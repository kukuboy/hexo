<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>animation</title>
    <url>/2020/07/23/animation/</url>
    <content><![CDATA[<h1 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h1><h2 id="作用-实现简单动画。"><a href="#作用-实现简单动画。" class="headerlink" title="作用:实现简单动画。"></a>作用:实现简单动画。</h2><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><pre><code>animation: name duration timing-function delay iteration-count direction fill-mode play-state;</code></pre><p>其中，</p>
<ol>
<li>name: animation-name简写，需要绑定的keyframe名称（其中规定了位置从哪儿到哪儿）</li>
<li>duration: animation-duration简写，规定整个过程花费时间。（单位：s/ms）</li>
<li>timing-function: animation-timing-function简写，整个过程的速度曲线（先快后慢ease-out、先慢后快ease-in、匀速linear等）</li>
<li>delay: animation-delay简写，动画开始之前的延迟。（单位：s/ms）</li>
<li>iteration-count： animation-iteration-count简写，动画循环次数。（无限infinite、自定义次数n）</li>
<li>direction： animation-direction：简写，是否轮流反方向播放。（normal正常播放、alternate轮流反方向播放）</li>
<li>fill-mode：animation-fill-mode简写，CSS动画在执行之前和之后如何将样式应用于其目标（none当动画未执行时，动画将不会将任何样式应用于目标，forwards目标将保留由执行期间遇到的最后一个关键帧计算值，backwards动画将在应用于目标时立即应用第一个关键帧中定义的值，both动画将遵循forwards和backwards的规则）</li>
<li>play-state：animation-play-state简写， CSS 属性定义一个动画是否运行或者暂停。（running当前动画正在运行，paused当前动画已被停止。）兼容性较差，尚在实验-2020-12</li>
</ol>
<h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><pre><code>// html部分
 &lt;div class=&quot;move&quot;&gt;&lt;/div&gt;
// css部分
@keyframes mymove{
    from{left: 0;}
    to{left: 80%;}
}
.move{
    height: 100px;
    width: 100px;
    position: relative;
    background: red;
    animation: mymove 5s infinite alternate linear;
}</code></pre><p>其中，</p>
<ol>
<li>注意@keyframes的用法，mymove就是animation中的name值，from规定起始位置，to规定结束位置。</li>
<li>注意一定要设置相对定位。</li>
<li>对于其中，参数位置的要求并没有十分严格，也就是说animation中顺序可以不按照语法中的顺序来写。</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css</title>
    <url>/2020/07/22/css/</url>
    <content><![CDATA[<h1 id="html居中的方法"><a href="#html居中的方法" class="headerlink" title="html居中的方法"></a>html居中的方法</h1><blockquote>
<p>可做对应修改值居中水平方向或者竖直方向</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">max-height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="css画三角形或者平行四边形"><a href="#css画三角形或者平行四边形" class="headerlink" title="css画三角形或者平行四边形"></a>css画三角形或者平行四边形</h1><blockquote>
<p>主要利用的边框拥有一定的厚度后，在转角处是以div的中心到角的线平分的，这个时候利用透明即可实现</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 三角形 */</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 平行四边形 */</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">50px</span>;</span><br><span class="line">    <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html居中的方法</tag>
        <tag>css画三角形或者平行四边形</tag>
      </tags>
  </entry>
  <entry>
    <title>canvas相关知识</title>
    <url>/2020/09/22/canvas%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>此文章做个人笔记，仅供参阅，来源：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API" target="_blank" rel="noopener">Canvas</a></p>
<h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p><strong>Canvas API 提供了一个通过JavaScript 和 HTML的&lt;canvas&gt;元素来绘制图形的方式。它可以用于动画、游戏画面、数据可视化、图片编辑以及实时视频处理等方面。<br>Canvas API主要聚焦于2D图形。而同样使用&lt;\canvas&gt;元素的 WebGL API 则用于绘制硬件加速的2D和3D图形。</strong></p>
<hr>
<h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><pre><code>&lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;
---
const canvas = document.getElementById(&apos;canvas&apos;);
const ctx = canvas.getContext(&apos;2d&apos;);</code></pre><hr>
<h1 id="检查支持性"><a href="#检查支持性" class="headerlink" title="检查支持性"></a>检查支持性</h1><pre><code>&lt;canvas id=&quot;tutorial&quot; width=&quot;150&quot; height=&quot;150&quot;&gt;
canvas在此不被支持
&lt;/canvas&gt;

var canvas = document.getElementById(&apos;tutorial&apos;);

if (canvas.getContext){
var ctx = canvas.getContext(&apos;2d&apos;);
// drawing code here
} else {
// canvas-unsupported code here
}</code></pre><h1 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h1><p><strong>不同于 SVG,&lt;canvas&gt; 只支持两种形式的图形绘制：矩形和路径（由一系列点连成的线段）。所有其他类型的图形都是通过一条或者多条路径组合而成的。不过，我们拥有众多路径生成的方法让复杂图形的绘制成为了可能</strong></p>
<p><strong>canvas提供了三种方法绘制矩形</strong></p>
<pre><code>fillRect(x, y, width, height)
绘制一个填充的矩形
strokeRect(x, y, width, height)
绘制一个矩形的边框
clearRect(x, y, width, height)
清除指定矩形区域，让清除部分完全透明。</code></pre><h1 id="绘制路径"><a href="#绘制路径" class="headerlink" title="绘制路径"></a>绘制路径</h1><p><strong>图形的基本元素是路径。路径是通过不同颜色和宽度的线段或曲线相连形成的不同形状的点的集合。一个路径，甚至一个子路径，都是闭合的。使用路径绘制图形需要一些额外的步骤。</strong></p>
<ol>
<li>首先，你需要创建路径起始点。</li>
<li>然后你使用画图命令去画出路径。</li>
<li>之后你把路径封闭。</li>
<li>一旦路径生成，你就能通过描边或填充路径区域来渲染图形。</li>
</ol>
<p><strong>以下是所要用到的函数：</strong></p>
<pre><code>beginPath()
新建一条路径，生成之后，图形绘制命令被指向到路径上生成路径。
closePath()
闭合路径之后图形绘制命令又重新指向到上下文中。
stroke()
通过线条来绘制图形轮廓。
fill()
通过填充路径的内容区域生成实心的图形。</code></pre><ol>
<li><p>生成路径的第一步叫做beginPath()。本质上，路径是由很多子路径构成，这些子路径都是在一个列表中，所有的子路径（线、弧形、等等）构成图形。而每次这个方法调用之后，列表清空重置，然后我们就可以重新绘制新的图形。  </p>
<blockquote>
<p>注意：当前路径为空，即调用beginPath()之后，或者canvas刚建的时候，第一条路径构造命令通常被视为是moveTo（），无论实际上是什么。出于这个原因，你几乎总是要在设置路径之后专门指定你的起始位置。</p>
</blockquote>
</li>
<li><p>调用函数指定绘制路径</p>
</li>
<li><p>就是闭合路径closePath(),不是必需的。这个方法会通过绘制一条从当前点到开始点的直线来闭合图形。如果图形是已经闭合了的，即当前点为开始点，该函数什么也不做。</p>
<p> 绘制三角形的代码如下：</p>
<pre><code>function draw() {
var canvas = document.getElementById(&apos;canvas&apos;);
if (canvas.getContext) {
    var ctx = canvas.getContext(&apos;2d&apos;);

    ctx.beginPath();
    ctx.moveTo(75, 50);
    ctx.lineTo(100, 75);
    ctx.lineTo(100, 25);
    ctx.fill();
}
}</code></pre></li>
</ol>
<h2 id="移动笔触"><a href="#移动笔触" class="headerlink" title="移动笔触"></a>移动笔触</h2><pre><code>moveTo(x, y)
将笔触移动到指定的坐标x以及y上。
当canvas初始化或者beginPath()调用后，你通常会使用moveTo()函数设置起点。我们也能够使用moveTo()绘制一些不连续的路径。看一下下面的笑脸例子。我将用到moveTo()方法（红线处）的地方标记了。</code></pre><h2 id="绘制直线"><a href="#绘制直线" class="headerlink" title="绘制直线"></a>绘制直线</h2><pre><code>lineTo(x, y)
绘制一条从当前位置到指定x以及y位置的直线。
该方法有两个参数：x以及y ，代表坐标系中直线结束的点。开始点和之前的绘制路径有关，之前路径的结束点就是接下来的开始点，等等。。。开始点也可以通过moveTo()函数改变。</code></pre><h2 id="圆弧"><a href="#圆弧" class="headerlink" title="圆弧"></a>圆弧</h2><pre><code>绘制圆弧或者圆，我们使用arc()方法。当然可以使用arcTo()，不过这个的实现并不是那么的可靠，所以我们这里不作介绍。

arc(x, y, radius, startAngle, endAngle, anticlockwise)
画一个以（x,y）为圆心的以radius为半径的圆弧（圆），从startAngle开始到endAngle结束，按照anticlockwise给定的方向（默认为顺时针）来生成。
arcTo(x1, y1, x2, y2, radius)
根据给定的控制点和半径画一段圆弧，再以直线连接两个控制点。
这里详细介绍一下arc方法，该方法有六个参数：x,y为绘制圆弧所在圆上的圆心坐标。radius为半径。startAngle以及endAngle参数用弧度定义了开始以及结束的弧度。这些都是以x轴为基准。参数anticlockwise为一个布尔值。为true时，是逆时针方向，否则顺时针方向。

注意：arc()函数中表示角的单位是弧度，不是角度。角度与弧度的js表达式:

弧度=(Math.PI/180)*角度。</code></pre><h2 id="矩形"><a href="#矩形" class="headerlink" title="矩形"></a>矩形</h2><pre><code>直接在画布上绘制矩形的三个额外方法，正如我们开始所见的绘制矩形，同样，也有rect()方法，将一个矩形路径增加到当前路径上。

rect(x, y, width, height)
绘制一个左上角坐标为（x,y），宽高为width以及height的矩形。
当该方法执行的时候，moveTo()方法自动设置坐标参数（0,0）。也就是说，当前笔触自动重置回默认坐标。</code></pre><h2 id="Path2D-对象"><a href="#Path2D-对象" class="headerlink" title="Path2D 对象"></a>Path2D 对象</h2><pre><code>Path2D()会返回一个新初始化的Path2D对象（可能将某一个路径作为变量——创建一个它的副本，或者将一个包含SVG path数据的字符串作为变量）。
new Path2D();     // 空的Path对象
new Path2D(path); // 克隆Path对象
new Path2D(d);    // 从SVG建立Path对象
在这个例子中，我们创造了一个矩形和一个圆。它们都被存为Path2D对象，后面再派上用场。随着新的Path2D API产生，几种方法也相应地被更新来使用Path2D对象而不是当前路径。在这里，带路径参数的stroke和fill可以把对象画在画布上。
function draw() {
var canvas = document.getElementById(&apos;canvas&apos;);
if (canvas.getContext){
    var ctx = canvas.getContext(&apos;2d&apos;);

    var rectangle = new Path2D();
    rectangle.rect(10, 10, 50, 50);

    var circle = new Path2D();
    circle.moveTo(125, 35);
    circle.arc(100, 35, 25, 0, 2 * Math.PI);

    ctx.stroke(rectangle);
    ctx.fill(circle);
}
}</code></pre><h1 id="色彩-Colors"><a href="#色彩-Colors" class="headerlink" title="色彩 Colors"></a>色彩 Colors</h1><pre><code>fillStyle = color
设置图形的填充颜色。
strokeStyle = color
设置图形轮廓的颜色。</code></pre><p><strong>注意: 一旦您设置了 strokeStyle 或者 fillStyle 的值，那么这个新值就会成为新绘制的图形的默认值。如果你要给每个图形上不同的颜色，你需要重新设置 fillStyle 或 strokeStyle 的值。</strong></p>
<h2 id="颜色标准"><a href="#颜色标准" class="headerlink" title="颜色标准"></a>颜色标准</h2><pre><code>// 这些 fillStyle 的值均为 &apos;橙色&apos;
ctx.fillStyle = &quot;orange&quot;;
ctx.fillStyle = &quot;#FFA500&quot;;
ctx.fillStyle = &quot;rgb(255,165,0)&quot;;
ctx.fillStyle = &quot;rgba(255,165,0,1)&quot;;</code></pre><h1 id="透明度-globalAlpha"><a href="#透明度-globalAlpha" class="headerlink" title="透明度 globalAlpha"></a>透明度 globalAlpha</h1><p><strong>globalAlpha = transparencyValue<br>这个属性影响到 canvas 里所有图形的透明度，有效的值范围是 0.0 （完全透明）到 1.0（完全不透明），默认是 1.0。</strong></p>
<h1 id="线型-Line-styles"><a href="#线型-Line-styles" class="headerlink" title="线型 Line styles"></a>线型 Line styles</h1><blockquote>
<p>可以通过一系列属性来设置线的样式。  </p>
</blockquote>
<ol>
<li>lineWidth 属性<br>这个属性设置当前绘线的粗细。属性值必须为正数。默认值是1.0。</li>
</ol>
<blockquote>
<p>较为准确的情况下，由于机制为由中心向两边延伸，宽度为1时可坐标可多加0.5</p>
</blockquote>
<ol start="2">
<li><p>lineCap 属性<br>属性 lineCap 的值决定了线段端点显示的样子。它可以为下面的三种的其中之一：butt，round 和 square。默认是 butt。square默认比butt长出宽度的一半</p>
</li>
<li><p>lineJoin 属性<br>lineJoin 的属性值决定了图形中两线段连接处所显示的样子。它可以是这三种之一：round, bevel 和 miter。默认是 miter。拐角的连接样式</p>
</li>
<li><p>miterLimit 属性<br>miterLimit 属性就是用来设定外延交点与连接点的最大距离，如果交点距离大于此值，连接效果会变成了 bevel。</p>
</li>
<li><p>虚线<br>用 setLineDash 方法和 lineDashOffset 属性来制定虚线样式. setLineDash 方法接受一个数组，来指定线段与间隙的交替；lineDashOffset 属性设置起始偏移量.</p>
<p> ctx.setLineDash([4, 2]);<br> ctx.lineDashOffset = -offset;</p>
</li>
</ol>
<h1 id="渐变-Gradients"><a href="#渐变-Gradients" class="headerlink" title="渐变 Gradients"></a>渐变 Gradients</h1><p>就好像一般的绘图软件一样，我们可以用线性或者径向的渐变来填充或描边。我们用下面的方法新建一个 canvasGradient 对象，并且赋给图形的 fillStyle 或 strokeStyle 属性。</p>
<pre><code>createLinearGradient(x1, y1, x2, y2)
createLinearGradient 方法接受 4 个参数，表示渐变的起点 (x1,y1) 与终点 (x2,y2)。
createRadialGradient(x1, y1, r1, x2, y2, r2)
createRadialGradient 方法接受 6 个参数，前三个定义一个以 (x1,y1) 为原点，半径为 r1 的圆，后三个参数则定义另一个以 (x2,y2) 为原点，半径为 r2 的圆。

var lineargradient = ctx.createLinearGradient(0,0,150,150);
var radialgradient = ctx.createRadialGradient(75,75,0,75,75,100);

创建出 canvasGradient 对象后，我们就可以用 addColorStop 方法给它上色了。

gradient.addColorStop(position, color)
addColorStop 方法接受 2 个参数，position 参数必须是一个 0.0 与 1.0 之间的数值，表示渐变中颜色所在的相对位置。例如，0.5 表示颜色会出现在正中间。color 参数必须是一个有效的 CSS 颜色值（如 #FFF， rgba(0,0,0,1)，等等）。
你可以根据需要添加任意多个色标（color stops）。下面是最简单的线性黑白渐变的例子。

var lineargradient = ctx.createLinearGradient(0,0,150,150);
lineargradient.addColorStop(0,&apos;white&apos;);
lineargradient.addColorStop(1,&apos;black&apos;);


例子
function draw() {
var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);

// 创建渐变
var radgrad = ctx.createRadialGradient(45,45,10,52,50,30);
radgrad.addColorStop(0, &apos;#A7D30C&apos;);
radgrad.addColorStop(0.9, &apos;#019F62&apos;);
radgrad.addColorStop(1, &apos;rgba(1,159,98,0)&apos;);

var radgrad2 = ctx.createRadialGradient(105,105,20,112,120,50);
radgrad2.addColorStop(0, &apos;#FF5F98&apos;);
radgrad2.addColorStop(0.75, &apos;#FF0188&apos;);
radgrad2.addColorStop(1, &apos;rgba(255,1,136,0)&apos;);

var radgrad3 = ctx.createRadialGradient(95,15,15,102,20,40);
radgrad3.addColorStop(0, &apos;#00C9FF&apos;);
radgrad3.addColorStop(0.8, &apos;#00B5E2&apos;);
radgrad3.addColorStop(1, &apos;rgba(0,201,255,0)&apos;);

var radgrad4 = ctx.createRadialGradient(0,150,50,0,140,90);
radgrad4.addColorStop(0, &apos;#F4F201&apos;);
radgrad4.addColorStop(0.8, &apos;#E4C700&apos;);
radgrad4.addColorStop(1, &apos;rgba(228,199,0,0)&apos;);

// 画图形
ctx.fillStyle = radgrad4;
ctx.fillRect(0,0,150,150);
ctx.fillStyle = radgrad3;
ctx.fillRect(0,0,150,150);
ctx.fillStyle = radgrad2;
ctx.fillRect(0,0,150,150);
ctx.fillStyle = radgrad;
ctx.fillRect(0,0,150,150);
}</code></pre><h1 id="阴影-Shadows"><a href="#阴影-Shadows" class="headerlink" title="阴影 Shadows"></a>阴影 Shadows</h1><pre><code>shadowOffsetX = float
shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。

shadowOffsetY = float
shadowOffsetX 和 shadowOffsetY 用来设定阴影在 X 和 Y 轴的延伸距离，它们是不受变换矩阵所影响的。负值表示阴影会往上或左延伸，正值则表示会往下或右延伸，它们默认都为 0。
shadowBlur = float
shadowBlur 用于设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响，默认为 0。
shadowColor = color
shadowColor 是标准的 CSS 颜色值，用于设定阴影颜色效果，默认是全透明的黑色

个例子绘制了带阴影效果的文字。

function draw() {
var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);

ctx.shadowOffsetX = 2;
ctx.shadowOffsetY = 2;
ctx.shadowBlur = 2;
ctx.shadowColor = &quot;rgba(0, 0, 0, 0.5)&quot;;

ctx.font = &quot;20px Times New Roman&quot;;
ctx.fillStyle = &quot;Black&quot;;
ctx.fillText(&quot;Sample String&quot;, 5, 30);
}</code></pre><h1 id="Canvas-填充规则"><a href="#Canvas-填充规则" class="headerlink" title="Canvas 填充规则"></a>Canvas 填充规则</h1><p>当我们用到 fill（或者 clip和isPointinPath ）你可以选择一个填充规则，该填充规则根据某处在路径的外面或者里面来决定该处是否被填充，这对于自己与自己路径相交或者路径被嵌套的时候是有用的。</p>
<p>两个可能的值：</p>
<p> “nonzero”: non-zero winding rule, 默认值.<br> “evenodd”:  even-odd winding rule.</p>
<pre><code>function draw() {
var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;); 
ctx.beginPath(); 
ctx.arc(50, 50, 30, 0, Math.PI*2, true);
ctx.arc(50, 50, 15, 0, Math.PI*2, true);
ctx.fill(&quot;evenodd&quot;);
}</code></pre><h1 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h1><h2 id="绘制文本-1"><a href="#绘制文本-1" class="headerlink" title="绘制文本"></a>绘制文本</h2><pre><code>canvas 提供了两种方法来渲染文本:蛀牙是实心空心的区别

fillText(text, x, y [, maxWidth])
在指定的(x,y)位置填充指定的文本，绘制的最大宽度是可选的.
strokeText(text, x, y [, maxWidth])
在指定的(x,y)位置绘制文本边框，绘制的最大宽度是可选的.</code></pre><h2 id="有样式的文本"><a href="#有样式的文本" class="headerlink" title="有样式的文本"></a>有样式的文本</h2><p>在上面的例子用我们已经使用了 font 来使文本比默认尺寸大一些. 还有更多的属性可以让你改变canvas显示文本的方式：</p>
<pre><code>font = value
当前我们用来绘制文本的样式. 这个字符串使用和 CSS font 属性相同的语法. 默认的字体是 10px sans-serif。
textAlign = value
文本对齐选项. 可选的值包括：start, end, left, right or center. 默认值是 start。
textBaseline = value
基线对齐选项. 可选的值包括：top, hanging, middle, alphabetic, ideographic, bottom。默认值是 alphabetic。
direction = value
文本方向。可能的值包括：ltr, rtl, inherit。默认值是 inherit。</code></pre><h2 id="预测量文本宽度"><a href="#预测量文本宽度" class="headerlink" title="预测量文本宽度"></a>预测量文本宽度</h2><p>measureText()<br>将返回一个 TextMetrics对象的宽度、所在像素，这些体现文本特性的属性。<br>下面的代码段将展示如何测量文本来获得它的宽度：</p>
<pre><code>function draw() {
var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);
var text = ctx.measureText(&quot;foo&quot;); // TextMetrics object
text.width; // 16;
}</code></pre><h1 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h1><pre><code>function draw() {
    var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);
    var img = new Image();
    img.onload = function(){
    ctx.drawImage(img,0,0);
    ctx.beginPath();
    ctx.moveTo(30,96);
    ctx.lineTo(70,66);
    ctx.lineTo(103,76);
    ctx.lineTo(170,15);
    ctx.stroke();
    }
    img.src = &apos;images/backdrop.png&apos;;
}</code></pre><h2 id="缩放-Scaling"><a href="#缩放-Scaling" class="headerlink" title="缩放 Scaling"></a>缩放 Scaling</h2><pre><code>drawImage(image, x, y, width, height)
这个方法多了2个参数：width 和 height，这两个参数用来控制 当向canvas画入时应该缩放的大小</code></pre><h2 id="切片-Slicing"><a href="#切片-Slicing" class="headerlink" title="切片 Slicing"></a>切片 Slicing</h2><pre><code>drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
第一个参数和其它的是相同的，都是一个图像或者另一个 canvas 的引用。其它8个参数最好是参照右边的图解，前4个是定义图像源的切片位置和大小，后4个则是定义切片的目标显示位置和大小。

思考：可用画框和图片实现多个画廊</code></pre><h2 id="状态的保存和恢复"><a href="#状态的保存和恢复" class="headerlink" title="状态的保存和恢复"></a>状态的保存和恢复</h2><pre><code>save()
保存画布(canvas)的所有状态
restore()
save 和 restore 方法是用来保存和恢复 canvas 状态的，都没有参数。Canvas 的状态就是当前画面应用的所有样式和变形的一个快照。</code></pre><p>Canvas状态存储在栈中，每当save()方法被调用后，当前的状态就被推送到栈中保存。一个绘画状态包括：</p>
<ul>
<li>当前应用的变形（即移动，旋转和缩放，见下）</li>
<li>以及下面这些属性：strokeStyle, fillStyle, globalAlpha, lineWidth, lineCap, lineJoin, miterLimit, lineDashOffset, shadowOffsetX, shadowOffsetY, shadowBlur, shadowColor, globalCompositeOperation, font, textAlign, textBaseline, direction, imageSmoothingEnabled</li>
<li>当前的裁切路径（clipping path），会在下一节介绍<br>你可以调用任意多次 save方法。每一次调用 restore 方法，上一个保存的状态就从栈中弹出，所有设定都恢复。</li>
</ul>
<h2 id="移动-Translating"><a href="#移动-Translating" class="headerlink" title="移动 Translating"></a>移动 Translating</h2><pre><code>translate(x, y)
translate 方法接受两个参数。x 是左右偏移量，y 是上下偏移量，如右图所示。</code></pre><h2 id="旋转-Rotating"><a href="#旋转-Rotating" class="headerlink" title="旋转 Rotating"></a>旋转 Rotating</h2><p>它用于以原点为中心旋转 canvas。</p>
<pre><code>rotate(angle)  
这个方法只接受一个参数：旋转的角度(angle)，它是顺时针方向的，以弧度为单位的值。  
旋转的中心点始终是 canvas 的原点，如果要改变它，我们需要用到 translate 方法。</code></pre><h2 id="缩放-Scaling-1"><a href="#缩放-Scaling-1" class="headerlink" title="缩放 Scaling"></a>缩放 Scaling</h2><p>我们用它来增减图形在 canvas 中的像素数目，对形状，位图进行缩小或者放大。  </p>
<pre><code>scale(x, y)  
scale  方法可以缩放画布的水平和垂直的单位。两个参数都是实数，可以为负数，x 为水平缩放因子，y 为垂直缩放因子，如果比1小，会比缩放图形， 如果比1大会放大图形。默认值为1， 为实际大小。  
画布初始情况下， 是以左上角坐标为原点的第一象限。如果参数为负实数， 相当于以x 或 y轴作为对称轴镜像反转（例如， 使用translate(0,canvas.height); scale(1,-1); 以y轴作为对称轴镜像反转， 就可得到著名的笛卡尔坐标系，左下角为原点）。  

默认情况下，canvas 的 1 个单位为 1 个像素。举例说，如果我们设置缩放因子是 0.5，1 个单位就变成对应 0.5 个像素，这样绘制出来的形状就会是原先的一半。同理，设置为 2.0 时，1 个单位就对应变成了 2 像素，绘制的结果就是图形放大了 2 倍。</code></pre><h2 id="变形-Transforms"><a href="#变形-Transforms" class="headerlink" title="变形 Transforms"></a>变形 Transforms</h2><p>允许对变形矩阵直接修改。</p>
<pre><code>transform(a, b, c, d, e, f)
这个方法是将当前的变形矩阵乘上一个基于自身参数的矩阵，如下面的矩阵所示：[ a    c    e    b    d    f    0    0    1 ]
如果任意一个参数是Infinity，变形矩阵也必须被标记为无限大，否则会抛出异常。
这个函数的参数各自代表如下：

a (m11)
水平方向的缩放
b(m12)
水平方向的倾斜偏移
c(m21)
竖直方向的倾斜偏移
d(m22)
竖直方向的缩放
e(dx)
水平方向的移动
f(dy)
竖直方向的移动
setTransform(a, b, c, d, e, f)
这个方法会将当前的变形矩阵重置为单位矩阵，然后用相同的参数调用 transform 方法。如果任意一个参数是无限大，那么变形矩阵也必须被标记为无限大，否则会抛出异常。从根本上来说，该方法是取消了当前变形,然后设置为指定的变形,一步完成。
resetTransform()
重置当前变形为单位矩阵，它和调用以下语句是一样的：ctx.setTransform(1, 0, 0, 1, 0, 0);</code></pre><h2 id="新图案覆盖原则"><a href="#新图案覆盖原则" class="headerlink" title="新图案覆盖原则"></a>新图案覆盖原则</h2><p><strong>globalCompositeOperation</strong><br>    globalCompositeOperation = type<br>    这个属性设定了在画新图形时采用的遮盖策略，其值是一个标识12种遮盖方式的字符串。</p>
<pre><code>source-over
这是默认设置，并在现有画布上下文之上绘制新图形。


source-in
新图形只在新图形和目标画布重叠的地方绘制。其他的都是透明的。

source-out
在不与现有画布内容重叠的地方绘制新图形。

source-atop
新图形只在与现有画布内容重叠的地方绘制。

destination-over
在现有的画布内容后面绘制新的图形。

destination-in
现有的画布内容保持在新图形和现有画布内容重叠的位置。其他的都是透明的。

destination-out
现有内容保持在新图形不重叠的地方。

destination-atop
现有的画布只保留与新图形重叠的部分，新的图形是在画布内容后面绘制的

lighter
两个重叠图形的颜色是通过颜色值相加来确定的。

copy
只显示新图形。

xor
图像中，那些重叠和正常绘制之外的其他地方是透明的。

multiply
将顶层像素与底层相应像素相乘，结果是一幅更黑暗的图片。

screen
像素被倒转，相乘，再倒转，结果是一幅更明亮的图片。

overlay
multiply和screen的结合，原本暗的地方更暗，原本亮的地方更亮。

darken
保留两个图层中最暗的像素。

lighten
保留两个图层中最亮的像素。

color-dodge
将底层除以顶层的反置。

color-burn
将反置的底层除以顶层，然后将结果反过来。

hard-light
屏幕相乘（A combination of multiply and screen）类似于叠加，但上下图层互换了

soft-light
用顶层减去底层或者相反来得到一个正值。

difference
一个柔和版本的强光（hard-light）。纯黑或纯白不会导致纯黑或纯白。

exclusion
和difference相似，但对比度较低。

hue
保留了底层的亮度（luma）和色度（chroma），同时采用了顶层的色调（hue）。

saturation
保留底层的亮度（luma）和色调（hue），同时采用顶层的色度（chroma）。

color
保留了底层的亮度（luma），同时采用了顶层的色调(hue)和色度(chroma)。

luminosity
保持底层的色调（hue）和色度（chroma），同时采用顶层的亮度（luma）。</code></pre><h1 id="裁切路径"><a href="#裁切路径" class="headerlink" title="裁切路径"></a>裁切路径</h1><p>裁切路径和普通的 canvas 图形差不多，不同的是它的作用是遮罩，用来隐藏不需要的部分。如右图所示。红边五角星就是裁切路径，所有在路径以外的部分都不会在 canvas 上绘制出来。</p>
<p>如果和上面介绍的 globalCompositeOperation 属性作一比较，它可以实现与 source-in 和 source-atop差不多的效果。最重要的区别是裁切路径不会在 canvas 上绘制东西，而且它永远不受新图形的影响。这些特性使得它在特定区域里绘制图形时相当好用。</p>
<p>在 绘制图形 一章中，只介绍了 stroke 和 fill 方法，这里介绍第三个方法clip</p>
<pre><code>clip()
将当前正在构建的路径转换为当前的裁剪路径。

默认情况下，canvas 有一个与它自身一样大的裁切路径（也就是没有裁切效果）。

这个例子，我会用一个圆形的裁切路径来限制随机星星的绘制区域。

function draw() {
var ctx = document.getElementById(&apos;canvas&apos;).getContext(&apos;2d&apos;);
ctx.fillRect(0,0,150,150);
ctx.translate(75,75);

// Create a circular clipping path
ctx.beginPath();
ctx.arc(0,0,60,0,Math.PI*2,true);
ctx.clip();

// draw background
var lingrad = ctx.createLinearGradient(0,-75,0,75);
lingrad.addColorStop(0, &apos;#232256&apos;);
lingrad.addColorStop(1, &apos;#143778&apos;);

ctx.fillStyle = lingrad;
ctx.fillRect(-75,-75,150,150);

// draw stars
for (var j=1;j&lt;50;j++){
    ctx.save();
    ctx.fillStyle = &apos;#fff&apos;;
    ctx.translate(75-Math.floor(Math.random()*150),
                75-Math.floor(Math.random()*150));
    drawStar(ctx,Math.floor(Math.random()*4)+2);
    ctx.restore();
}

}
function drawStar(ctx,r){
ctx.save();
ctx.beginPath()
ctx.moveTo(r,0);
for (var i=0;i&lt;9;i++){
    ctx.rotate(Math.PI/5);
    if(i%2 == 0) {
    ctx.lineTo((r/0.525731)*0.200811,0);
    } else {
    ctx.lineTo(r,0);
    }
}
ctx.closePath();
ctx.fill();
ctx.restore();
}

首先，我画了一个与 canvas 一样大小的黑色方形作为背景，然后移动原点至中心点。然后用 clip 方法创建一个弧形的裁切路径。裁切路径也属于 canvas 状态的一部分，可以被保存起来。如果我们在创建新裁切路径时想保留原来的裁切路径，我们需要做的就是保存一下 canvas 的状态。

裁切路径创建之后所有出现在它里面的东西才会画出来。在画线性渐变时我们就会注意到这点。然后会绘制出50 颗随机位置分布（经过缩放）的星星，当然也只有在裁切路径里面的星星才会绘制出来。</code></pre><h1 id="基本动画"><a href="#基本动画" class="headerlink" title="基本动画"></a>基本动画</h1><h2 id="动画的基本步骤"><a href="#动画的基本步骤" class="headerlink" title="动画的基本步骤"></a>动画的基本步骤</h2><p>你可以通过以下的步骤来画出一帧:</p>
<ol>
<li>清空 canvas<br>除非接下来要画的内容会完全充满 canvas （例如背景图），否则你需要清空所有。最简单的做法就是用 clearRect 方法。</li>
<li>保存 canvas 状态<br>如果你要改变一些会改变 canvas 状态的设置（样式，变形之类的），又要在每画一帧之时都是原始状态的话，你需要先保存一下。</li>
<li>绘制动画图形（animated shapes）<br>这一步才是重绘动画帧。</li>
<li>恢复 canvas 状态<br>如果已经保存了 canvas 的状态，可以先恢复它，然后重绘下一帧。</li>
</ol>
<h2 id="有安排的更新画布-Scheduled-updates"><a href="#有安排的更新画布-Scheduled-updates" class="headerlink" title="有安排的更新画布 Scheduled updates"></a>有安排的更新画布 Scheduled updates</h2><p>首先，可以用window.setInterval(), window.setTimeout(),和window.requestAnimationFrame()来设定定期执行一个指定函数。</p>
<pre><code>setInterval(function, delay)
当设定好间隔时间后，function会定期执行。
setTimeout(function, delay)
在设定好的时间之后执行函数
requestAnimationFrame(callback)
告诉浏览器你希望执行一个动画，并在重绘之前，请求浏览器执行一个特定的函数来更新动画。
如果你并不需要与用户互动，你可以使用setInterval()方法，它就可以定期执行指定代码。如果我们需要做一个游戏，我们可以使用键盘或者鼠标事件配合上setTimeout()方法来实现。通过设置事件监听，我们可以捕捉用户的交互，并执行相应的动作。</code></pre><p>下面的例子，采用 window.requestAnimationFrame()实现动画效果。这个方法提供了更加平缓并更加有效率的方式来执行动画，当系统准备好了重绘条件的时候，才调用绘制动画帧。一般每秒钟回调函数执行60次，也有可能会被降低。想要了解更多关于动画循环的信息，尤其是游戏，可以在Game development zone 参考这篇文章 Anatomy of a video game。</p>
<h2 id="鼠标追踪动画"><a href="#鼠标追踪动画" class="headerlink" title="鼠标追踪动画"></a>鼠标追踪动画</h2><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
    &lt;head&gt;
        &lt;meta charset=&quot;UTF-8&quot;&gt;
        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
        &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;
        &lt;title&gt;Document&lt;/title&gt;
        &lt;script&gt;
            var cn;
            //= document.getElementById(&apos;cw&apos;);
            var c;
            var u = 10;
            const m = {
                x: innerWidth / 2,
                y: innerHeight / 2
            };
            window.onmousemove = function(e) {
                m.x = e.clientX;
                m.y = e.clientY;

            }
            function gc() {
                var s = &quot;0123456789ABCDEF&quot;;
                var c = &quot;#&quot;;
                for (var i = 0; i &lt; 6; i++) {
                    c += s[Math.ceil(Math.random() * 15)]
                }
                return c
            }
            var a = [];
            window.onload = function myfunction() {
                cn = document.getElementById(&apos;cw&apos;);
                c = cn.getContext(&apos;2d&apos;);

                for (var i = 0; i &lt; 10; i++) {
                    var r = 30;
                    var x = Math.random() * (innerWidth - 2 * r) + r;
                    var y = Math.random() * (innerHeight - 2 * r) + r;
                    var t = new ob(innerWidth / 2,innerHeight / 2,5,&quot;red&quot;,Math.random() * 200 + 20,2);
                    a.push(t);
                }
                //cn.style.backgroundColor = &quot;#700bc8&quot;;

                c.lineWidth = &quot;2&quot;;
                c.globalAlpha = 0.5;
                resize();
                anim()
            }
            window.onresize = function() {

                resize();

            }
            function resize() {
                cn.height = innerHeight;
                cn.width = innerWidth;
                for (var i = 0; i &lt; 101; i++) {
                    var r = 30;
                    var x = Math.random() * (innerWidth - 2 * r) + r;
                    var y = Math.random() * (innerHeight - 2 * r) + r;
                    a[i] = new ob(innerWidth / 2,innerHeight / 2,4,gc(),Math.random() * 200 + 20,0.02);

                }
                //  a[0] = new ob(innerWidth / 2, innerHeight / 2, 40, &quot;red&quot;, 0.05, 0.05);
                //a[0].dr();
            }
            function ob(x, y, r, cc, o, s) {
                this.x = x;
                this.y = y;
                this.r = r;
                this.cc = cc;
                this.theta = Math.random() * Math.PI * 2;
                this.s = s;
                this.o = o;
                this.t = Math.random() * 150;

                this.o = o;
                this.dr = function() {
                    const ls = {
                        x: this.x,
                        y: this.y
                    };
                    this.theta += this.s;
                    this.x = m.x + Math.cos(this.theta) * this.t;
                    this.y = m.y + Math.sin(this.theta) * this.t;
                    c.beginPath();
                    c.lineWidth = this.r;
                    c.strokeStyle = this.cc;
                    c.moveTo(ls.x, ls.y);
                    c.lineTo(this.x, this.y);
                    c.stroke();
                    c.closePath();

                }
            }
            function anim() {
                requestAnimationFrame(anim);
                c.fillStyle = &quot;rgba(0,0,0,0.05)&quot;;
                c.fillRect(0, 0, cn.width, cn.height);
                a.forEach(function(e, i) {
                    e.dr();
                });

            }
        &lt;/script&gt;
        &lt;style&gt;
            #cw {
                position: fixed;
                z-index: -1;
            }

            body {
                margin: 0;
                padding: 0;
                background-color: rgba(0,0,0,0.05);
            }
        &lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;canvas id=&quot;cw&quot;&gt;&lt;/canvas&gt;
        qwerewr    

    &lt;/body&gt;
&lt;/html&gt;</code></pre><h1 id="像素操作"><a href="#像素操作" class="headerlink" title="像素操作"></a>像素操作</h1><h2 id="ImageData-对象"><a href="#ImageData-对象" class="headerlink" title="ImageData 对象"></a>ImageData 对象</h2><p>ImageData对象中存储着canvas对象真实的像素数据，它包含以下几个只读属性：</p>
<pre><code>width

图片宽度，单位是像素
height
图片高度，单位是像素
data
Uint8ClampedArray类型的一维数组，包含着RGBA格式的整型数据，范围在0至255之间（包括255）。</code></pre><p>data属性返回一个 Uint8ClampedArray，它可以被使用作为查看初始像素数据。每个像素用4个1bytes值(按照红，绿，蓝和透明值的顺序; 这就是”RGBA”格式) 来代表。每个颜色值部份用0至255来代表。每个部份被分配到一个在数组内连续的索引，左上角像素的红色部份在数组的索引0位置。像素从左到右被处理，然后往下，遍历整个数组。</p>
<p>Uint8ClampedArray  包含高度 × 宽度 × 4 bytes数据，索引值从0到(高度×宽度×4)-1  </p>
<p>例如，要读取图片中位于第50行，第200列的像素的蓝色部份，你会写以下代码：</p>
<pre><code>blueComponent = imageData.data[((50 * (imageData.width * 4)) + (200 * 4)) + 2];</code></pre><p>根据行、列读取某像素点的R/G/B/A值的公式：</p>
<pre><code>imageData.data[((50 * (imageData.width * 4)) + (200 * 4)) + 0/1/2/3];</code></pre><p>你可能用会使用Uint8ClampedArray.length属性来读取像素数组的大小（以bytes为单位）：</p>
<pre><code>var numBytes = imageData.data.length;</code></pre><h2 id="创建一个ImageData对象"><a href="#创建一个ImageData对象" class="headerlink" title="创建一个ImageData对象"></a>创建一个ImageData对象</h2><p>去创建一个新的，空白的ImageData对象，你应该会使用createImageData() 方法。有2个版本的createImageData()方法。</p>
<pre><code>var myImageData = ctx.createImageData(width, height);</code></pre><p>上面代码创建了一个新的具体特定尺寸的ImageData对象。所有像素被预设为透明黑。</p>
<p>你也可以创建一个被anotherImageData对象指定的相同像素的ImageData对象。这个新的对象像素全部被预设为透明黑。这个并非复制了图片数据。</p>
<pre><code>var myImageData = ctx.createImageData(anotherImageData);</code></pre><h2 id="得到场景像素数据"><a href="#得到场景像素数据" class="headerlink" title="得到场景像素数据"></a>得到场景像素数据</h2><p>为了获得一个包含画布场景像素数据的ImageData对像，你可以用getImageData()方法：</p>
<pre><code>var myImageData = ctx.getImageData(left, top, width, height);
这个方法会返回一个ImageData对象，它代表了画布区域的对象数据，此画布的四个角落分别表示为(left, top), (left + width, top), (left, top + height), 以及(left + width, top + height)四个点。这些坐标点被设定为画布坐标空间元素。</code></pre><p>注：任何在画布以外的元素都会被返回成一个透明黑的ImageData对像。</p>
<h2 id="在场景中写入像素数据"><a href="#在场景中写入像素数据" class="headerlink" title="在场景中写入像素数据"></a>在场景中写入像素数据</h2><p>你可以用putImageData()方法去对场景进行像素数据的写入。</p>
<pre><code>ctx.putImageData(myImageData, dx, dy);
dx和dy参数表示你希望在场景内左上角绘制的像素数据所得到的设备坐标。</code></pre><h2 id="缩放和反锯齿"><a href="#缩放和反锯齿" class="headerlink" title="缩放和反锯齿"></a>缩放和反锯齿</h2><p>CanvasRenderingContext2D.imageSmoothingEnabled 是 Canvas 2D API 用来设置图片是否平滑的属性，true表示图片平滑（默认值），false表示图片不平滑。当我们获取 imageSmoothingEnabled 属性值时， 它会返回最新设置的值。</p>
<p> 以缩放画布为例，这个属性对像素为主的游戏很有用。默认的改变大小的算法会造成图片模糊并且破坏图片原有的像素。 如果那样的话，设置属性值为false。 参见 CSS image-rendering 属性。</p>
<p>注意:您可以使用imageSmoothingQuality属性来调整平滑质量。</p>
<pre><code>语法
ctx.imageSmoothingEnabled = value;
选项
value
一个Boolean 类型的值，表示图片是否平滑。


    &lt;canvas id=&quot;zoom&quot; width=&quot;300&quot; height=&quot;227&quot;&gt;&lt;/canvas&gt;
    &lt;div&gt;
    &lt;label for=&quot;smoothbtn&quot;&gt;
    &lt;input type=&quot;checkbox&quot; name=&quot;smoothbtn&quot; checked=&quot;checked&quot; id=&quot;smoothbtn&quot;&gt;
    Enable image smoothing
    &lt;/label&gt;
    &lt;/div&gt;
    var img = new Image();
    img.src = &apos;https://mdn.mozillademos.org/files/5397/rhino.jpg&apos;;
    img.onload = function() {
    draw(this);
    };

    function draw(img) {
    var canvas = document.getElementById(&apos;canvas&apos;);
    var ctx = canvas.getContext(&apos;2d&apos;);
    ctx.drawImage(img, 0, 0);
    img.style.display = &apos;none&apos;;
    var zoomctx = document.getElementById(&apos;zoom&apos;).getContext(&apos;2d&apos;);

    var smoothbtn = document.getElementById(&apos;smoothbtn&apos;);
    var toggleSmoothing = function(event) {
        zoomctx.imageSmoothingEnabled = this.checked;
        zoomctx.mozImageSmoothingEnabled = this.checked;
        zoomctx.webkitImageSmoothingEnabled = this.checked;
        zoomctx.msImageSmoothingEnabled = this.checked;
    };
    smoothbtn.addEventListener(&apos;change&apos;, toggleSmoothing);

    var zoom = function(event) {
        var x = event.layerX;
        var y = event.layerY;
        zoomctx.drawImage(canvas,
                        Math.abs(x - 5),
                        Math.abs(y - 5),
                        10, 10,
                        0, 0,
                        200, 200);
    };

    canvas.addEventListener(&apos;mousemove&apos;, zoom);
    }</code></pre><h2 id="保存图片"><a href="#保存图片" class="headerlink" title="保存图片"></a>保存图片</h2><p>HTMLCanvasElement  提供一个toDataURL()方法，此方法在保存图片的时候非常有用。它返回一个包含被类型参数规定的图像表现格式的数据链接。返回的图片分辨率是96dpi。</p>
<pre><code>canvas.toDataURL(&apos;image/png&apos;)
默认设定。创建一个PNG图片。
Default setting. Creates a PNG image.
canvas.toDataURL(&apos;image/jpeg&apos;, quality)
创建一个JPG图片。你可以有选择地提供从0到1的品质量，1表示最好品质，0基本不被辨析但有比较小的文件大小。
当你从画布中生成了一个数据链接，例如，你可以将它用于任何&lt;image&gt;元素，或者将它放在一个有download属性的超链接里用于保存到本地。

你也可以从画布中创建一个Blob对像。

canvas.toBlob(callback, type, encoderOptions)</code></pre><h1 id="点击区域和无障碍访问"><a href="#点击区域和无障碍访问" class="headerlink" title="点击区域和无障碍访问"></a>点击区域和无障碍访问</h1><h2 id="点击区域"><a href="#点击区域" class="headerlink" title="点击区域"></a>点击区域</h2><p>点击区域（hit region）<br>判断鼠标坐标是否在canvas上一个特定区域里一直是个有待解决的问题。hit region API让你可以在canvas上定义一个区域，这让无障碍工具获取canvas上的交互内容成为可能。它能让你更容易地进行点击检测并把事件转发到DOM元素去。这个API有以下三个方法（都是实验性特性，请先在浏览器兼容表上确认再使用）。</p>
<pre><code>CanvasRenderingContext2D.addHitRegion() 
在canvas上添加一个点击区域。
CanvasRenderingContext2D.removeHitRegion() 
从canvas上移除指定id的点击区域。
CanvasRenderingContext2D.clearHitRegions() 
移除canvas上的所有点击区域。</code></pre><p>你可以把一个点击区域添加到路径里并检测MouseEvent.region属性来测试你的鼠标有没有点击这个区域，例：</p>
<pre><code>&lt;canvas id=&quot;canvas&quot;&gt;&lt;/canvas&gt;
&lt;script&gt;
var canvas = document.getElementById(&quot;canvas&quot;);
var ctx = canvas.getContext(&quot;2d&quot;);

ctx.beginPath();
ctx.arc(70, 80, 10, 0, 2 * Math.PI, false);
ctx.fill();
ctx.addHitRegion({id: &quot;circle&quot;});

canvas.addEventListener(&quot;mousemove&quot;, function(event){
if(event.region) {
    alert(&quot;hit region: &quot; + event.region);
}
});
&lt;/script&gt;
addHitRegion()方法也可以带一个control选项来指定把事件转发到哪个元素上（canvas里的元素）。

ctx.addHitRegion({control: element});
把这个特性用在&lt;input&gt;元素上会很有用。</code></pre><h2 id="焦点圈"><a href="#焦点圈" class="headerlink" title="焦点圈"></a>焦点圈</h2><p>当用键盘控制时，焦点圈是一个能帮我们在页面上快速导航的标记。要在canvas上绘制焦点圈，可以使用drawFocusIfNeeded 属性。</p>
<pre><code>CanvasRenderingContext2D.drawFocusIfNeeded() 
如果给定的元素获得了焦点，这个方法会沿着在当前的路径画个焦点圈。
另外，scrollPathIntoView()方法可以让一个元素获得焦点的时候在屏幕上可见(滚动到元素所在的区域)。

CanvasRenderingContext2D.scrollPathIntoView() 
把当前的路径或者一个给定的路径滚动到显示区域内。</code></pre><h2 id="内容兼容"><a href="#内容兼容" class="headerlink" title="内容兼容"></a>内容兼容</h2><p>&lt;canvas&gt; … &lt;/canvas&gt;标签里的内容被可以对一些不支持canvas的浏览器提供兼容。这对残疾用户设备也很有用（比如屏幕阅读器），这样它们就可以读取并解释DOM里的子节点。在html5accessibility.com有个很好的例子来演示它如何运作。</p>
<pre><code>&lt;canvas&gt; 
&lt;h2&gt;Shapes&lt;/h2&gt; 
&lt;p&gt;A rectangle with a black border. 
In the background is a pink circle. 
Partially overlaying the &lt;a href=&quot;http://en.wikipedia.org/wiki/Circle&quot; onfocus=&quot;drawCircle();&quot; onblur=&quot;drawPicture();&quot;&gt;circle&lt;/a&gt;. 
Partially overlaying the circle is a green 
&lt;a href=&quot;http://en.wikipedia.org/wiki/Square&quot; onfocus=&quot;drawSquare();&quot; onblur=&quot;drawPicture();&quot;&gt;square&lt;/a&gt; 
and a purple &lt;a href=&quot;http://en.wikipedia.org/wiki/Triangle&quot; onfocus=&quot;drawTriangle();&quot; onblur=&quot;drawPicture();&quot;&gt;triangle&lt;/a&gt;,
both of which are semi-opaque, so the full circle can be seen underneath.&lt;/p&gt; 
&lt;/canvas&gt;</code></pre><h2 id="ARIA-规则"><a href="#ARIA-规则" class="headerlink" title="ARIA 规则"></a>ARIA 规则</h2><p>Accessible Rich Internet Applications (ARIA) 定义了让Web内容和Web应用更容易被有身体缺陷的人获取的办法。你可以用ARIA属性来描述canvas元素的行为和存在目的。详情见ARIA和 ARIA 技术。</p>
<pre><code>&lt;canvas id=&quot;button&quot; tabindex=&quot;0&quot; role=&quot;button&quot; aria-pressed=&quot;false&quot; aria-label=&quot;Start game&quot;&gt;&lt;/canvas&gt;</code></pre><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><p>&lt;canvas&gt;元素是众多广泛使用的网络2D图像渲染标准之一。它被广泛用于游戏及复杂的图像可视化中。然而，随着网站和应用将canvas画布推至极限，性能开始成为问题。此文目标是给使用canvas画布元素的优化带来建议，去保证你的网站或者应用表现卓越。</p>
<p>性能贴士<br>下面是一些改善性能的建议</p>
<h2 id="在离屏canvas上预渲染相似的图形或重复的对象"><a href="#在离屏canvas上预渲染相似的图形或重复的对象" class="headerlink" title="在离屏canvas上预渲染相似的图形或重复的对象"></a>在离屏canvas上预渲染相似的图形或重复的对象</h2><p>如果发现自己在每个动画帧上重复了一些相同的绘制操作，请考虑将其分流到屏幕外的画布上。 然后，您可以根据需要频繁地将屏幕外图像渲染到主画布上，而不必首先重复生成该图像的步骤。</p>
<pre><code>myEntity.offscreenCanvas = document.createElement(&quot;canvas&quot;);
myEntity.offscreenCanvas.width = myEntity.width;
myEntity.offscreenCanvas.height = myEntity.height;
myEntity.offscreenContext = myEntity.offscreenCanvas.getContext(&quot;2d&quot;);

myEntity.render(myEntity.offscreenContext);</code></pre><h2 id="避免浮点数的坐标点，用整数取而代之"><a href="#避免浮点数的坐标点，用整数取而代之" class="headerlink" title="避免浮点数的坐标点，用整数取而代之"></a>避免浮点数的坐标点，用整数取而代之</h2><p>当你画一个没有整数坐标点的对象时会发生子像素渲染。</p>
<pre><code>ctx.drawImage(myImage, 0.3, 0.5);</code></pre><p>浏览器为了达到抗锯齿的效果会做额外的运算。为了避免这种情况，请保证在你调用drawImage()函数时，用Math.floor()函数对所有的坐标点取整。</p>
<h2 id="不要在用drawImage时缩放图像"><a href="#不要在用drawImage时缩放图像" class="headerlink" title="不要在用drawImage时缩放图像_"></a>不要在用drawImage时缩放图像_</h2><p>在离屏canvas中缓存图片的不同尺寸，而不要用drawImage()去缩放它们。</p>
<h2 id="使用多层画布去画一个复杂的场景"><a href="#使用多层画布去画一个复杂的场景" class="headerlink" title="使用多层画布去画一个复杂的场景"></a>使用多层画布去画一个复杂的场景</h2><p>在您的应用程序中，您可能会发现某些对象需要经常移动或更改，而其他对象则保持相对静态。 在这种情况下，可能的优化是使用多个&lt;canvas&gt;元素对您的项目进行分层。</p>
<p>例如，假设您有一个游戏，其UI位于顶部，中间是游戏性动作，底部是静态背景。 在这种情况下，您可以将游戏分成三个&lt;canvas&gt;层。 UI将仅在用户输入时发生变化，游戏层随每个新框架发生变化，并且背景通常保持不变。</p>
<pre><code>&lt;div id=&quot;stage&quot;&gt;
&lt;canvas id=&quot;ui-layer&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt;
&lt;canvas id=&quot;game-layer&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt;
&lt;canvas id=&quot;background-layer&quot; width=&quot;480&quot; height=&quot;320&quot;&gt;&lt;/canvas&gt;
&lt;/div&gt;

&lt;style&gt;
#stage {
    width: 480px;
    height: 320px;
    position: relative;
    border: 2px solid black
}
canvas { position: absolute; }
#ui-layer { z-index: 3 }
#game-layer { z-index: 2 }
#background-layer { z-index: 1 }
&lt;/style&gt;</code></pre><h2 id="用CSS设置大的背景图"><a href="#用CSS设置大的背景图" class="headerlink" title="用CSS设置大的背景图"></a>用CSS设置大的背景图</h2><p>如果像大多数游戏那样，你有一张静态的背景图，用一个静态的<div>元素，结合background 特性，以及将它置于画布元素之后。这么做可以避免在每一帧在画布上绘制大图。</p>
<h2 id="用CSS-transforms特性缩放画布"><a href="#用CSS-transforms特性缩放画布" class="headerlink" title="用CSS transforms特性缩放画布"></a>用CSS transforms特性缩放画布</h2><p>CSS transforms 使用GPU，因此速度更快。 最好的情况是不直接缩放画布，或者具有较小的画布并按比例放大，而不是较大的画布并按比例缩小。</p>
<pre><code>var scaleX = window.innerWidth / canvas.width;
var scaleY = window.innerHeight / canvas.height;

var scaleToFit = Math.min(scaleX, scaleY);
var scaleToCover = Math.max(scaleX, scaleY);

stage.style.transformOrigin = &apos;0 0&apos;; //scale from top left
stage.style.transform = &apos;scale(&apos; + scaleToFit + &apos;)&apos;;</code></pre><h2 id="关闭透明度"><a href="#关闭透明度" class="headerlink" title="关闭透明度"></a>关闭透明度</h2><p>如果你的游戏使用画布而且不需要透明，当使用 HTMLCanvasElement.getContext() 创建一个绘图上下文时把 alpha 选项设置为 false 。这个选项可以帮助浏览器进行内部优化。</p>
<pre><code>var ctx = canvas.getContext(&apos;2d&apos;, { alpha: false });</code></pre><h2 id="更多的贴士"><a href="#更多的贴士" class="headerlink" title="更多的贴士"></a>更多的贴士</h2><ul>
<li>将画布的函数调用集合到一起（例如，画一条折线，而不要画多条分开的直线）</li>
<li>避免不必要的画布状态改变</li>
<li>渲染画布中的不同点，而非整个新状态</li>
<li>尽可能避免 shadowBlur特性</li>
<li>尽可能避免text rendering</li>
<li>尝试不同的方法来清除画布(clearRect() vs. fillRect() vs. 调整   canvas大小)</li>
<li>有动画，请使用window.requestAnimationFrame() 而非window.setInterval()</li>
<li>请谨慎使用大型物理库</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title>es6新特性</title>
    <url>/2020/10/09/es6%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><p><em>表示独一无二的值，最大的用法是用来定义对象的唯一属性名</em></p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><em>Symbol函数栈不能用new命令，因为是原始数据类型，不是对象。可以接受一个字符串作为参数，为新创建的Symbol提供 <strong>描述</strong> ，用于显示在控制台或者作为字符串的时候，便于区分</em></p>
<pre><code>let s1 = Symbol(&apos;aa&apos;);
let s2 = Symbol(&apos;aa&apos;);
console.log(s1===s2); // false
typeof(s1); // &quot;symbol&quot;
console.log(s1) // Symbol(aa)</code></pre><h2 id="Symbol-for"><a href="#Symbol-for" class="headerlink" title="Symbol.for()"></a>Symbol.for()</h2><p><em>Symbol.for() 类似单例模式，首先会在全局搜索被登记的 Symbol 中是否有该字符串参数作为名称的 Symbol 值，如果有即返回该 Symbol 值，若没有则新建并返回一个以该字符串参数为名称的 Symbol 值，并登记在全局环境中供搜索。</em></p>
<pre><code>let yellow = Symbol(&quot;Yellow&quot;);
let yellow1 = Symbol.for(&quot;Yellow&quot;);
yellow === yellow1;      // false

let yellow2 = Symbol.for(&quot;Yellow&quot;);
yellow1 === yellow2;     // true</code></pre><h2 id="Symbol-keyFor"><a href="#Symbol-keyFor" class="headerlink" title="Symbol.keyFor()"></a>Symbol.keyFor()</h2><p><em>Symbol.keyFor() 返回一个已登记的 Symbol 类型值的 key ，用来检测该字符串参数作为名称的 Symbol 值是否已被登记。</em></p>
<pre><code>let yellow1 = Symbol.for(&quot;Yellow&quot;);
Symbol.keyFor(yellow1);    // &quot;Yellow&quot;</code></pre><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><em>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。</em></p>
<h2 id="Maps-和-Objects-的区别"><a href="#Maps-和-Objects-的区别" class="headerlink" title="Maps 和 Objects 的区别"></a>Maps 和 Objects 的区别</h2><ul>
<li>一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。</li>
<li>Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</li>
<li>Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。</li>
<li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li>
</ul>
<h2 id="Map-中的-key"><a href="#Map-中的-key" class="headerlink" title="Map 中的 key"></a>Map 中的 key</h2><h3 id="key-是字符串"><a href="#key-是字符串" class="headerlink" title="key 是字符串"></a>key 是字符串</h3><pre><code>var myMap = new Map();
var keyString = &quot;a string&quot;; 

myMap.set(keyString, &quot;和键&apos;a string&apos;关联的值&quot;);

myMap.get(keyString);    // &quot;和键&apos;a string&apos;关联的值&quot;
myMap.get(&quot;a string&quot;);   // &quot;和键&apos;a string&apos;关联的值&quot;
                        // 因为 keyString === &apos;a string&apos;</code></pre><h3 id="key-是对象"><a href="#key-是对象" class="headerlink" title="key 是对象"></a>key 是对象</h3><pre><code>var myMap = new Map();  
var keyObj = {}, 

myMap.set(keyObj, &quot;和键 keyObj 关联的值&quot;);

myMap.get(keyObj); // &quot;和键 keyObj 关联的值&quot;
myMap.get({}); // undefined, 因为 keyObj !== {}</code></pre><h3 id="key-是函数"><a href="#key-是函数" class="headerlink" title="key 是函数"></a>key 是函数</h3><pre><code>var myMap = new Map();
var keyFunc = function () {}, // 函数

myMap.set(keyFunc, &quot;和键 keyFunc 关联的值&quot;);

myMap.get(keyFunc); // &quot;和键 keyFunc 关联的值&quot;
myMap.get(function() {}) // undefined, 因为 keyFunc !== function () {}</code></pre><h3 id="key-是-NaN"><a href="#key-是-NaN" class="headerlink" title="key 是 NaN"></a>key 是 NaN</h3><pre><code>var myMap = new Map();  
myMap.set(NaN, &quot;not a number&quot;);

myMap.get(NaN); // &quot;not a number&quot;

var otherNaN = Number(&quot;foo&quot;);
myMap.get(otherNaN); // &quot;not a number&quot;
虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，NaN作为Map的键来说是没有区别的。</code></pre><h2 id="Map-的迭代"><a href="#Map-的迭代" class="headerlink" title="Map 的迭代"></a>Map 的迭代</h2><p><em>对 Map 进行遍历，以下两个最高级。</em></p>
<h3 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h3><pre><code>var myMap = new Map();
myMap.set(0, &quot;zero&quot;);
myMap.set(1, &quot;one&quot;);

// 将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;
for (var [key, value] of myMap) {
console.log(key + &quot; = &quot; + value);
}
for (var [key, value] of myMap.entries()) {
console.log(key + &quot; = &quot; + value);
}
/* 这个 entries 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组。 */

// 将会显示两个log。 一个是 &quot;0&quot; 另一个是 &quot;1&quot;
for (var key of myMap.keys()) {
console.log(key);
}
/* 这个 keys 方法返回一个新的 Iterator 对象， 它按插入顺序包含了 Map 对象中每个元素的键。 */

// 将会显示两个log。 一个是 &quot;zero&quot; 另一个是 &quot;one&quot;
for (var value of myMap.values()) {
console.log(value);
}
/* 这个 values 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值。 */</code></pre><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><pre><code>var myMap = new Map();
myMap.set(0, &quot;zero&quot;);
myMap.set(1, &quot;one&quot;);

// 将会显示两个 logs。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;
myMap.forEach(function(value, key) {
console.log(key + &quot; = &quot; + value);
}, myMap)</code></pre><h2 id="Map-对象的操作"><a href="#Map-对象的操作" class="headerlink" title="Map 对象的操作"></a>Map 对象的操作</h2><h3 id="Map-与-Array的转换"><a href="#Map-与-Array的转换" class="headerlink" title="Map 与 Array的转换"></a>Map 与 Array的转换</h3><pre><code>var kvArray = [[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]];

// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象
var myMap = new Map(kvArray);

// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组
var outArray = Array.from(myMap);</code></pre><h3 id="Map-的克隆"><a href="#Map-的克隆" class="headerlink" title="Map 的克隆"></a>Map 的克隆</h3><pre><code>var myMap1 = new Map([[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]]);
var myMap2 = new Map(myMap1);

console.log(original === clone); 
// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。</code></pre><h3 id="Map-的合并"><a href="#Map-的合并" class="headerlink" title="Map 的合并"></a>Map 的合并</h3><pre><code>var first = new Map([[1, &apos;one&apos;], [2, &apos;two&apos;], [3, &apos;three&apos;],]);
var second = new Map([[1, &apos;uno&apos;], [2, &apos;dos&apos;]]);

// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three
var merged = new Map([...first, ...second]);</code></pre><h1 id="Set-对象"><a href="#Set-对象" class="headerlink" title="Set 对象"></a>Set 对象</h1><p><em>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</em></p>
<h2 id="Set-中的特殊值"><a href="#Set-中的特殊值" class="headerlink" title="Set 中的特殊值"></a>Set 中的特殊值</h2><p><em>Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：</em></p>
<ul>
<li><p>+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；</p>
</li>
<li><p>undefined 与 undefined 是恒等的，所以不重复；</p>
</li>
<li><p>NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。代码</p>
<pre><code>let mySet = new Set();

mySet.add(1); // Set(1) {1}
mySet.add(5); // Set(2) {1, 5}
mySet.add(5); // Set(2) {1, 5} 这里体现了值的唯一性
mySet.add(&quot;some text&quot;); 
// Set(3) {1, 5, &quot;some text&quot;} 这里体现了类型的多样性
var o = {a: 1, b: 2}; 
mySet.add(o);
mySet.add({a: 1, b: 2}); 
// Set(5) {1, 5, &quot;some text&quot;, {…}, {…}} 
// 这里体现了对象之间引用不同不恒等，即使值相同，Set 也能存储</code></pre></li>
</ul>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><pre><code>// Array 转 Set
var mySet = new Set([&quot;value1&quot;, &quot;value2&quot;, &quot;value3&quot;]);
// 用...操作符，将 Set 转 Array
var myArray = [...mySet];
String
// String 转 Set
var mySet = new Set(&apos;hello&apos;);  // Set(4) {&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;o&quot;}
// 注：Set 中 toString 方法是不能将 Set 转换成 String</code></pre><h2 id="Set-对象作用"><a href="#Set-对象作用" class="headerlink" title="Set 对象作用"></a>Set 对象作用</h2><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><pre><code>var mySet = new Set([1, 2, 3, 4, 4]);
[...mySet]; // [1, 2, 3, 4]</code></pre><h3 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h3><pre><code>var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var union = new Set([...a, ...b]); // {1, 2, 3, 4}</code></pre><h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><pre><code>var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var intersect = new Set([...a].filter(x =&gt; b.has(x))); // {2, 3}</code></pre><h3 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h3><pre><code>var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var difference = new Set([...a].filter(x =&gt; !b.has(x))); // {1}</code></pre>]]></content>
      <categories>
        <category>前端</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>es6新特性</tag>
        <tag>symbol</tag>
      </tags>
  </entry>
  <entry>
    <title>express</title>
    <url>/2020/09/14/express/</url>
    <content><![CDATA[<h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h1><pre><code>mkdir helloExpress
cd helloExpress
// 可手动操作，创建文件夹并进入

npm init 
// 一直enter,除下项
entry point: (index.js)：app.js
// 建议此项改为app.js

npm i express -S
// 安装依赖

接下来创建app.js文件
文件内容如下

const express = require(&apos;express&apos;)
const app = express()
const port = 3000

app.get(&apos;/&apos;, (req, res) =&gt; res.send(&apos;Hello World!&apos;))

app.listen(port, () =&gt; console.log(`Example app listening on port ${port}!`))


node app.js
// 命令行运行，打印出相关信息</code></pre><h1 id="项目建立"><a href="#项目建立" class="headerlink" title="项目建立"></a>项目建立</h1><pre><code>mkdir myapp
cd myapp
// 可手动操作，创建文件夹并进入

npx express-generator
// 包含在 Node.js 8.2.0 及更高版本中


npm install -g express-generator
express --view=pug myapp
// 老版本用此句生成

cd myapp
npm i

官方文档

在 MacOS 或 Linux 中，通过如下命令启动此应用：
$ DEBUG=myapp:* npm start
在 Windows 中，通过如下命令启动此应用：
&gt; set DEBUG=myapp:* &amp; npm start

若启动出错，可直接
npm start</code></pre><h1 id="基本路由"><a href="#基本路由" class="headerlink" title="基本路由"></a>基本路由</h1><pre><code>app.METHOD(PATH, HANDLER)
// 基本方法

app.get(&apos;/&apos;, function (req, res) {
res.send(&apos;Hello World!&apos;)
})

app.post(&apos;/&apos;, function (req, res) {
res.send(&apos;Got a POST request&apos;)
})

app.put(&apos;/user&apos;, function (req, res) {
res.send(&apos;Got a PUT request at /user&apos;)
})

app.delete(&apos;/user&apos;, function (req, res) {
res.send(&apos;Got a DELETE request at /user&apos;)
})</code></pre><h1 id="利用express-静态托管页面"><a href="#利用express-静态托管页面" class="headerlink" title="利用express 静态托管页面"></a>利用express 静态托管页面</h1><blockquote>
<p>在上述生成器生成的项目中，已默认托管public文件夹</p>
</blockquote>
<pre><code>express.static(root, [options])

app.use(express.static(&apos;public&apos;))
// 默认

app.use(express.static(&apos;public&apos;))
app.use(express.static(&apos;files&apos;))
// 多个

app.use(&apos;/static&apos;, express.static(&apos;public&apos;))
// 带访问路径

http://localhost:3000/static/images/kitten.jpg

app.use(&apos;/static&apos;, express.static(path.join(__dirname, &apos;public&apos;)))</code></pre>]]></content>
      <categories>
        <category>前端</category>
        <category>express</category>
      </categories>
      <tags>
        <tag>express</tag>
      </tags>
  </entry>
  <entry>
    <title>git相关操作</title>
    <url>/2020/07/22/git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="git创建项目，并绑定本地项目"><a href="#git创建项目，并绑定本地项目" class="headerlink" title="git创建项目，并绑定本地项目"></a>git创建项目，并绑定本地项目</h1><pre><code>Git init
Git add .
Git commit -m ‘first’
git remote add origin https://github.com/kukuboy/actity.git
git push -u origin master
git pull
git push --set-upstream origin master</code></pre><h1 id="git多分支管理"><a href="#git多分支管理" class="headerlink" title="git多分支管理"></a>git多分支管理</h1><p>在github上创建新分支dev,一个两个分支管理，master用于生产，dev用于开发，开发一个版本后再合并即可。</p>
<pre><code>// 查看所有分支
git branch -a
    * master
    remotes/origin/dev
    remotes/origin/master
// 创建本地分支
git branch dev
// 切换到dev分支
git checkout dev
// 查看分支对应管理
$ git branch -vv
    * dev    3593014 [origin/dev] first commit
    master 29b0ba9 [origin/master] first commit
// 本地dev绑定远程dev
git branch --set-upstream-to=origin/dev</code></pre><h1 id="github-绑定ssh"><a href="#github-绑定ssh" class="headerlink" title="github 绑定ssh"></a>github 绑定ssh</h1><blockquote>
<p>使用ssh可以在每次使用时不用重复的填写密码</p>
</blockquote>
<h2 id="windows操作系统下"><a href="#windows操作系统下" class="headerlink" title="windows操作系统下"></a>windows操作系统下</h2><blockquote>
<p>使用git bash的终端</p>
</blockquote>
<ol>
<li><p>查看现有</p>
<pre><code>ls -al ~/.ssh</code></pre></li>
<li><p>若出现此项目，说明已存在可跳过生成，也可重新生成</p>
<pre><code>id_rsa // 私钥
id_rsa.pub // 公钥</code></pre></li>
<li><p>生成，替换自己邮件</p>
<pre><code>$ ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;
   注：如果您使用的是不支持 Ed25519 算法的旧系统，请使用以下命令：

    $ ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;

//提示您“Enter a file in which to save the key（输入要保存密钥的文件）”时，按 Enter 键。 这将接受默认文件位置。

Enter a file in which to save the key (/c/Users/you/.ssh/id_rsa):[Press enter]

//在提示时输入安全密码。 

Enter passphrase (empty for no passphrase): 
Enter same passphrase again: </code></pre></li>
<li><p>将 SSH 密钥添加到 ssh-agent</p>
<pre><code>ssh-add ~/.ssh/id_rsa</code></pre></li>
</ol>
<p>确保 ssh-agent 正在运行。可手动启动</p>
<pre><code>//在后台启动 ssh-agent
$ eval $(ssh-agent -s)
&gt; Agent pid 59566</code></pre><ol start="4">
<li><p>添加到个人账户中</p>
<ol>
<li>打开github 并登录</li>
<li>打开个人setting</li>
<li>找到SSH and GPG keys</li>
<li>新建并命名</li>
<li>进入git-bash复制对应<pre><code>//此操作可直接复制
clip &lt; ~/.ssh/id_rsa</code></pre></li>
<li>添加保存即可</li>
</ol>
</li>
</ol>
<h1 id="git更改https为ssl"><a href="#git更改https为ssl" class="headerlink" title="git更改https为ssl"></a>git更改https为ssl</h1><pre><code>// 查看之前的地址

$ git remote -v
    origin  https://baidu.com/aaa/aaa.git (fetch)
    origin  https://baidu.com/aaa/aaa.git (push)

// 复制新的ssl地址放在下面语句后执行
$ git remote set-url origin git @github.com:baidu/aaa.git </code></pre>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>clone</tag>
        <tag>ssh</tag>
        <tag>branch</tag>
      </tags>
  </entry>
  <entry>
    <title>iosH5输入框解决办法</title>
    <url>/2020/08/26/iosH5%E8%BE%93%E5%85%A5%E6%A1%86%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<h1 id="ios输入框问题解决方法总结"><a href="#ios输入框问题解决方法总结" class="headerlink" title="ios输入框问题解决方法总结"></a>ios输入框问题解决方法总结</h1><blockquote>
<p>以vue为框架，但与其他差距不大</p>
</blockquote>
<h2 id="键盘上部分按键为英文的解决办法"><a href="#键盘上部分按键为英文的解决办法" class="headerlink" title="键盘上部分按键为英文的解决办法"></a>键盘上部分按键为英文的解决办法</h2><blockquote>
<p>以下解决方法以此输入框为基准<br>外部加上form包含即可解决</p>
</blockquote>
<pre><code>&lt;form action=&quot;javascript:return true&quot;&gt;
    &lt;div
    v-html=&quot;chat_input&quot;
    @click=&quot;stopPromot&quot;
    @input=&quot;inputDiv&quot;
    @blur=&quot;blur&quot;
    tabindex=&quot;1&quot;
    @focus=&quot;focusChange&quot;
    class=&quot;chat_input&quot;
    contenteditable=&quot;true&quot;
    ref=&quot;chat_input&quot;
    @keydown=&quot;keydown($event)&quot;
    placeholder=&quot;我来说两句…&quot;
    &gt;&lt;/div&gt;
&lt;/form&gt;</code></pre><h2 id="第一次点击任何任何输入框均会获取焦点的问题"><a href="#第一次点击任何任何输入框均会获取焦点的问题" class="headerlink" title="第一次点击任何任何输入框均会获取焦点的问题"></a>第一次点击任何任何输入框均会获取焦点的问题</h2><blockquote>
<p>WebkitUserSelect = ‘text’样式不再写在css中</p>
</blockquote>
<pre><code>stopPromot () {
    // 优化ios点击体验，修复第一次点击任何地方弹出键盘和有时点击为及时获取焦点的问题
        if (myUtil.checkPlatform() === &apos;Ios&apos;) {
            this.$refs.chat_input.style.WebkitUserSelect = &apos;text&apos;
            this.toLastDiv(this.$refs.chat_input)
        }
    },</code></pre><h2 id="在ios中页面整体可滑动的问题"><a href="#在ios中页面整体可滑动的问题" class="headerlink" title="在ios中页面整体可滑动的问题"></a>在ios中页面整体可滑动的问题</h2><pre><code>body {
/* 防止ios页面滑动 */
overflow: hidden;
margin: 0;
padding: 0;
width: 100%;
height: 100%;
top: 0;
left: 0;
position: fixed;
/* 页面主题限制在安全区域内 */
padding-bottom: constant(safe-area-insert-bottom);
padding-bottom: env(safe-area-insert-bottom);
}</code></pre><h2 id="重点-下列方法可解决，软键盘弹出时头部被顶出，或者输入框被盖住的问题"><a href="#重点-下列方法可解决，软键盘弹出时头部被顶出，或者输入框被盖住的问题" class="headerlink" title="(重点)下列方法可解决，软键盘弹出时头部被顶出，或者输入框被盖住的问题"></a>(重点)下列方法可解决，软键盘弹出时头部被顶出，或者输入框被盖住的问题</h2><blockquote>
<p>此方法写在输入框的组件中</p>
</blockquote>
<pre><code>// 原来是光标不能放在某些位置
focusChange () {
  // 关闭表情面板
  console.log(&apos;获得焦点&apos;, document.body.scrollTop)
  this.$emit(&apos;focusChange&apos;, 0, true)
  this.shutDown()
  if (myUtil.checkPlatform() === &apos;Ios&apos;) {
    clearInterval(focusTime)
    focusTime = setInterval(() =&gt; {
      console.log(document.body.scrollTop)
      if (document.body.scrollTop !== 0) { clearInterval(focusTime) }
      this.$emit(&apos;focusChange&apos;, document.body.scrollTop)
    }, 30)
  } else {
    this.$emit(&apos;focusChange&apos;, 0, false, false)
  }
},</code></pre><blockquote>
<p>此方法写在包含输入组件的页面中<br>this.scroll(true)为输入框获取焦点时其他处理的部分，如聊天内容需要滚动到最下方<br>bodyTouch的值为当前页面是否被触摸，下列介绍获取方法</p>
</blockquote>
<pre><code>    focusChange (h, blur = false, isIos = true) {
  // 处理安卓
  if (!isIos) {
    setTimeout(() =&gt; {
      this.scroll(true)
    }, 100)
    return
  }
  // 处理ios
  if (h &gt; 0 &amp;&amp; !blur) {
    h += &apos;px&apos;
    document.body.style.height = &apos;calc(100% - &apos; + h + &apos;)&apos;
    document.body.scrollTop = h
    console.log(&apos;focusChange&apos;, h)
    clearInterval(this.bodyTouchTime)
    this.bodyTouchTime = setInterval(() =&gt; {
      if (this.bodyTouch) {
        return
      }
      document.body.scrollTop = h
    }, 10)
    setTimeout(() =&gt; {
      this.scroll(true)
    }, 100)
  } else if (blur) {
    clearInterval(this.bodyTouchTime)
    document.body.style.height = &apos;100%&apos;
  }
},</code></pre><blockquote>
<p>bodyTouchh获取</p>
</blockquote>
<pre><code>mounted () {
    this.init()
},
destroyed () {
    clearInterval(this.bodyTouchTime)
    // 清除事件
    let _this = this
    document.removeEventListener(&apos;touchstart&apos;, function (e) {
    _this.bodyTouch = true
    }, false)
    document.removeEventListener(&apos;touchend&apos;, function (e) {
    _this.bodyTouch = false
    }, false)
},
methods: {
    init () {
    chatContent = this.$refs.chat_content
    chatContent.addEventListener(&apos;scroll&apos;, this.scrollListen, false)
    // 判断检测当前屏幕是否被触摸
    let _this = this
    document.addEventListener(&apos;touchstart&apos;, function (e) {
        _this.bodyTouch = true
    }, false)
    document.addEventListener(&apos;touchend&apos;, function (e) {
        _this.bodyTouch = false
    }, false)
    },
}</code></pre><h2 id="ios输入框获取焦点，光标移到最后"><a href="#ios输入框获取焦点，光标移到最后" class="headerlink" title="ios输入框获取焦点，光标移到最后"></a>ios输入框获取焦点，光标移到最后</h2><blockquote>
<p>obj即为输入框对象，可使输入框获取焦点，也可使光标移到最后</p>
</blockquote>
<pre><code>// 光标移到最后
toLastDiv (obj) {
  let range
  if (window.getSelection) {
    // ie11 10 9 ff safari
    obj.focus() // 解决ff不获取焦点无法定位问题
    range = window.getSelection() // 创建range
    range.selectAllChildren(obj) // range 选择obj下所有子内容
    range.collapseToEnd() // 光标移至最后
  } else if (document.selection) {
    // ie10 9 8 7 6 5
    range = document.selection.createRange() // 创建选择对象
    // var range = document.body.createTextRange();
    range.moveToElementText(obj) // range定位到obj
    range.collapse(false) // 光标移至最后
    range.select()
  }
},</code></pre>]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
        <category>input输入框</category>
      </categories>
      <tags>
        <tag>ios</tag>
        <tag>H5</tag>
        <tag>输入框</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>js堆和栈-基本类型和引用类型</title>
    <url>/2021/04/02/js%E5%A0%86%E5%92%8C%E6%A0%88-%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<blockquote>
<blockquote>
<p>堆和栈其实是内存存储的方式，在js中基本类型是放在栈内存中的，引用类型是放在堆内存中的,引用类型的引用还是放在栈内存中的</p>
</blockquote>
</blockquote>
<p><strong><em>因为引用类型指向的是栈中的指针地址，指针地址在指向堆中的内容，故由此存在了浅复制的问题，故在最后还会讲下深度克隆的方法</em></strong></p>
<h1 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h1><h2 id="数字（Number）"><a href="#数字（Number）" class="headerlink" title="数字（Number）"></a>数字（Number）</h2><ol>
<li><p>包括浮点数和整数</p>
<p> 什么是浮点数：浮点数就是该数值中必须有一个小数点，并且小数点后面必须至少有一位数字。<br> 由于保存浮点数值的内存空间是保存整数值的两倍，所以js会不失时机的把浮点数转换为整数。小数点后面没有数值或者1.0就会被保存成整数。</p>
</li>
<li><p>特殊的数字类型NaN</p>
<p> 1、表示不是数字，但是其实它是一个特殊的数字（NaN：Not a Number）</p>
<p> 2、当运算操作符错误的时候，一般会得到NaN</p>
<p> 3、NaN具有传染性，即NaN参与任何运算，结果都为NaN</p>
<p> 4、NaN与任何数值都不相等</p>
</li>
</ol>
<ul>
<li><p>isNaN()函数</p>
<p>  isNaN()函数—判断一个数是否为NaN的唯一方式</p>
<p>  判断一个数是否是NaN，如果是NaN则返回true，否则返回false</p>
</li>
</ul>
<ol start="3">
<li><p>Infinity</p>
<p>1、Infinity：数据超过了JS可以表示的范围，是一个特殊的数字</p>
<p>2、Infinity与其他数据类型进行操作运算，结果还是Infinity</p>
<p>3、数字除以0得到Infinity</p>
</li>
</ol>
<ul>
<li><p>isFinite()函数</p>
<p>  如果是NaN或者Infinity返回false，否则返回true</p>
</li>
</ul>
<h2 id="字符串（String）"><a href="#字符串（String）" class="headerlink" title="字符串（String）"></a>字符串（String）</h2><p>多个字符的有序序列，双引号和单引号引起来的都是字符串</p>
<ul>
<li>字符串特点：</li>
</ul>
<ul>
<li><p>单引号和双引号引起来的都是字符串</p>
</li>
<li><p>两个字符串相加，实际上是将两个字符串拼接</p>
</li>
<li><p>两个字符串相加，是拼接而不是运算，其他运算结果为NaN，表示计算错误</p>
</li>
<li><p>字符串加数字，首先将数字转化为响应的字符串然后再参与运算。同样不支持-, *, /等其他运算</p>
</li>
</ul>
<h2 id="布尔值（Boolean）"><a href="#布尔值（Boolean）" class="headerlink" title="布尔值（Boolean）"></a>布尔值（Boolean）</h2><p>包括true和false，通常用在流程控制语句，选择判断语句</p>
<ul>
<li>false值：</li>
</ul>
<ul>
<li>数字0</li>
<li>NaN</li>
<li>“ ”，空字符串</li>
<li>false</li>
<li>undefined</li>
<li>null</li>
</ul>
<ul>
<li>true值： 除了false值就是true值</li>
</ul>
<h2 id="Undefined"><a href="#Undefined" class="headerlink" title="Undefined"></a>Undefined</h2><p>如果使用一个未定义的变量，会得到一个undefined值，当定义了一个变量未初始化，默认的也会给它初始化成undefined值</p>
<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>代表什么也没有</p>
<p>注意：null和undefined的最大区别是如果变量值为null，说明变量是存在的，只不过它的值是空值null</p>
<h2 id="Symbol-es6"><a href="#Symbol-es6" class="headerlink" title="Symbol(es6)"></a>Symbol(es6)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><blockquote>
<p>主要用于变量名,货号内的内容是描述</p>
</blockquote>
<blockquote>
<p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。</p>
</blockquote>
<blockquote>
<p>ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
</blockquote>
<blockquote>
<p>Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
</blockquote>
<pre><code>let s = Symbol();

typeof s
// &quot;symbol&quot;</code></pre><blockquote>
<p>上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。</p>
</blockquote>
<blockquote>
<p>注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
</blockquote>
<blockquote>
<p>Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
</blockquote>
<pre><code>let s1 = Symbol(&apos;foo&apos;);
let s2 = Symbol(&apos;bar&apos;);

s1 // Symbol(foo)
s2 // Symbol(bar)

s1.toString() // &quot;Symbol(foo)&quot;
s2.toString() // &quot;Symbol(bar)&quot;</code></pre><blockquote>
<p>上面代码中，s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p>
</blockquote>
<blockquote>
<p>如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。</p>
</blockquote>
<pre><code>const obj = {
toString() {
    return &apos;abc&apos;;
}
};
const sym = Symbol(obj);
sym // Symbol(abc)
注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。

// 没有参数的情况
let s1 = Symbol();
let s2 = Symbol();

s1 === s2 // false

// 有参数的情况
let s1 = Symbol(&apos;foo&apos;);
let s2 = Symbol(&apos;foo&apos;);

s1 === s2 // false
上面代码中，s1和s2都是Symbol函数的返回值，而且参数相同，但是它们是不相等的。</code></pre><blockquote>
<p>Symbol 值不能与其他类型的值进行运算，会报错。</p>
</blockquote>
<pre><code>let sym = Symbol(&apos;My symbol&apos;);

&quot;your symbol is &quot; + sym
// TypeError: can&apos;t convert symbol to string
`your symbol is ${sym}`
// TypeError: can&apos;t convert symbol to string</code></pre><blockquote>
<p>但是，Symbol 值可以显式转为字符串。</p>
</blockquote>
<pre><code>let sym = Symbol(&apos;My symbol&apos;);

String(sym) // &apos;Symbol(My symbol)&apos;
sym.toString() // &apos;Symbol(My symbol)&apos;</code></pre><blockquote>
<p>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p>
</blockquote>
<pre><code>let sym = Symbol();
Boolean(sym) // true
!sym  // false

if (sym) {
    // ...
}

Number(sym) // TypeError
sym + 2 // TypeError
Symbol.prototype.description</code></pre><blockquote>
<p>创建 Symbol 的时候，可以添加一个描述。</p>
</blockquote>
<pre><code>const sym = Symbol(&apos;foo&apos;);</code></pre><blockquote>
<p>上面代码中，sym的描述就是字符串foo。</p>
</blockquote>
<blockquote>
<p>但是，读取这个描述需要将 Symbol 显式转为字符串，即下面的写法。</p>
</blockquote>
<pre><code>const sym = Symbol(&apos;foo&apos;);

String(sym) // &quot;Symbol(foo)&quot;
sym.toString() // &quot;Symbol(foo)&quot;</code></pre><blockquote>
<p>上面的用法不是很方便。ES2019 提供了一个实例属性description，直接返回 Symbol 的描述。</p>
</blockquote>
<pre><code>const sym = Symbol(&apos;foo&apos;);

sym.description // &quot;foo&quot;</code></pre><blockquote>
<p>作为属性名的 Symbol<br>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
</blockquote>
<pre><code>let mySymbol = Symbol();

// 第一种写法
let a = {};
a[mySymbol] = &apos;Hello!&apos;;

// 第二种写法
let a = {
    [mySymbol]: &apos;Hello!&apos;
};

// 第三种写法
let a = {};
Object.defineProperty(a, mySymbol, { value: &apos;Hello!&apos; });

// 以上写法都得到同样结果
a[mySymbol] // &quot;Hello!&quot;
上面代码通过方括号结构和Object.defineProperty，将对象的属性名指定为一个 Symbol 值。</code></pre><blockquote>
<p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p>
</blockquote>
<pre><code>const mySymbol = Symbol();
const a = {};

a.mySymbol = &apos;Hello!&apos;;
a[mySymbol] // undefined
a[&apos;mySymbol&apos;] // &quot;Hello!&quot;</code></pre><blockquote>
<p>上面代码中，因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。</p>
</blockquote>
<blockquote>
<p>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
</blockquote>
<pre><code>let s = Symbol();

let obj = {
    [s]: function (arg) { ... }
};

obj[s](123);
上面代码中，如果s不放在方括号中，该属5性的键名就是字符串s，而不是s所代表的那个 Symbol 值。</code></pre><blockquote>
<p>采用增强的对象写法，上面代码的obj对象可以写得更简洁一些。</p>
</blockquote>
<pre><code>let obj = {
[s](arg) { ... }
};</code></pre><blockquote>
<p>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p>
</blockquote>
<pre><code>const log = {};

log.levels = {
DEBUG: Symbol(&apos;debug&apos;),
INFO: Symbol(&apos;info&apos;),
WARN: Symbol(&apos;warn&apos;)
};
console.log(log.levels.DEBUG, &apos;debug message&apos;);
console.log(log.levels.INFO, &apos;info message&apos;);</code></pre><blockquote>
<p>下面是另外一个例子。</p>
</blockquote>
<pre><code>const COLOR_RED    = Symbol();
const COLOR_GREEN  = Symbol();

function getComplement(color) {
switch (color) {
    case COLOR_RED:
    return COLOR_GREEN;
    case COLOR_GREEN:
    return COLOR_RED;
    default:
    throw new Error(&apos;Undefined color&apos;);
    }
}</code></pre><blockquote>
<p>常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的switch语句会按设计的方式工作。</p>
</blockquote>
<blockquote>
<p>还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</p>
</blockquote>
<p><a href=""https://wangdoc.com/es6/symbol.html">查看更多内容点此处</a></p>
<h1 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h1><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><blockquote>
<p>数组、函数、正则表达式都是对象。</p>
</blockquote>
<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><pre><code>学过数据结构的都知道 栈 是一种 先进后出 的数据结构，栈内存是内存中用于存放临时变量的一片内存块。当声明一个基本变量时，它就会被存储到栈内存中。比如有这样一段代码，他们在栈内存中存储的形式如下表一样:

const a = 1;
const b = &quot;1&quot;;</code></pre><table>
<thead>
<tr>
<th>变量名</th>
<th>变量值</th>
</tr>
</thead>
<tbody><tr>
<td>b</td>
<td>“1”</td>
</tr>
<tr>
<td>a</td>
<td>1</td>
</tr>
</tbody></table>
<blockquote>
<p>而当其发生复制时，会把对应内存中的数据复制一份到新内存中，就像下面这样</p>
</blockquote>
<pre><code>const c = b</code></pre><table>
<thead>
<tr>
<th>变量名</th>
<th>变量值</th>
</tr>
</thead>
<tbody><tr>
<td>c</td>
<td>“1”</td>
</tr>
<tr>
<td>b</td>
<td>“1”</td>
</tr>
<tr>
<td>a</td>
<td>1</td>
</tr>
</tbody></table>
<blockquote>
<p>很显然，c，b两个变量占用了不同的存储空间，所以他们之间也并没有什么联系。<br>栈内存的地址分配是连续的，所以在后续也不能对其进行进一步的扩充或者删除。</p>
</blockquote>
<p><strong>栈总结：</strong></p>
<blockquote>
<p>栈内存的特点:存取速度快，但不灵活，同时由于结构简单，在变量使用完成后就可以将其释放，内存回收容易实现。</p>
</blockquote>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><blockquote>
<p>堆内存的存储不同与栈，虽然他们都是内存中的一片空间，但是堆内存存储变量时没有什么规律可言。</p>
</blockquote>
<pre><code>const p1 = {};
const p2 = {};
const p3 = {};</code></pre><blockquote>
<p>我们在访问引用类型时，需要在栈内存中查找 对应的地址，在去堆内存中取得真正的值，访问速度自然不及栈内存。</p>
</blockquote>
<blockquote>
<p>对引用类型进行复制</p>
</blockquote>
<pre><code>const p4 = p3;
占用不同的栈但指针指向相同的堆</code></pre><blockquote>
<p>我们只是将地址复制了一遍，p4 和 p3 都是指向同一个地址，这就说明对 p4 进行修改时就会影响到 p3 的值。所以对引用类型进行复制时，应该把堆内存中的内容复制一遍，在将新地址赋值给新变量，这就涉及到深拷贝了, 那我就简单的实现下深拷贝：</p>
</blockquote>
<p><strong>堆总结：</strong></p>
<blockquote>
<p>堆内存的特点：使用灵活，可以动态增加或删除空间，但是存取比较慢</p>
</blockquote>
<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><pre><code>// 第一种
const a = {};
const b = JSON.parse(JSON.stringfy(a));

// 第二种
function clone(obj, hash = new WeakMap()) {
// 判断是否为 null 或者 typeof 返回类型是否为 object
if (obj == null || typeof obj !== &quot;object&quot;) return obj;
else if (obj instanceof Date) return new Date(obj);
else if (obj instanceof RegExp) return new RegExp(obj);

// 判断集合是否有这个属性，有则直接 return obj
if(hash.has(obj)) return hash.get(obj)
const newObj = new obj.constructor();

// 将属性和拷贝后的值作为一个map
hash.set(obj, newObj);

// 遍历 obj
for (let key in Object.getOwnPropertyDescriptors(obj)) {
    // 过滤掉原型身上的属性
    if (obj.hasOwnProperty(key)) {
        // 递归拷贝
        newObj[key] = clone(obj[key], hash);
    }

}
return newObj;
}</code></pre>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>栈</tag>
        <tag>基本类型</tag>
        <tag>引用类型</tag>
        <tag>深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>js遍历</title>
    <url>/2021/02/25/js%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><ul>
<li><p>返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</p>
</li>
<li><p>按照原始数组元素顺序依次处理元素。</p>
</li>
<li><p>不会改变原数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.map(<span class="function">(<span class="params">currentValue,index,array</span>)=&gt;</span>currentValue*index)</span><br><span class="line"><span class="comment">// currentValue 必须。当前元素的值</span></span><br><span class="line"><span class="comment">// index 可选。当前元素的索引值</span></span><br><span class="line"><span class="comment">// array 可选。当前元素属于的数组对象</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h1><ul>
<li><p>创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</p>
</li>
<li><p>不会改变原数组</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.filter(<span class="function">(<span class="params">currentValue,index,array</span>)=&gt;</span>currentValue&gt;index)</span><br><span class="line"><span class="comment">// currentValue 必须。当前元素的值</span></span><br><span class="line"><span class="comment">// index 可选。当前元素的索引值</span></span><br><span class="line"><span class="comment">// array 可选。当前元素属于的数组对象</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="find"><a href="#find" class="headerlink" title="find"></a>find</h1><ul>
<li><p>返回通过测试（函数内判断）的数组的第一个元素的值。</p>
</li>
<li><p>方法为数组中的每个元素都调用一次函数执行：</p>
<ul>
<li>当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。</li>
<li>如果没有符合条件的元素返回 undefined</li>
</ul>
</li>
<li><p>并没有改变数组的原始值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.find(<span class="function">(<span class="params">currentValue,index,array</span>)=&gt;</span>currentValue===index)</span><br><span class="line"><span class="comment">// currentValue 必须。当前元素的值</span></span><br><span class="line"><span class="comment">// index 可选。当前元素的索引值</span></span><br><span class="line"><span class="comment">// array 可选。当前元素属于的数组对象</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<h1 id="findIndex"><a href="#findIndex" class="headerlink" title="findIndex"></a>findIndex</h1><ul>
<li><p>返回传入一个测试条件（函数）符合条件的数组第一个元素位置。</p>
</li>
<li><p>方法为数组中的每个元素都调用一次函数执行：</p>
<ul>
<li>当数组中的元素在测试条件时返回 true 时, findIndex() 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。</li>
<li>如果没有符合条件的元素返回 -1</li>
</ul>
</li>
<li><p>并没有改变数组的原始值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.findIndex(<span class="function">(<span class="params">currentValue,index,array</span>)=&gt;</span>currentValue===index)</span><br><span class="line"><span class="comment">// currentValue 必须。当前元素的值</span></span><br><span class="line"><span class="comment">// index 可选。当前元素的索引值</span></span><br><span class="line"><span class="comment">// array 可选。当前元素属于的数组对象</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h1><ul>
<li>用于调用数组的每个元素，并将元素传递给回调函数。</li>
<li>遍历之后添加的元素不会被遍历</li>
<li>不会改变原数组</li>
<li>没办法终止<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> sum=<span class="number">0</span></span><br><span class="line"><span class="keyword">let</span> arr1 = arr.forEach(<span class="function">(<span class="params">currentValue,index,array</span>)=&gt;</span>sum+=currentValue)</span><br><span class="line"><span class="comment">// currentValue 必须。当前元素的值</span></span><br><span class="line"><span class="comment">// index 可选。当前元素的索引值</span></span><br><span class="line"><span class="comment">// array 可选。当前元素属于的数组对象</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="every"><a href="#every" class="headerlink" title="every"></a>every</h1><ul>
<li>测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值</li>
<li>若收到一个空数组，此方法在一切情况下都会返回 true<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> arr1 = arr.every(<span class="function">(<span class="params">currentValue,index,array</span>)=&gt;</span>currentValue&lt;<span class="number">10</span>)</span><br><span class="line"><span class="comment">// currentValue 必须。当前元素的值</span></span><br><span class="line"><span class="comment">// index 可选。当前元素的索引值</span></span><br><span class="line"><span class="comment">// array 可选。当前元素属于的数组对象</span></span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># entries()，keys() 和 values() </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">+ 用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 "a"</span></span><br><span class="line"><span class="comment">// 1 "b"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果不使用<span class="keyword">for</span>...of循环，可以手动调用遍历器对象的next方法，进行遍历。</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> letter = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> entries = letter.entries();</span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [0, 'a']</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [1, 'b']</span></span><br><span class="line"><span class="built_in">console</span>.log(entries.next().value); <span class="comment">// [2, 'c']</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>数组</tag>
        <tag>遍历</tag>
      </tags>
  </entry>
  <entry>
    <title>markdown</title>
    <url>/2020/07/22/markdown/</url>
    <content><![CDATA[<h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><pre><code>#一级标题
##二级标题
###三级标题</code></pre><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><hr>
<pre><code>代码 前用一个tab或者四个空格

this is code 
before is a tab or four space
少部分区块
`代码`
可以指定一部分预言

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">代码</span><br></pre></td></tr></table></figure></code></pre><hr>
<h1 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h1><pre><code>---
***</code></pre><hr>
<hr>
<h1 id="字体格式"><a href="#字体格式" class="headerlink" title="字体格式"></a>字体格式</h1><pre><code>*斜体文本*  
_斜体文本_  
**粗体文本**  
__粗体文本__  
***粗斜体文本***  
___粗斜体文本___  </code></pre><p>效果</p>
<p><em>斜体文本</em><br><em>斜体文本</em><br><strong>粗体文本</strong><br><strong>粗体文本</strong><br><strong><em>粗斜体文本</em></strong><br><strong><em>粗斜体文本</em></strong>  </p>
<hr>
<h1 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h1><pre><code>- 无序列表
- 无序列表</code></pre><ul>
<li><p>无序列表</p>
</li>
<li><h2 id="无序列表-1"><a href="#无序列表-1" class="headerlink" title="无序列表"></a>无序列表</h2><h1 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h1><ol>
<li>有序列表</li>
<li>有序列表</li>
</ol>
</li>
</ul>
<ol>
<li><p>有序列表</p>
</li>
<li><p>有序列表</p>
<hr>
<h1 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h1><ul>
<li>嵌套列表<ul>
<li>嵌套列表</li>
<li>嵌套列表</li>
</ul>
<ul>
<li>嵌套列表<ul>
<li>嵌套列表</li>
</ul>
</li>
</ul>
</li>
<li>嵌套列表</li>
</ul>
</li>
</ol>
<ul>
<li>嵌套列表<ul>
<li>嵌套列表</li>
<li>嵌套列表</li>
</ul>
<ul>
<li>嵌套列表<ul>
<li>嵌套列表</li>
</ul>
</li>
</ul>
</li>
<li>嵌套列表</li>
</ul>
<hr>
<h1 id="文字超链"><a href="#文字超链" class="headerlink" title="文字超链"></a>文字超链</h1><pre><code>Tooltips可省略
[不如](http://bruce-sha.github.io &quot;不如的博客&quot;)
[不如][1]

[1]:http://bruce-sha.github.io

直接使用链接地址
&lt;http://blog.dingyahui.top&gt;</code></pre><p> <a href="http://bruce-sha.github.io" target="_blank" rel="noopener" title="不如的博客">不如</a>   </p>
<p> <a href="http://bruce-sha.github.io" target="_blank" rel="noopener">不如</a></p>
<p> <a href="../_assets/images/vue生命周期图示.png">不如</a></p>
<p> <a href="http://blog.dingyahui.top">http://blog.dingyahui.top</a></p>
<hr>
<h1 id="图片超链"><a href="#图片超链" class="headerlink" title="图片超链"></a>图片超链</h1><p><strong>前面加入!即可显示图片内容</strong></p>
<pre><code> 多个感叹号，Tooltips可省略，要设置大小只能借助HTML标记
 ![GitHub Mark](http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png &quot;GitHub Mark&quot;)

![alt 属性文本](图片地址 &quot;可选标题&quot;)

可以直接使用img标签，指定宽度
&lt;img src = &quot;http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png&quot;/&gt;</code></pre><p><img src="http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png" alt="GitHub Mark" title="GitHub Mark"> </p>
<hr>
<h1 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h1><pre><code>Markdown中的转义字符为\，转义的有：
\\ 反斜杠
\` 反引号
\* 星号
\_ 下划线
\{\} 大括号
\[\] 中括号
\(\) 小括号
\# 井号
\+ 加号
\- 减号
\. 英文句号
\! 感叹号</code></pre><hr>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><pre><code>aaaa
&lt;!--注释内容 --&gt;</code></pre><p>aaaa</p>
<!-- 注释内容 -->


<h1 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h1><pre><code>&gt;区块内容
&gt;&gt;区块内容
&gt;&gt;&gt;区块内容</code></pre><blockquote>
<p>区块内容</p>
<blockquote>
<p>区块内容</p>
<blockquote>
<p>区块内容</p>
</blockquote>
</blockquote>
</blockquote>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><pre><code>| 表头 | 表头 |
| ---- | ---- |
| 内容 | 内容 |
| 内容 | 内容 |</code></pre><table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody><tr>
<td>内容</td>
<td>内容</td>
</tr>
<tr>
<td>内容</td>
<td>内容</td>
</tr>
</tbody></table>
<h1 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h1><pre><code>~~sdadadada~~</code></pre><p><del>sdasdadssa</del></p>
<h1 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h1><pre><code>&lt;u&gt;这是个带脚注的文本&lt;/u&gt;</code></pre><p><u>这是个带脚注的文本</u></p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><pre><code>[^这是个带脚注的文本]
[^这是个带脚注的文本]:这个是它的脚注</code></pre><p><a href="这个是它的脚注">^这是个带脚注的文本</a></p>
<h1 id="高级技巧"><a href="#高级技巧" class="headerlink" title="高级技巧"></a>高级技巧</h1><pre><code>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。

目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：

使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></pre><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>js基本属性-不常见</title>
    <url>/2021/07/19/js%E5%9F%BA%E6%9C%AC%E5%B1%9E%E6%80%A7-%E4%B8%8D%E5%B8%B8%E8%A7%81/</url>
    <content><![CDATA[<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><blockquote>
<p>Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p>
</blockquote>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><h3 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h3><blockquote>
<p>包含捕捉器（trap）的占位符对象，可译为处理器对象。</p>
</blockquote>
<h3 id="traps"><a href="#traps" class="headerlink" title="traps"></a>traps</h3><blockquote>
<p>提供属性访问的方法。这类似于操作系统中捕获器的概念。</p>
</blockquote>
<h3 id="target"><a href="#target" class="headerlink" title="target"></a>target</h3><blockquote>
<p>被 Proxy 代理虚拟化的对象。它常被作为代理的存储后端。根据目标验证关于对象不可扩展性或不可配置属性的不变量（保持不变的语义）。</p>
</blockquote>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="target-1"><a href="#target-1" class="headerlink" title="target"></a>target</h3><blockquote>
<p>要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</p>
</blockquote>
<h3 id="handler-1"><a href="#handler-1" class="headerlink" title="handler"></a>handler</h3><blockquote>
<p>一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</p>
</blockquote>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Proxy</span>.revocable()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>创建一个可撤销的Proxy对象。</p>
</blockquote>
<h2 id="handler-对象的方法"><a href="#handler-对象的方法" class="headerlink" title="handler 对象的方法"></a>handler 对象的方法</h2><blockquote>
<p>handler 对象是一个容纳一批特定属性的占位符对象。它包含有 Proxy 的各个捕获器（trap）。</p>
</blockquote>
<blockquote>
<p>所有的捕捉器是可选的。如果没有定义某个捕捉器，那么就会保留源对象的默认行为。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">handler.getPrototypeOf()</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf 方法的捕捉器。</span><br><span class="line">handler.setPrototypeOf()</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf 方法的捕捉器。</span><br><span class="line">handler.isExtensible()</span><br><span class="line"><span class="built_in">Object</span>.isExtensible 方法的捕捉器。</span><br><span class="line">handler.preventExtensions()</span><br><span class="line"><span class="built_in">Object</span>.preventExtensions 方法的捕捉器。</span><br><span class="line">handler.getOwnPropertyDescriptor()</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor 方法的捕捉器。</span><br><span class="line">handler.defineProperty()</span><br><span class="line"><span class="built_in">Object</span>.defineProperty 方法的捕捉器。</span><br><span class="line">handler.has()</span><br><span class="line"><span class="keyword">in</span> 操作符的捕捉器。</span><br><span class="line">handler.get()</span><br><span class="line">属性读取操作的捕捉器。</span><br><span class="line">handler.set()</span><br><span class="line">属性设置操作的捕捉器。</span><br><span class="line">handler.deleteProperty()</span><br><span class="line"><span class="keyword">delete</span> 操作符的捕捉器。</span><br><span class="line">handler.ownKeys()</span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames 方法和 <span class="built_in">Object</span>.getOwnPropertySymbols 方法的捕捉器。</span><br><span class="line">handler.apply()</span><br><span class="line">函数调用操作的捕捉器。</span><br><span class="line">handler.construct()</span><br><span class="line"><span class="keyword">new</span> 操作符的捕捉器。</span><br><span class="line">一些不标准的捕捉器已经被废弃并且移除了。</span><br></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h3><p>在以下简单的例子中，当对象中不存在属性名时，默认返回值为 37。下面的代码以此展示了 get handler 的使用场景。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> handler = &#123;</span><br><span class="line">    <span class="keyword">get</span>: function(obj, prop) &#123;</span><br><span class="line">        <span class="keyword">return</span> prop <span class="keyword">in</span> obj ? obj[prop] : <span class="number">37</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, handler);</span><br><span class="line">p.a = <span class="number">1</span>;</span><br><span class="line">p.b = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(p.a, p.b);      <span class="comment">// 1, undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'c'</span> <span class="keyword">in</span> p, p.c); <span class="comment">// false, 37</span></span><br></pre></td></tr></table></figure>
<h3 id="无操作转发代理"><a href="#无操作转发代理" class="headerlink" title="无操作转发代理"></a>无操作转发代理</h3><p>在以下例子中，我们使用了一个原生 JavaScript 对象，代理会将所有应用到它的操作转发到这个对象上。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> target = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;);</span><br><span class="line"></span><br><span class="line">p.a = <span class="number">37</span>;   <span class="comment">// 操作转发到目标</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(target.a);    <span class="comment">// 37. 操作已经被正确地转发</span></span><br></pre></td></tr></table></figure>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>通过代理，你可以轻松地验证向一个对象的传值。下面的代码借此展示了 set handler 的作用。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> validator = &#123;</span><br><span class="line">  <span class="keyword">set</span>: function(obj, prop, value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'age'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">Number</span>.isInteger(value)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'The age is not an integer'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (value &gt; <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'The age seems invalid'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The default behavior to store the value</span></span><br><span class="line">    obj[prop] = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, validator);</span><br><span class="line"></span><br><span class="line">person.age = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.age);</span><br><span class="line"><span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">person.age = <span class="string">'young'</span>;</span><br><span class="line"><span class="comment">// 抛出异常: Uncaught TypeError: The age is not an integer</span></span><br><span class="line"></span><br><span class="line">person.age = <span class="number">300</span>;</span><br><span class="line"><span class="comment">// 抛出异常: Uncaught RangeError: The age seems invalid</span></span><br></pre></td></tr></table></figure>
<h3 id="扩展构造函数"><a href="#扩展构造函数" class="headerlink" title="扩展构造函数"></a>扩展构造函数</h3><p>方法代理可以轻松地通过一个新构造函数来扩展一个已有的构造函数。这个例子使用了construct和apply。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">sup, base</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(</span><br><span class="line">    base.prototype, <span class="string">"constructor"</span></span><br><span class="line">  );</span><br><span class="line">  base.prototype = <span class="built_in">Object</span>.create(sup.prototype);</span><br><span class="line">  <span class="keyword">var</span> handler = &#123;</span><br><span class="line">    construct: <span class="function"><span class="keyword">function</span>(<span class="params">target, args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(base.prototype);</span><br><span class="line">      <span class="keyword">this</span>.apply(target, obj, args);</span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;,</span><br><span class="line">    apply: <span class="function"><span class="keyword">function</span>(<span class="params">target, that, args</span>) </span>&#123;</span><br><span class="line">      sup.apply(that, args);</span><br><span class="line">      base.apply(that, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(base, handler);</span><br><span class="line">  descriptor.value = proxy;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(base.prototype, <span class="string">"constructor"</span>, descriptor);</span><br><span class="line">  <span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Boy = extend(Person, <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Boy.prototype.sex = <span class="string">"M"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Peter = <span class="keyword">new</span> Boy(<span class="string">"Peter"</span>, <span class="number">13</span>);</span><br><span class="line"><span class="built_in">console</span>.log(Peter.sex);  <span class="comment">// "M"</span></span><br><span class="line"><span class="built_in">console</span>.log(Peter.name); <span class="comment">// "Peter"</span></span><br><span class="line"><span class="built_in">console</span>.log(Peter.age);  <span class="comment">// 13</span></span><br></pre></td></tr></table></figure>
<h3 id="操作-DOM-节点"><a href="#操作-DOM-节点" class="headerlink" title="操作 DOM 节点"></a>操作 DOM 节点</h3><p>有时，我们可能需要互换两个不同的元素的属性或类名。下面的代码以此为目标，展示了 set handler 的使用场景。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> view = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;</span><br><span class="line">  selected: <span class="literal">null</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="keyword">set</span>: function(obj, prop, newval) &#123;</span><br><span class="line">    <span class="keyword">let</span> oldval = obj[prop];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prop === <span class="string">'selected'</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldval) &#123;</span><br><span class="line">        oldval.setAttribute(<span class="string">'aria-selected'</span>, <span class="string">'false'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (newval) &#123;</span><br><span class="line">        newval.setAttribute(<span class="string">'aria-selected'</span>, <span class="string">'true'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认行为是存储被传入 setter 函数的属性值</span></span><br><span class="line">    obj[prop] = newval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示操作成功</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i1 = view.selected = <span class="built_in">document</span>.getElementById(<span class="string">'item-1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(i1.getAttribute(<span class="string">'aria-selected'</span>)); <span class="comment">// 'true'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i2 = view.selected = <span class="built_in">document</span>.getElementById(<span class="string">'item-2'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(i1.getAttribute(<span class="string">'aria-selected'</span>)); <span class="comment">// 'false'</span></span><br><span class="line"><span class="built_in">console</span>.log(i2.getAttribute(<span class="string">'aria-selected'</span>)); <span class="comment">// 'true'</span></span><br></pre></td></tr></table></figure>

<h3 id="一个完整的-traps-列表示例"><a href="#一个完整的-traps-列表示例" class="headerlink" title="一个完整的 traps 列表示例"></a>一个完整的 traps 列表示例</h3><p>出于教学目的，这里为了创建一个完整的 traps 列表示例，我们将尝试代理化一个非原生对象，这特别适用于这类操作：由 发布在 document.cookie页面上的“小型框架” (en-US)创建的docCookies全局对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  var docCookies = ... get the "docCookies" object here:</span></span><br><span class="line"><span class="comment">  https://developer.mozilla.org/zh-CN/docs/DOM/document.cookie#A_little_framework.3A_a_complete_cookies_reader.2Fwriter_with_full_unicode_support</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> docCookies = <span class="keyword">new</span> <span class="built_in">Proxy</span>(docCookies, &#123;</span><br><span class="line">  <span class="string">"get"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">oTarget, sKey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> oTarget[sKey] || oTarget.getItem(sKey) || <span class="literal">undefined</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"set"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">oTarget, sKey, vValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sKey <span class="keyword">in</span> oTarget) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> oTarget.setItem(sKey, vValue);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"deleteProperty"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">oTarget, sKey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sKey <span class="keyword">in</span> oTarget) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    <span class="keyword">return</span> oTarget.removeItem(sKey);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"enumerate"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">oTarget, sKey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> oTarget.keys();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"ownKeys"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">oTarget, sKey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> oTarget.keys();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"has"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">oTarget, sKey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sKey <span class="keyword">in</span> oTarget || oTarget.hasItem(sKey);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"defineProperty"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">oTarget, sKey, oDesc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oDesc &amp;&amp; <span class="string">"value"</span> <span class="keyword">in</span> oDesc) &#123; oTarget.setItem(sKey, oDesc.value); &#125;</span><br><span class="line">    <span class="keyword">return</span> oTarget;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"getOwnPropertyDescriptor"</span>: <span class="function"><span class="keyword">function</span> (<span class="params">oTarget, sKey</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> vValue = oTarget.getItem(sKey);</span><br><span class="line">    <span class="keyword">return</span> vValue ? &#123;</span><br><span class="line">      <span class="string">"value"</span>: vValue,</span><br><span class="line">      <span class="string">"writable"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">"enumerable"</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="string">"configurable"</span>: <span class="literal">false</span></span><br><span class="line">    &#125; : <span class="literal">undefined</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Cookies 测试 */</span></span><br><span class="line"></span><br><span class="line">alert(docCookies.my_cookie1 = <span class="string">"First value"</span>);</span><br><span class="line">alert(docCookies.getItem(<span class="string">"my_cookie1"</span>));</span><br><span class="line"></span><br><span class="line">docCookies.setItem(<span class="string">"my_cookie1"</span>, <span class="string">"Changed value"</span>);</span><br><span class="line">alert(docCookies.my_cookie1);</span><br></pre></td></tr></table></figure>

<h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><blockquote>
<p>instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。</p>
</blockquote>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">object <span class="keyword">instanceof</span> <span class="keyword">constructor</span></span><br></pre></td></tr></table></figure>
<h2 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h2><pre><code>object
某个实例对象
constructor
某个构造函数</code></pre><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote>
<p>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">D</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> C();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o <span class="keyword">instanceof</span> C; <span class="comment">// true，因为 Object.getPrototypeOf(o) === C.prototype</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o <span class="keyword">instanceof</span> D; <span class="comment">// false，因为 D.prototype 不在 o 的原型链上</span></span><br><span class="line"></span><br><span class="line">o <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true，因为 Object.prototype.isPrototypeOf(o) 返回 true</span></span><br><span class="line">C.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true，同上</span></span><br><span class="line"></span><br><span class="line">C.prototype = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> C();</span><br><span class="line"></span><br><span class="line">o2 <span class="keyword">instanceof</span> C; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">o <span class="keyword">instanceof</span> C; <span class="comment">// false，C.prototype 指向了一个空对象,这个空对象不在 o 的原型链上.</span></span><br><span class="line"></span><br><span class="line">D.prototype = <span class="keyword">new</span> C(); <span class="comment">// 继承</span></span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> D();</span><br><span class="line">o3 <span class="keyword">instanceof</span> D; <span class="comment">// true</span></span><br><span class="line">o3 <span class="keyword">instanceof</span> C; <span class="comment">// true 因为 C.prototype 现在在 o3 的原型链上</span></span><br></pre></td></tr></table></figure>

<p><em>需要注意的是，如果表达式 obj instanceof Foo 返回 true，则并不意味着该表达式会永远返回 true，因为 Foo.prototype 属性的值有可能会改变，改变之后的值很有可能不存在于 obj 的原型链上，这时原表达式的值就会成为 false。另外一种情况下，原表达式的值也会改变，就是改变对象 obj 的原型链的情况，虽然在目前的ES规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的 <strong>proto</strong> 伪属性，是可以实现的。比如执行 obj.<strong>proto</strong> = {} 之后，obj instanceof Foo 就会返回 false 了。</em></p>
<blockquote>
<p>instanceof 和多全局对象(例如：多个 frame 或多个 window 之间的交互)</p>
</blockquote>
<blockquote>
<blockquote>
<p>在浏览器中，我们的脚本可能需要在多个窗口之间进行交互。多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。这可能会引发一些问题。比如，表达式 [] instanceof window.frames[0].Array 会返回 false，因为 Array.prototype !== window.frames[0].Array.prototype，并且数组从前者继承。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>起初，你会认为这样并没有意义，但是当你在你的脚本中开始处理多个 frame 或多个 window 以及通过函数将对象从一个窗口传到另一个窗口时，这就是一个有效而强大的话题。比如，实际上你可以通过使用Array.isArray(myObj) 或者Object.prototype.toString.call(myObj) === “[object Array]” 来安全的检测传过来的对象是否是一个数组。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>比如检测一个 Nodes 在另一个窗口中是不是 SVGElement，你可以使用myNode instanceof myNode.ownerDocument.defaultView.SVGElement</p>
</blockquote>
</blockquote>
<h1 id="Object-defineProperties"><a href="#Object-defineProperties" class="headerlink" title="Object.defineProperties()"></a>Object.defineProperties()</h1><blockquote>
<p>Object.defineProperties() 方法直接在一个对象上定义新的属性或修改现有属性，并返回该对象。</p>
</blockquote>
<h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(obj, props)</span><br></pre></td></tr></table></figure>
<h2 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h2><pre><code>obj
在其上定义或修改属性的对象。
props
要定义其可枚举属性或修改的属性描述符的对象。对象中存在的属性描述符主要有两种：数据描述符和访问器描述符（更多详情，请参阅Object.defineProperty()）。描述符具有以下键：
    configurable
      true 只有该属性描述符的类型可以被改变并且该属性可以从对应对象中删除。
      默认为 false
    enumerable
      true 只有在枚举相应对象上的属性时该属性显现。
      默认为 false
    value
      与属性关联的值。可以是任何有效的JavaScript值（数字，对象，函数等）。
      默认为 undefined.
    writable
      true只有与该属性相关联的值被assignment operator改变时。
      默认为 false
    get
      作为该属性的 getter 函数，如果没有 getter 则为undefined。函数返回值将被用作属性的值。
      默认为 undefined
    set
      作为属性的 setter 函数，如果没有 setter 则为undefined。函数将仅接受参数赋值给该属性的新值。
      默认为 undefined
返回值
  传递给函数的对象。</code></pre><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><blockquote>
<p>Object.defineProperties本质上定义了obj 对象上props的可枚举属性相对应的所有属性。</p>
</blockquote>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperties(obj, &#123;</span><br><span class="line">  <span class="string">'property1'</span>: &#123;</span><br><span class="line">    value: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">'property2'</span>: &#123;</span><br><span class="line">    value: <span class="string">'Hello'</span>,</span><br><span class="line">    writable: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// etc. etc.</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="Polyfill"><a href="#Polyfill" class="headerlink" title="Polyfill"></a>Polyfill</h2><blockquote>
<p>假设一个原始的执行环境，所有的名称和属性都引用它们的初始值，Object.defineProperties几乎完全等同于（注意isCallable中的注释）以下JavaScript中的重新实现：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineProperties</span>(<span class="params">obj, properties</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">convertToDescriptor</span>(<span class="params">desc</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hasProperty</span>(<span class="params">obj, prop</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, prop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">isCallable</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// NB: modify as necessary if other values than functions are callable.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">typeof</span> v === <span class="string">'function'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> desc !== <span class="string">'object'</span> || desc === <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'bad desc'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> d = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasProperty(desc, <span class="string">'enumerable'</span>))</span><br><span class="line">      d.enumerable = !!desc.enumerable;</span><br><span class="line">    <span class="keyword">if</span> (hasProperty(desc, <span class="string">'configurable'</span>))</span><br><span class="line">      d.configurable = !!desc.configurable;</span><br><span class="line">    <span class="keyword">if</span> (hasProperty(desc, <span class="string">'value'</span>))</span><br><span class="line">      d.value = desc.value;</span><br><span class="line">    <span class="keyword">if</span> (hasProperty(desc, <span class="string">'writable'</span>))</span><br><span class="line">      d.writable = !!desc.writable;</span><br><span class="line">    <span class="keyword">if</span> (hasProperty(desc, <span class="string">'get'</span>)) &#123;</span><br><span class="line">      <span class="keyword">var</span> g = desc.get;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!isCallable(g) &amp;&amp; <span class="keyword">typeof</span> g !== <span class="string">'undefined'</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'bad get'</span>);</span><br><span class="line">      d.get = g;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasProperty(desc, <span class="string">'set'</span>)) &#123;</span><br><span class="line">      <span class="keyword">var</span> s = desc.set;</span><br><span class="line">      <span class="keyword">if</span> (!isCallable(s) &amp;&amp; <span class="keyword">typeof</span> s !== <span class="string">'undefined'</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'bad set'</span>);</span><br><span class="line">      d.set = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((<span class="string">'get'</span> <span class="keyword">in</span> d || <span class="string">'set'</span> <span class="keyword">in</span> d) &amp;&amp; (<span class="string">'value'</span> <span class="keyword">in</span> d || <span class="string">'writable'</span> <span class="keyword">in</span> d))</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'identity-confused descriptor'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'object'</span> || obj === <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'bad obj'</span>);</span><br><span class="line"></span><br><span class="line">  properties = <span class="built_in">Object</span>(properties);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(properties);</span><br><span class="line">  <span class="keyword">var</span> descs = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; keys.length; i++)</span><br><span class="line">    descs.push([keys[i], convertToDescriptor(properties[keys[i]])]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; descs.length; i++)</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(obj, descs[i][<span class="number">0</span>], descs[i][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Object-seal"><a href="#Object-seal" class="headerlink" title="Object.seal()"></a>Object.seal()</h1><blockquote>
<p>Object.seal()方法封闭一个对象，阻止添加新属性并将所有现有属性标记为不可配置。当前属性的值只要原来是可写的就可以改变。</p>
</blockquote>
<h2 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.seal(obj)</span><br></pre></td></tr></table></figure>
<h2 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h2><p>  obj<br>  将要被密封的对象。<br>  返回值<br>  被密封的对象。</p>
<h2 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h2><blockquote>
<p>通常，一个对象是可扩展的（可以添加新的属性）。密封一个对象会让这个对象变的不能添加新属性，且所有已有属性会变的不可配置。属性不可配置的效果就是属性变的不可删除，以及一个数据属性不能被重新定义成为访问器属性，或者反之。但属性的值仍然可以修改。尝试删除一个密封对象的属性或者将某个密封对象的属性从数据属性转换成访问器属性，结果会静默失败或抛出TypeError（在严格模式 中最常见的，但不唯一）。</p>
</blockquote>
<blockquote>
<p>不会影响从原型链上继承的属性。但 <strong>proto</strong> (  ) 属性的值也会不能修改。</p>
</blockquote>
<blockquote>
<p>返回被密封对象的引用。</p>
</blockquote>
<h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  prop: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  foo: <span class="string">'bar'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以添加新的属性</span></span><br><span class="line"><span class="comment">// 可以更改或删除现有的属性</span></span><br><span class="line">obj.foo = <span class="string">'baz'</span>;</span><br><span class="line">obj.lumpy = <span class="string">'woof'</span>;</span><br><span class="line"><span class="keyword">delete</span> obj.prop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.seal(obj);</span><br><span class="line"></span><br><span class="line">o === obj; <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.isSealed(obj); <span class="comment">// === true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 仍然可以修改密封对象的属性值</span></span><br><span class="line">obj.foo = <span class="string">'quux'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是你不能将属性重新定义成为访问器属性</span></span><br><span class="line"><span class="comment">// 反之亦然</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'foo'</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: function() &#123; <span class="keyword">return</span> <span class="string">'g'</span>; &#125;</span><br><span class="line">&#125;); <span class="comment">// throws a TypeError</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 除了属性值以外的任何变化，都会失败.</span></span><br><span class="line">obj.quaxxor = <span class="string">'the friendly duck'</span>;</span><br><span class="line"><span class="comment">// 添加属性将会失败</span></span><br><span class="line"><span class="keyword">delete</span> obj.foo;</span><br><span class="line"><span class="comment">// 删除属性将会失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在严格模式下，这样的尝试将会抛出错误</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="keyword">delete</span> obj.foo; <span class="comment">// throws a TypeError</span></span><br><span class="line">  obj.sparky = <span class="string">'arf'</span>; <span class="comment">// throws a TypeError</span></span><br><span class="line">&#125;</span><br><span class="line">fail();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过Object.defineProperty添加属性将会报错</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'ohai'</span>, &#123;</span><br><span class="line">  value: <span class="number">17</span></span><br><span class="line">&#125;); <span class="comment">// throws a TypeError</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'foo'</span>, &#123;</span><br><span class="line">  value: <span class="string">'eit'</span></span><br><span class="line">&#125;); <span class="comment">// 通过Object.defineProperty修改属性值</span></span><br></pre></td></tr></table></figure>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><blockquote>
<p>在ES5中，如果这个方法的参数不是一个（原始）对象，那么它将导致TypeError。在ES2015中，非对象参数将被视为已被密封的普通对象，会直接返回它。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.seal(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object (ES5 code)</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.seal(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 1                             (ES2015 code)</span></span><br></pre></td></tr></table></figure>

<h1 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze()"></a>Object.freeze()</h1><blockquote>
<p>使用Object.freeze()冻结的对象中的现有属性值是不可变的。用Object.seal()密封的对象可以改变其现有属性值。</p>
</blockquote>
<h1 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h1><blockquote>
<p>Object.getOwnPropertyDescriptor() 方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</p>
</blockquote>
<h2 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, prop)</span><br></pre></td></tr></table></figure>
<h2 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h2><pre><code>obj
需要查找的目标对象
prop
目标对象内属性名称
返回值
如果指定的属性存在于对象上，则返回其属性描述符对象（property descriptor），否则返回 undefined。</code></pre><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  property1: <span class="number">42</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> descriptor1 = <span class="built_in">Object</span>.getOwnPropertyDescriptor(object1, <span class="string">'property1'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(descriptor1.configurable);</span><br><span class="line"><span class="comment">// expected output: true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(descriptor1.value);</span><br><span class="line"><span class="comment">// expected output: 42</span></span><br></pre></td></tr></table></figure>

<h1 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h1><blockquote>
<p>Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的<em>proto_</em>(请打开浏览器控制台以查看运行结果.))</p>
</blockquote>
<h2 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Object</span>.create(proto，[propertiesObject])</span><br></pre></td></tr></table></figure>

<h2 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">proto</span><br><span class="line">新创建对象的原型对象.</span><br><span class="line">propertiesObject</span><br><span class="line">可选.需要传入一个对象，该对象的属性类型参照<span class="built_in">Object</span>.defineProperties()的第二个参数.如果该参数被指定且不为<span class="literal">undefined</span>、该传入对象的自有可枚举属性(即其自身定义的属性，而不是其原型链上的枚举属性)将为新创建的对象添加指定的属性值和对应的属性描述符.</span><br><span class="line">返回值</span><br><span class="line">一个新对象，带着指定的原型对象和属性.</span><br><span class="line"></span><br><span class="line">例外</span><br><span class="line">如果propertiesObject参数是<span class="literal">null</span>或非原始包装对象，则抛出一个<span class="built_in">TypeError</span>异常.</span><br></pre></td></tr></table></figure>

<h2 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h2><p>用 Object.create实现类式继承<br>下面的例子演示了如何使用Object.create()来实现类式继承.这是一个所有版本JavaScript都支持的单继承。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Shape - 父类(superclass)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类的方法</span></span><br><span class="line">Shape.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x += x;</span><br><span class="line">  <span class="keyword">this</span>.y += y;</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">'Shape moved.'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rectangle - 子类(subclass)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Shape.call(<span class="keyword">this</span>); <span class="comment">// call super constructor.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类续承父类</span></span><br><span class="line">Rectangle.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</span><br><span class="line">Rectangle.prototype.constructor = Rectangle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Is rect an instance of Rectangle?'</span>,</span><br><span class="line">  rect <span class="keyword">instanceof</span> Rectangle); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Is rect an instance of Shape?'</span>,</span><br><span class="line">  rect <span class="keyword">instanceof</span> Shape); <span class="comment">// true</span></span><br><span class="line">rect.move(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// Outputs, 'Shape moved.'</span></span><br><span class="line"></span><br><span class="line">如果你希望能继承到多个对象，则可以使用混入的方式.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     SuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">     OtherSuperClass.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承一个类</span></span><br><span class="line">MyClass.prototype = <span class="built_in">Object</span>.create(SuperClass.prototype);</span><br><span class="line"><span class="comment">// 混合其它</span></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, OtherSuperClass.prototype);</span><br><span class="line"><span class="comment">// 重新指定constructor</span></span><br><span class="line">MyClass.prototype.constructor = MyClass;</span><br><span class="line"></span><br><span class="line">MyClass.prototype.myMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="comment">// do a thing</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Object.assign会把OtherSuperClass原型上的函数拷贝到MyClass原型上，使MyClass的所有实例都可用Other SuperClass的方法.指定是在ES 2015引入的，且可用多填充…要支持旧浏览器的话，可用使用JQuery.EXTEND()或者_.分配()。</p>
<p>使用Object.create 的 propertyObject参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个原型为null的空对象</span></span><br><span class="line">o = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o = &#123;&#125;;</span><br><span class="line"><span class="comment">// 以字面量方式创建的空对象就相当于:</span></span><br><span class="line">o = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">o = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.prototype, &#123;</span><br><span class="line">  <span class="comment">// foo会成为所创建对象的数据属性</span></span><br><span class="line">  foo: &#123;</span><br><span class="line">    writable:<span class="literal">true</span>,</span><br><span class="line">    configurable:<span class="literal">true</span>,</span><br><span class="line">    value: <span class="string">"hello"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// bar会成为所创建对象的访问器属性</span></span><br><span class="line">  bar: &#123;</span><br><span class="line">    configurable: <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">get</span>: function() &#123; <span class="keyword">return</span> <span class="number">10</span> &#125;,</span><br><span class="line">    <span class="keyword">set</span>: function(value) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"Setting `o.bar` to"</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Constructor</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">o = <span class="keyword">new</span> Constructor();</span><br><span class="line"><span class="comment">// 上面的一句就相当于:</span></span><br><span class="line">o = <span class="built_in">Object</span>.create(Constructor.prototype);</span><br><span class="line"><span class="comment">// 当然,如果在Constructor函数中有一些初始化代码,Object.create不能执行那些代码</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个以另一个空对象为原型,且拥有一个属性p的对象</span></span><br><span class="line">o = <span class="built_in">Object</span>.create(&#123;&#125;, &#123; <span class="attr">p</span>: &#123; <span class="attr">value</span>: <span class="number">42</span> &#125; &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:</span></span><br><span class="line">o.p = <span class="number">24</span></span><br><span class="line">o.p</span><br><span class="line"><span class="comment">//42</span></span><br><span class="line"></span><br><span class="line">o.q = <span class="number">12</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> prop <span class="keyword">in</span> o) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(prop)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//"q"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> o.p</span><br><span class="line"><span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个可写的,可枚举的,可配置的属性p</span></span><br><span class="line">o2 = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;</span><br><span class="line">  p: &#123;</span><br><span class="line">    value: <span class="number">42</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="polyfill"><a href="#polyfill" class="headerlink" title="polyfill"></a>polyfill</h2><blockquote>
<p>这个聚填充涵盖了主要的应用场景，它创建一个已经选择了原型的新对象，但没有把第二个参数考虑在内.</p>
</blockquote>
<blockquote>
<p>请注意，尽管在ES5中Object.create支持设置为[[Prototype]]为null、但因为那些ECMAScript5以前版本限制，此Poly填充无法支持该特性.</p>
</blockquote>
<p>if (typeof Object.create !== “function”) {<br>    Object.create = function (proto, propertiesObject) {<br>        if (typeof proto !== ‘object’ &amp;&amp; typeof proto !== ‘function’) {<br>            throw new TypeError(‘Object prototype may only be an Object: ‘ + proto);<br>        } else if (proto === null) {<br>            throw new Error(“This browser’s implementation of Object.create is a shim and doesn’t support ‘null’ as the first argument.”);<br>        }</p>
<pre><code>    if (typeof propertiesObject !== &apos;undefined&apos;) throw new Error(&quot;This browser&apos;s implementation of Object.create is a shim and doesn&apos;t support a second argument.&quot;);

    function F() {}
    F.prototype = proto;

    return new F();
};</code></pre><p>}</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>rem相关</title>
    <url>/2020/08/20/rem%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><pre><code>let clientWidth = document.documentElement.clientWidth;
if (!clientWidth) return;
let pxOneRem = clientWidth / 7.5;
document.documentElement.style.fontSize = pxOneRem + &quot;px&quot;;</code></pre><blockquote>
<p>个人理解:设置html样式的font-size为10px,则1rem为未10px<br>在设备的适配中，尤其是手机设备中，由于不同设备的尺寸大小，纵横比差距过大，所以会导致使用<br>px往往不能满足这些需求。使用百分比在纵横比不同的手机上表现差距也会很大。故可以采用rem。</p>
</blockquote>
<blockquote>
<p>通过获取设备html的宽度，然后除于10,100,7.5,25这些你自定义的值，在此以7.5为例。<br>那么7.5rem便是100vw，即宽度的100%。如果除的值是100，那么rem和vw便会有很多的相似点，<br>但也会有不同的地方，如若手机字体方法，则同时rem也会改变。</p>
</blockquote>
<h2 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h2><blockquote>
<p>那么在一些改变字体的手机上，可能会出现实际的rem值比你想要的偏大，导致页面效果异常。<br>旧手机这个现象比较常见，则可以采用下列的方法进行修复，<br>这里放在vue的钩子中</p>
</blockquote>
<pre><code>data () {
  return {
      resizeEvt: &quot;orientationchange&quot; in window ? &quot;orientationchange&quot; : &quot;resize&quot;
  }
 }
destroyed() {
  window.removeEventListener(this.resizeEvt, this.adjustRem(), false);
 },
 mounted() {
   this.init();
 },
 methods: {
   init() {
     // 调整rem尺寸
     this.adjustRem();
     // 修复字体放大手机上rem尺寸错误的问题
     window.addEventListener(this.resizeEvt, this.adjustRem(), false);
   },
   adjustRem() {
     console.log(&quot;触发了尺寸检测变化&quot;);
     let clientWidth = document.documentElement.clientWidth;
     if (!clientWidth) return;
     let pxOneRem = clientWidth / 7.5;
     document.documentElement.style.fontSize = pxOneRem + &quot;px&quot;;
     // 纠错函数
     function adapt() {
       let d = window.document.createElement(&quot;div&quot;);
       d.style.width = &quot;1rem&quot;;
       d.style.display = &quot;none&quot;;
       let head = window.document.getElementsByTagName(&quot;head&quot;)[0];
       head.appendChild(d);
       let defaultFontSize = parseFloat(
         window.getComputedStyle(d, null).getPropertyValue(&quot;width&quot;)
       );
       return defaultFontSize;
     }
     pxOneRem = (pxOneRem * pxOneRem) / adapt();
     document.documentElement.style.fontSize = pxOneRem + &quot;px&quot;;
   },
  }</code></pre><blockquote>
<p>实测有用, 如有问题评论区留言即可</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
        <category>rem</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>rem</tag>
      </tags>
  </entry>
  <entry>
    <title>svg</title>
    <url>/2021/04/13/svg/</url>
    <content><![CDATA[<h1 id="svg路径"><a href="#svg路径" class="headerlink" title="svg路径"></a>svg路径</h1><h2 id="path"><a href="#path" class="headerlink" title="path"></a>path</h2><blockquote>
<p><path> 标签用来定义路径。</p>
</blockquote>
<h3 id="d"><a href="#d" class="headerlink" title="d"></a>d</h3><blockquote>
<p>该属性定义了一个路径</p>
</blockquote>
<ul>
<li>下面的命令可用于路径数据：</li>
</ul>
<ul>
<li><p>M = moveto </p>
<ul>
<li>移动到点对应位置，与上个点之间没有路径</li>
<li>M x,y</li>
</ul>
</li>
<li><p>L = lineto</p>
<ul>
<li>与上个点之间绘制一条直线</li>
<li>L x, y</li>
</ul>
</li>
<li><p>H = horizontal lineto</p>
<ul>
<li>与上个点之间绘制一条水平的线</li>
<li>H x, y</li>
</ul>
</li>
<li><p>V = vertical lineto</p>
<ul>
<li>与上个点之间绘制一条垂直的线</li>
<li>V x, y</li>
</ul>
</li>
<li><p>C = curveto</p>
<ul>
<li><p>Curvto命令指定了一个贝塞尔曲线。有两种类型的贝塞尔曲线：立方曲线和二次方曲线。</p>
</li>
<li><p>二次方贝塞尔曲线是一种特殊的立方贝塞尔曲线，在这里，控制点的两端是相同的。二次方贝塞尔曲线的句法是”Q cx, cy  x, y“或”q dcx, dcy dx, dy“。cx和cy都是控制点的绝对坐标，而dcx和dcy分别是控制点在x和y方向上的距离。 </p>
</li>
<li><p>立方贝赛尔曲线遵守二次方贝赛尔曲线同样的概念，但是它需要考虑两个控制点。立方贝塞尔曲线的句法是：”C c1x,c1y c2x,c2y x,y“或者”c dc1x,dc1y dc2x,dc2y dx,dy“，在这里，c1x、c1y和c2x、c2y是分别是初始点和结束点的控制点的绝对坐标。dc1x、dc1y和dc2x、dc2y都是相对于初始点，而不是相对于结束点的。dx和dy分别是向右和向下的距离。 </p>
</li>
<li><p>最后，所有的贝塞尔曲线命令可以制作出一个多边贝塞尔图形，先初始化命令，然后多次指定所有的参数，就可以制作出一个多边贝赛尔图形。因此，下面的两个命令可以创建完全相同的路径：</p>
<pre><code>&lt;path d=&quot;c 50,0 50,100 100,100 50,0 50,-100 100,-100&quot; /&gt;
&lt;path d=&quot;c 50,0 50,100 100,100 c 50,0 50,-100 100,-100&quot; /&gt;</code></pre></li>
</ul>
</li>
<li><p>S = smooth curveto</p>
<ul>
<li>因为它假定第一个控制点是从前一个控制点关于前一个点的反射，或者说如果没有前一个控制点的话它实际上就是前一个点。</li>
<li>S用来创建立方贝塞尔曲线，语法是”S cx,cy x,y“或者”s dcx,dcy dx,dy“，在这里(d)cx指定第二个控制点。</li>
</ul>
</li>
<li><p>Q = quadratic Belzier curve</p>
<ul>
<li>二次方贝塞尔曲线的句法是”Q cx, cy  x, y“或”q dcx, dcy dx, dy“。cx和cy都是控制点的绝对坐标，而dcx和dcy分别是控制点在x和y方向上的距离。</li>
</ul>
</li>
<li><p>T = smooth quadratic Belzier curveto</p>
<ul>
<li>因为它假定第一个控制点是从前一个控制点关于前一个点的反射，或者说如果没有前一个控制点的话它实际上就是前一个点。</li>
<li>T的句法是”T x,y“或者”t dx,dy“，分别对应于绝对坐标和相对距离，用来创建二次方贝塞尔曲线</li>
</ul>
</li>
<li><p>A = elliptical Arc</p>
<ul>
<li>”A rx,ry xAxisRotate LargeArcFlag,SweepFlag x,y“。解构它，rx和ry分别是x和y方向的半径，而LargeArcFlag的值要到是0要么是1，用来确定是要画小弧（0）还是画大弧（1）。SweepFlag也要么是0要么是1，用来确定弧是顺时针方向（1）还是逆时针方向（0）。x和y是目的地的坐标。虽然xAxisRotate支持改变x轴相对于当前引用框架的方向，但是在Gecko 7中，这个参数看起来没什么效果。</li>
</ul>
</li>
<li><p>Z = closepath</p>
<ul>
<li>ClosePath命令将在当前路径从，从当前点到第一个点简单画一条直线。它是最简单的命令</li>
</ul>
</li>
</ul>
<blockquote>
<p>注释：以上所有命令均允许小写字母。大写表示绝对定位，小写表示相对定位。</p>
</blockquote>
<blockquote>
<p>请把下面的代码拷贝到记事本，然后把文件保存为 “path1.svg”。把此文件放入您的 web 目录：</p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;
&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; 
&quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;

&lt;svg width=&quot;100%&quot; height=&quot;100%&quot; version=&quot;1.1&quot;
xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;

&lt;path d=&quot;M250 150 L150 350 L350 350 Z&quot; /&gt;

&lt;/svg&gt;</code></pre><blockquote>
<p>上面的例子定义了一条路径，它开始于位置 250 150，到达位置 150 350，然后从那里开始到 350 350，最后在 250 150 关闭路径。</p>
</blockquote>
<blockquote>
<p>下面的例子创建了一个螺旋：</p>
</blockquote>
<pre><code>&lt;?xml version=&quot;1.0&quot; standalone=&quot;no&quot;?&gt;
&lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; 
&quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt;

&lt;svg width=&quot;100%&quot; height=&quot;100%&quot; version=&quot;1.1&quot;
xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;

&lt;path d=&quot;M153 334
C153 334 151 334 151 334
C151 339 153 344 156 344
C164 344 171 339 171 334
C171 322 164 314 156 314
C142 314 131 322 131 334
C131 350 142 364 156 364
C175 364 191 350 191 334
C191 311 175 294 156 294
C131 294 111 311 111 334
C111 361 131 384 156 384
C186 384 211 361 211 334
C211 300 186 274 156 274&quot;
style=&quot;fill:white;stroke:red;stroke-width:2&quot;/&gt;

&lt;/svg&gt;</code></pre><h2 id="Stroke属性"><a href="#Stroke属性" class="headerlink" title="Stroke属性"></a>Stroke属性</h2><h3 id="Stroke"><a href="#Stroke" class="headerlink" title="Stroke"></a>Stroke</h3><blockquote>
<p>Stroke属性定义一条线，文本或元素轮廓颜色：</p>
</blockquote>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <g fill="none">
  <path stroke="red" d="M5 20 l215 0" />
  <path stroke="blue" d="M5 40 l215 0" />
  <path stroke="black" d="M5 60 l215 0" />
  </g>
  </svg>

<pre><code>下面是SVG代码：
实例
&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;
&lt;g fill=&quot;none&quot;&gt;
&lt;path stroke=&quot;red&quot; d=&quot;M5 20 l215 0&quot; /&gt;
&lt;path stroke=&quot;blue&quot; d=&quot;M5 40 l215 0&quot; /&gt;
&lt;path stroke=&quot;black&quot; d=&quot;M5 60 l215 0&quot; /&gt;
&lt;/g&gt;
&lt;/svg&gt;</code></pre><h3 id="stroke-width"><a href="#stroke-width" class="headerlink" title="stroke-width"></a>stroke-width</h3><blockquote>
<p>stroke- width属性定义了一条线，文本或元素轮廓厚度：</p>
</blockquote>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <g fill="none" stroke="black">
  <path stroke-width="2" d="M5 20 l215 0" />
  <path stroke-width="4" d="M5 40 l215 0" />
  <path stroke-width="6" d="M5 60 l215 0" />
  </g>
  </svg>


<p>下面是SVG代码：</p>
<pre><code>&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;
&lt;g fill=&quot;none&quot; stroke=&quot;black&quot;&gt;
&lt;path stroke-width=&quot;2&quot; d=&quot;M5 20 l215 0&quot; /&gt;
&lt;path stroke-width=&quot;4&quot; d=&quot;M5 40 l215 0&quot; /&gt;
&lt;path stroke-width=&quot;6&quot; d=&quot;M5 60 l215 0&quot; /&gt;
&lt;/g&gt;
&lt;/svg&gt;</code></pre><h3 id="stroke-linecap"><a href="#stroke-linecap" class="headerlink" title="stroke-linecap"></a>stroke-linecap</h3><blockquote>
<p>strokelinecap属性定义不同类型的开放路径的终结：</p>
</blockquote>
<p>实例</p>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <g fill="none" stroke="black" stroke-width="6">
  <path stroke-linecap="butt" d="M5 20 l215 0" />
  <path stroke-linecap="round" d="M5 40 l215 0" />
  <path stroke-linecap="square" d="M5 60 l215 0" />
  </g>
  </svg>

<p>下面是SVG代码：</p>
<pre><code>&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;
&lt;g fill=&quot;none&quot; stroke=&quot;black&quot; stroke-width=&quot;6&quot;&gt;
&lt;path stroke-linecap=&quot;butt&quot; d=&quot;M5 20 l215 0&quot; /&gt;
&lt;path stroke-linecap=&quot;round&quot; d=&quot;M5 40 l215 0&quot; /&gt;
&lt;path stroke-linecap=&quot;square&quot; d=&quot;M5 60 l215 0&quot; /&gt;
&lt;/g&gt;
&lt;/svg&gt;</code></pre><h3 id="stroke-dasharray"><a href="#stroke-dasharray" class="headerlink" title="stroke-dasharray"></a>stroke-dasharray</h3><blockquote>
<p>strokedasharray属性用于创建虚线：</p>
</blockquote>
<p>实例</p>
  <svg xmlns="http://www.w3.org/2000/svg" version="1.1">
  <g fill="none" stroke="black" stroke-width="4">
  <path stroke-dasharray="5,5" d="M5 20 l215 0" />
  <path stroke-dasharray="10,10" d="M5 40 l215 0" />
  <path stroke-dasharray="20,10,5,5,5,10" d="M5 60 l215 0" />
  </g>
  </svg>

<p>下面是SVG代码：</p>
<pre><code>&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot;&gt;
&lt;g fill=&quot;none&quot; stroke=&quot;black&quot; stroke-width=&quot;4&quot;&gt;
&lt;path stroke-dasharray=&quot;5,5&quot; d=&quot;M5 20 l215 0&quot; /&gt;
&lt;path stroke-dasharray=&quot;10,10&quot; d=&quot;M5 40 l215 0&quot; /&gt;
&lt;path stroke-dasharray=&quot;20,10,5,5,5,10&quot; d=&quot;M5 60 l215 0&quot; /&gt;
&lt;/g&gt;
&lt;/svg&gt;</code></pre>]]></content>
      <categories>
        <category>前端</category>
        <category>svg</category>
      </categories>
      <tags>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title>scss函数</title>
    <url>/2020/07/23/scss%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h1 id="Scss函数"><a href="#Scss函数" class="headerlink" title="Scss函数"></a>Scss函数</h1><h2 id="abs-number-绝对值"><a href="#abs-number-绝对值" class="headerlink" title="abs($number) 绝对值"></a>abs($number) 绝对值</h2><blockquote>
<p>说明：取变量的绝对值，可以包含单位。<br>返回类型：number</p>
</blockquote>
<pre><code>@debug abs(-10);   // 10
@debug abs(-10in); // 10in
@debug abs(-10px); // 10px</code></pre><h2 id="ceil-number-向高位取整"><a href="#ceil-number-向高位取整" class="headerlink" title="ceil($number) 向高位取整"></a>ceil($number) 向高位取整</h2><blockquote>
<p>说明：把数值中的小数舍去，取下一个整数。返回类型：number</p>
</blockquote>
<pre><code>@debug ceil(4); // 4
@debug ceil(4.2); // 5
@debug ceil(4.9); // 5</code></pre><h2 id="comparable-number-number2-判断单位"><a href="#comparable-number-number2-判断单位" class="headerlink" title="comparable($number,$number2) 判断单位"></a>comparable($number,$number2) 判断单位</h2><blockquote>
<p>说明：判断$number和$number2是否有同类型的单位，例如px和px，cm和mm等。如果返回true，这两个变量可以相加、相减、比较，否则对$number和$number2进行上述运算时会报错。<br>返回类型：boolean</p>
</blockquote>
<pre><code>@debug comparable(2px, 1px); // true
@debug comparable(100px, 3em); // false
@debug comparable(10cm, 3mm); // true</code></pre><h2 id="floor-number-向低位取整"><a href="#floor-number-向低位取整" class="headerlink" title="floor($number) 向低位取整"></a>floor($number) 向低位取整</h2><blockquote>
<p>说明：把数值中的小数舍去。<br>返回类型：number</p>
</blockquote>
<pre><code>@debug floor(4); // 4
@debug floor(4.2); // 4
@debug floor(4.9); // 4</code></pre><h2 id="max-number…-取最大值"><a href="#max-number…-取最大值" class="headerlink" title="max($number…) 取最大值"></a>max($number…) 取最大值</h2><blockquote>
<p>说明：参数中最大的一个数。如果参数是数组，则需要在后面添加…才能执行，不然会报错<br>返回类型：number</p>
</blockquote>
<pre><code>@debug max(1px, 4px); // 4px
$widths: 50px, 30px, 100px;
@debug max($widths...); // 100px</code></pre><h2 id="min-number…-取最小值"><a href="#min-number…-取最小值" class="headerlink" title="min($number…) 取最小值"></a>min($number…) 取最小值</h2><blockquote>
<p>说明：参数中最小的一个数。如果参数是数组，则需要在后面添加…才能执行，不然会报错<br>返回类型：number</p>
</blockquote>
<pre><code>@debug min(1px, 4px); // 1px
$widths: 50px, 30px, 100px;
@debug min($widths...); // 30px</code></pre><h2 id="percentage-number-转换为百分比"><a href="#percentage-number-转换为百分比" class="headerlink" title="percentage($number) 转换为百分比"></a>percentage($number) 转换为百分比</h2><blockquote>
<p>说明：把没有单位的值转换为百分比，通常是0到1的浮点数，带单位会报错。此函数和$number * 100%效果是一样的。<br>返回类型：number</p>
</blockquote>
<pre><code>@debug percentage(0.2); // 20%
$number : 0.2;
@debug $number * 100%;  // 20%
@debug percentage(100px / 50px); // 200%  100px和50px带单位，但是除法运算后是2，不带单位</code></pre><h2 id="random-limit-null-生成随机数"><a href="#random-limit-null-生成随机数" class="headerlink" title="random($limit:null)  生成随机数"></a>random($limit:null)  生成随机数</h2><blockquote>
<p>说明：生成随机数。参数$limit默认为null，为随机数最大值。<br>返回类型：number<br>如果$limit为null时，结果介于0与1之间。</p>
</blockquote>
<pre><code>@debug random(); // 0.2821251858
@debug random(); // 0.6221325814</code></pre><blockquote>
<p>如果$limit不为空时，结果介于1与$limit之间，参数必须大于或等于1，而且为整数，否则报错。</p>
</blockquote>
<pre><code>@debug random(10); // 4
@debug random(10000); // 5373</code></pre><h2 id="round-number-四舍五入"><a href="#round-number-四舍五入" class="headerlink" title="round($number) 四舍五入"></a>round($number) 四舍五入</h2><blockquote>
<p>说明：四舍五入（0.5进位操作）<br>返回类型：number</p>
</blockquote>
<pre><code>@debug round(4); // 4
@debug round(4.2); // 4
@debug round(4.9); // 5</code></pre><h2 id="unit-number-取单位"><a href="#unit-number-取单位" class="headerlink" title="unit($number) 取单位"></a>unit($number) 取单位</h2><blockquote>
<p>说明：获取参数的单位，字符串形式返回<br>返回类型：quoted string<br>注意：这个方法是用于调试的，不保证输出结果和发布的一致</p>
</blockquote>
<pre><code>@debug unit(100); // &quot;&quot;
@debug unit(100px); // &quot;px&quot;
@debug unit(5px * 10px); // &quot;px*px&quot;
@debug unit(5px / 1s); // &quot;px/s&quot;</code></pre><h2 id="unitless-number"><a href="#unitless-number" class="headerlink" title="unitless($number)"></a>unitless($number)</h2><blockquote>
<p>说明：判断$number是否没有单位<br>返回类型：boolean</p>
</blockquote>
<pre><code>@debug unitless(100); // true</code></pre>]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
        <category>scss</category>
      </categories>
      <tags>
        <tag>scss</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常见命令</title>
    <url>/2020/09/16/linux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h1><pre><code>===================目录操作========================
mkdir: 创建目录
　　-p : 递归的创建目录 也就是可以创建多层目录
　　一次创建多个目录： mkdir {a,b,c,d,e,f}
　　一次创建 a b c d e f多个目录。
rmdir：删除一个空文件夹
cp：复制文件或者文件夹

　　-a =-pdr
　　-p 同时复制文件属性，比如修改日期
　　-d 复制时保留文件链接
　　-r: 复制文件夹时,递归复制子文件夹
　　-l 不复制，而是创建指向源文件的链接文件，链接文件名由目标文件给出。   
　　note:可以在拷贝的同时重命名
mv：移动文件或者文件夹，可以在移动的时候重命名

rm ：删除文件或者文件夹
　　-r：递归删除
　　-f：强制删除 即没有提醒

======================文件处理命令==============================
ls :查看文件
　　-l 以列表形式查看
　　-h 以一种人性化的方式查看，也是文件的大小以合适的单位显示
　　-a 查看所有文件，包括隐藏文件
　　-i 显示出文件的i节点号
touch 文件名：创建文件 可以一次创建多个文件，以空格隔开

cat :查看文件内容 
　　-n:带行号
tac:反向显示文件内容

more：分页查看文件内容
　　进入浏览模式后：
　　f或者空格：下一页
　　enter：一行一行往下翻
　　q:退出

less:查看文件内容 
　　空格翻页
　　回车换行
　　pageup：上一页
　　pagedown：下一页
　　上箭头：向上翻
　　下箭头：向下翻
　　/搜索词 n向下找

head -n 文件名 :查看文件前n行。缺省-n显示前10行
tail -n 文件名 ：查看文件的末尾几行
　　-f :动态显示文件末尾内容

ln:链接命令
　　-s创建软连接
　　硬链接和cp -p的区别是硬链接会同步更新
　　源文件如果丢失，硬链接依然存在。
　　硬链接和源文件的i节点相同。
　　硬链接不能夸分区，软连接可以跨分区。
　　硬链接不可以链接目录，链接可以
　　软连接文件具有的权限是ugo都是rwx

====================权限管理命令==============
chmod:修改文件或目录的权限，只有root和所有者可以更改
　　[{ugoa}{+-=}{rwx}] [文件或目录] 
　　[mode=421] [文件或目录]
　　-R 递归修改
　　权限的数字表示：
　　r-&gt;4
　　w-&gt;2
　　x-&gt;1

　　例：chmod u+x a.txt
　　　　chmod g+w,o-r a.txt //同时做多个权限的修改
　　　　chmod g=rwx a.txt
　　　　chmod 640 a.txt
　　　　chmod -R 777 testdir //把目录和下面所有文件的权限

　　　　　　　　　　　　针对文件　　 　　　　 针对目录
　　　　r　　 读权限 　　 可以查看文件内容　　  可以列出目录中的内容
　　　　w 　  写权限 　　 可以修改文件内容 　　 可以在目录中创建、删除文件
　　　　x 　   执行权限      可以执行文件 　　　　 可以进入目录

chown:更改文件所有者，只有root可以更改
　　chown root a.txt//把a.txt更改为root所有

chgrp:更改所属组
　　chgrp lambrother fengjie //把fengjie的所属组更改为lambrother

umask -S:查看创建文件的缺省权限，即默认权限
umask 023:修改文件的缺省权限为777-023=754。即rwxr-xr--



=====================文件搜索命令========================================
find:搜索制定范围内的文件
　　find [搜索范围] [匹配条件]
　　-name 按文件名搜索
　　-iname 根据文件名查找，不区分大小写
　　-size +n大于 -n小于 n等于 这个n是数据块，在Linux中一个数据块是512字节大小
　　-user 根据所有者查找
　　-group 根据所属组查找
　　根据文件属性查找：
　　　　-amin 访问时间 access
　　　　-cmin 根据文件属性被修改的时间 change
　　　　-mmin 根据文件内容被修改的时间 modify
　　例： find /etc -cmin -5 :查找/etc目录下五分钟内被修改过属性的文件和目录

　　-a 两个条件同时满足
　　　　find /etc -size +10 -a -size -50
　　-o 两个条件满足一个即可

　　-type 
　　　　f 文件 d 目录 l软连接文件
　　-inum 根据i节点查找

　　对找到的结果进行操作
　　　　-exec或者-ok 命令 {} \;
　　　　例如：
　　　　　　find /etc -name init* -exec ls -l {} \; 对找到的文件名按列表查看

　　find /etc -name init :搜索目录/etc下面所有的init文件，精确匹配，包括子目录中的init文件
　　find / -size +204800 搜索大于100M的文件

locate:(查找速度非常快，因为它维护了一个文件库。缺点就是新建立的文件没有很快收录到文件库)
　　locate 文件名
　　updatedb 更新locate的文件资料库 文件资料库不收录/tmp下的文件
　　-i 不区分大小写

which :查找命令的目录以及别名
　　which 命令

whereis :搜索命令所在目录及帮助文档路径。

grep:在文件中搜寻字符串匹配的行并输出，多个文件以空格隔开。
　　-i不区分大小写
　　-v排除指定字符串
　　-E 以正则表达式的方式搜索
　　-F 以普通文本的方式搜索
　　-n 显示搜索到的内容在文件中的行号。

==================帮助命令======================
man：查看命令或者配置文件的帮助信息
　　man 命令/配置文件
　　在手册里面，可以输入/要查找的str
　　man ls
　　man services
　　man fstab //直接输入配置文件的名字，而不需要使用绝对路径 重点查看name选项和配置文件的格式。
　　如果一个命令即使命令又是配置文件，那么可以使用一个序号进行区分，比如：
　　man 1 passwd 查看命令passwd的帮助
　　man 5 passwd 查看配置文件passwd的帮助

whatis 命令：得到命令的简要信息

apropos 配置文件名：查看配置文件的简短信息

命令 --help：查看命令的选项。

help 命令：查看shell内置命令的帮助信息。 shell内置命令是没有命令路径。不能使用man查看帮助。

===================用户管理命令==========================================
useradd: 添加用户
　　useradd 用户名

passwd: 修改用户密码
　　passwd 用户名 不加用户名直接更改自己的密码

who:查看当前的账户 显示的格式为： 登录用户名 登录终端（tty:本地登录 pts:远程终端） 登录时间 ip地址

　　w:查看更详细的用户登录信息。


=====================================压缩解压缩命令============================
.gz格式
　　压缩：gzip 文件名 只能压缩文件不能压缩目录，压缩完源文件也不见了
　　解压缩：gunzip/gzip -d 压缩包名称

tar:
　　-zcvf 压缩后文件名 打包的目录 :生成.tar.gz文件 注：这个命令先用tar归档，然后把归档的包压缩成.gz
　　-zxvf 要解压的文件名 ：解压缩.tar.bz2的文件

　　-jcvf 压缩后的文件名 打包的目录：生成.tar.bz2 注：这个命令先用tar归档，然后把归档的包压缩成.bz2
　　-jxvf 要解压的文件名 :解压.tar.bz2的文件

zip:
　　zip -r 压缩生成的文件名 要压缩的目录
　　zip 压缩生成的文件名 要压缩的文件。

unzip:
　　unzip 要解压缩的文件

bzip2:
　　bzip2 -k 要压缩的文件名 -k选项：保留源文件
　　bunzip2 -k 要解压的文件名 -k选项：保留压缩包



===============网络命令==========================
write:给在线用户发送信息，用户不在线不行。以Ctrl+D保存
　　write 用户名

wall:给所有用户名发送信息
　　wall 要发送的信息

ping:测试网络连通性

　　ping ip地址 
　　-c 要ping的次数

ifconfig:
　　直接回车查看当前网卡信息
　　ifconfig 网卡名 ip地址 临时修改网络ip
　　　　ifconfig th0:0 192.168.1.100 netmask 255.255.255.0
　　　　　　给th0这个网卡新添加一个ip
　　　　ifconfig eth0:0 down
　　　　ifconfig eth0:0 up
ifdown th0
　　禁用th0这块网卡

ifup th0
　　开启th0这块网卡

mail:邮件命令
　　mail 要发送的用户名
　　mail 直接回车：查看命令
　　　　help :查看支持的命令格式
　　　　输入序列号：查看邮件详细内容
　　　　h: 回到邮件列表
　　　　d 序列号：删除序列号对应的邮件

last:统计计算机所有用户登录的时间信息，以及重启信息
lastlog:所有用户最后一次登录的时间
　　-u 用户的uid 查看指定用户的登录信息。

traceroute:显示数据包到主机间的路径
　　traceroute 要探测的地址.
　　-n 使用ip而不使用域名

nslookup www.baidu.com
　　查看百度的ip地址

netstat:显示网络相关信息
　　-t :tcp协议
　　-u :udp协议
　　-l:监听
　　-r:路由
　　-n:显示ip地址和端口号

　　netstat -tlun:查看本机监听的端口
　　netstat -an:查看所有的监听信息
　　netstat -rn ：查看路由表，即网管

wget 文件地址
　　下载文件

service network restart:重启网络服务。

telnet 域名或ip
　　远程管理与端口探测
　　如： telnet 192.168.2.3:80
　　　　探测192.168.2.3是否开启了80端口

mount:挂在命令
　　mount -t iso9660 /dev/sr0 /mnt/cdrom :把sr0挂在到cdrom

==============关机重启命令====================

shutdown:这个关机命令更安全一些，不推荐使用其他关机命令。
　　-h：关机
shutdown -h now shutdown -h 20:30
　　-r:重启 
shutdown -r now 
　　-c:取消上次的关机命令

重启：
　　init 6
　　reboot

关机：
　　init 0
　　poweroff

　　系统运行级别：
　　　　0 关机
　　　　1 单用户 类似windows安全模式
　　　　2 不完全多用户，不含nfs服务
　　　　3 完全多用户
　　　　4 未分配
　　　　5 图形界面
　　　　6 重启
　　可以通过查看/etc/inittab来查看系统启动的运行级别
　　runlevel:查看当前的运行级别
　　init n:设置系统运行级别

logout:退出当前用户，返回到登录界面



==============其他小技巧==========
\命令名字 :使用原始的命令
　　比如：
　　　　ls 实际上是ls --color auto
　　　　\ls 就是原始的ls


=============================================
一、软件包分类
　　源码包
　　　　脚本安装包
　　特点：
　　　　1. 开源
　　　　2. 可以自由选择所需的功能
　　　　3. 软件是编译安装，所以更加适合自己的系统，更加稳定也效率更高
　　　　4. 卸载方便，即可以直接删除文件夹。
　　缺点：
　　　　1. 安装过程步骤较多，尤其安装较大的软件集合时，容易出现错误
　　　　2. 编译时间较长，安装毕二进制安装时间长
　　　　3. 因为是编译安装，安装过程中一旦报错新手很难解决


　　二进制包(RPM包、系统默认包)
　　　　优点：
　　　　　　1. 包管理系统简单，只通过几个命令就可以实现包的安装、升级、查询和卸载
　　　　　　2. 安装速度比源码包安装快的多
　　　　缺点：
　　　　　　1. 经过编译，不再可以看到源代码
　　　　　　2. 功能选择不如源码包灵活
　　　　　　3. 依赖性

=============rpm命令管理-包命名与依赖性=======================================
1. RPM包命名原则
　　httpd-2.2.15-15.el6.centos.l.i686.rpm
　　　　httpd 软件包名
　　　　2.2.15 软件版本
　　　　15 软件发布的次数
　　　　el6.centos 适合的Linux平台
　　　　i686 适合的硬件平台
　　　　rpm rpm包扩展名
　　　　如果名字里有noarch,则表示所有平台都可以。

2、 rpm包依赖性
　　　　树形依赖： a-&gt;b-&gt;c 从后往前安装所依赖的包。
　　　　环形依赖： a-&gt;b-&gt;c-&gt;a 解决办法：一次性安装三个包
　　　　模块依赖：模块依赖查询网站 ：www.rpmfind.net 一般以.so.数字结尾的依赖包，是库依赖包，只需要安装包括这个库的软件就可以自动安装好这个所需的库依赖包

包全名：操作的包是没有安装的软件包时，使用包全名，而且要注意路径。安装、升级时用
包名 ：操作已经安装的软件包时，使用包名。是搜索/var/lib/rpm中的数据库。一般查询，卸载时用

3. rpm安装：
　　rpm-ivh 包全名
　　　　-i(install) 安装
　　　　-v(verbose) 显示详细信息
　　　　-h(hash) 显示进度
　　　　--nodeps 不检测依赖性 一般都必须要检测

4. rpm包升级：
　　rpm -Uvh 包全名
　　　　-U(upgrade) 升级
　　　　-h

5. rpm -e 包名
　　-e(erase) 卸载
　　--nodeps 不检查依赖性

6. 查询是否安装
　　rpm - q 包名 :查询包是否安装
　　　　-q(query) 查询
　　　　-a(all) 所有
　　　　-i(information) 查询软件信息
　　　　-p(package) 查询未安装包信息
　　rpm -ql 包名：查询包中文件安装位置(list) 注：包的安装路径在包生成的时候就确定了
　　rpm -qlp 包全名：查询未安装包安装时会安装在哪里。
　　rpm -qf 系统文件名 ：查询系统文件属于哪个rpm包 注：系统文件名必须是通过安装哪个包生成的文件
　　　　-f:查询系统文件属于哪个包
　　rpm -qR 包名 查询已安装软件包的依赖性
　　　　-r: 查询软件包的依赖性(requires)
　　rpm -qRp:查询未安装包的依赖性
　　　　-p: 查询未安装包的依赖性

　　　　例如：
　　　　　　rpm -qa | grep httpd 查询所有Apache的包

7. rpm包校验
　　rpm -V 已安装的包名 ：如果没有提示则表示没有被修改过
　　　　-V 校验指定rpm包中的文件(verify)
　　　　校验值的含义：
　　　　　　S:文件大小是否改变
　　　　　　M:文件的类型或文件的权限(rwx)是否被改变
　　　　　　5：文件MD5校验和是否改变(可以看成文件内容是否改变)
　　　　　　D:设备的中，从代码是否改变
　　　　　　L:文件路径是否改变
　　　　　　U:文件的属主(所有者)是否改变
　　　　　　G:文件的属组是否改变
　　　　　　T:文件的修改时间是否改变

8. rpm包中文件提取：
　　rpm2cpio 包全名 | \
　　cpio -div .文件绝对路径

　　rpm2cpio:讲rpm包转换为cpio格式的命令 
　　\表示命令没有输完,在下一行继续输入
　　cpio:是一个标准工具，它用于创建软件档案文件和从档案文件中提取文件
　　cpio 选项 &lt;[文件|设备]
　　　　-i copy-in模式，还原
　　　　-d:还原时自动新建目录
　　　　-v:显示还原过程

　　例如：
　　　　rpm -qf /bin/ls #查看ls命令属于哪个包
　　　　mv /bin/ls /tmp #将ls命令移走
　　　　rpm2cpio /mnt/cdrom/Packages/coreutils-8.4-19.el6.i686.rpm | cpio -idv ./bin/ls #提取rpm保重ls命令到当前目录的/bin/ls下
　　　　cp /root/bin/ls /bin/ #把ls命令复制到/bin/目录，修复文件丢失



yum在线管理：
一、 ip地址配置
第1步：setup:使用图形界面配置ip地址
第2步：vi/etc/sysconfig/network-scripts/ifcfg-eth0 把ONBOOT=&quot;no&quot;改为ONBOOT=&quot;yes&quot; #启动网卡
第3步：service network restart :重新启动网络服务。

二、网络yum源
1. yum源位置：/etc/yum.repos.d/CentOS-Base.repo,这个是默认的网络yum源
　　[base]    容器名称，一定要放在[]中
　　name  容器说明，可以自己随便写
　　mirrorlist    镜像站点，这个可以注释掉
　　baseurl   我们的yum源服务器的地址，默认是CentOS官方的yum源服务器，是可以使用的，如果你觉得慢可以改成你喜欢的yum源地址
　　enabled   此容器是否生效，如果不写或写成enable=1都是生效，写成enable=0就是不生效
　　gpgcheck  如果是1是指rpm的数字证书生效，如果是0则不生效
　　gpgkey    数字证书的公钥文件保存位置。不用修改。

2. yum命令
　　yum list :获取服务器上所有可用的软件的列表
　　yum search 关键字：搜索服务器上所有和关键字相关的包
　　yum -y install 包名：安装软件包
　　　　install:安装
　　　　-y:自动回答yes
　　yum -y update 包名：升级软件包
　　　　update:升级
　　　　-y:自动回答yes
　　　　如果没有包名，就会升级所有的软件包，包括Linux内核。慎用
　　yum -y remove 包名
　　　　remove:卸载
　　　　-y:自动回答yes
　　　　注：yum会自动卸载依赖包，而很有可能这个依赖包也被别的包依赖，所以很危险，慎用。

　　yum grouplist:列出所有可用的软件组列表
　　yum groupinstall 软件组名：安装指定软件组，组名可以由grouplist查询出来 注：如果查询出来的软件组名中间有空格，要使用&quot;&quot;引起来。
　　yum groupremove 软件组名：卸载指定软件组

3. 光盘yum源
　　1) 挂在光盘 mount /dev/sr0 /mnt/cdrom 
　　2) 让网络yum源文件失效
　　　　cd /etc/yum.repos.d/
　　　　mv CentOS-Base.repo CentOS-Base.repo.bak
　　　　mv CentOS-Debuginfo.repo CentOS-Debuginfo.repo.bak
　　　　mv Centos-Vault.repo Centos-Vault.repo.bak
　　3) 修改光盘yum源文件
　　　　vim CentOS-Media.repo
　　　　[c6-media]
　　　　name=CentOS-$releaserver -Media
　　　　baseurl=file:///mnt/cdrom 
　　　　#地址为你自己的光盘挂载地址
　　　　#   file:///media/cdrom/
　　　　#   file:///media/cdrecorder/
　　　　#注释这两个不存在的地址
　　　　gpgcheck=1
　　　　enabled=1 #把enabled=0改为enabled=1，让这个yum配置文件生效
　　　　gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6

　　　　注意：注释配置行的时候，#符号一定要写在开头，不要随便在配置文件某一行后面加注释，也不要随便加空格。

源码包管理
　　1. 区别
　　　　安装之前的区别：概念上的区别
　　　　安装之后的区别：安装位置不同

　　2. rpm包安装位置(大多数)
　　　　/etc/   配置文件安装目录
　　　　/usr/bin/   可执行的命令安装目录
　　　　/usr/lib/   程序所使用的函数库保存位置
　　　　/usr/share/doc  软件的基本使用书册保存位置
　　　　/usr/share/man/ 帮助文件保存位置    
　　3. 源码包安装位置
　　　　安装在指定位置当中，一般是
　　　　/usr/local/软件名/ 
　　4. 安装位置不同带来的影响
　　　　rpm包安装的服务可以使用系统服务管理命令(service)来管理
　　　　例如rpm包安装的Apache的启动方法是：
　　　　/etc/rc.d/init.d/httpd start 注：服务的安装路径一般在：/etc/rc.d/init.d下
　　　　service httpd start 注：service命令是红帽的专用命令,只能管理rpm包安装的服务
源码包安装过程
　　1. 安装准备
　　　　安装C语言编译器 gcc
　　　　下载源码包
　　　　http://mirror.bit.edu.cn/apach/httpd/   
　　2. 安装注意事项
　　　　源代码保存位置：/usr/local/src/
　　　　软件安装位置： /usr/local/
　　　　如何确定安装过程报错：
　　　　　　安装过程停止并出现error、warning或no的提示  
　　3. 源码包安装过程
　　　　1)下载源码包
　　　　2)解压缩下载的源码包
　　　　3)进入解压缩目录 注：里面有个INSTALL是系统安装的步骤说明
　　　　4)./configure 软件配置与检查
　　　　　　定义需要的功能选项
　　　　　　检测系统环境是否符合安装要求
　　　　　　把定义好的功能选项和检测系统环境的信息都写入Makefile文件，用于后续的编辑。
　　　　./configure --prefix=/usr/local/apache2 ：定义安装位置 
　　　　5)make :编译
　　　　　　如果前面有错误，则使用make clean命令清楚编译产生的临时文件
　　　　6)make install:编译安装
　　4. 源码包的卸载
　　　　不需要卸载命令，直接删除安装目录即可。不会遗留任何垃圾文件

脚本安装
　　1. 脚本安装包
　　　　脚本安装包并不是独立的软件包类型，常见安装的是源码包
　　　　是人为把安装过程写成了自动安装的脚本，只要执行脚本，定义简单的参数，就可以完成安装
　　　　非常类似于windows下软件的安装方式
　　2. Webmin的作用
　　　　Webmin是一个基于web的Linux系统管理界面，你就可以通过图形化的方式
　　　　设置用户账号、Apache，DNS、文件共享等服务。
　　3、 webmin安装过程
　　　　1) 下载软件
　　　　　　http;//sourceforge.net/projects/webadmin/files/webmin/
　　　　2) 解压缩，并进入解压缩目录
　　　　3) 执行安装脚本 ./setup.sh



其他命令

du -sh 文件名

ps 静态查看系统进程，系统默认安装
　　ps -aux 使用BSD语法查看所有进程
　　ps -ef 标准语法查看所有进程
　　　　UID 程序被该 UID 所拥有
　　　　PID 就是这个程序的 ID 
　　　　PPID 则是其上级父程序的ID
　　　　C CPU 使用的资源百分比
　　　　STIME 系统启动时间
　　　　TTY 登入者的终端机位置
　　　　TIME 使用掉的 CPU 时间。
　　　　CMD 所下达的指令为何
　　ps -aux --sort -pcpu,-pmem
　　　　根据CPU占用情况和内存占用情况来显示进程
　　watch -n 1 &apos;ps -aux --sort -pcpu,-pmem&apos;
　　　　每隔1秒监控一次进程情况

top 动态查看系统的状态

lsof -Pti :8000
　　通过端口号获得进程pid

kill -9 pid
　　杀死指定pid的进程，强行杀死。

history
　　查看历史命令

执行历史命令
　　!! 执行上一条命令
　　!n 执行历史命令的中第n条
　　!-n 执行导数第n条
　　!string 执行以string开头的历史命令行
　　!?string? 执行包含string的历史命令行


alias 
　　给命令起别名

　　alias 命令=&apos;别名&apos;
　　alias -p 查看已存在的别名

unlias 
　　取消别名
　　unlias name

cal 
　　查看某一年的日历，可以是1-9999中的任意一年
　　cal 88

zcat
　　查看压缩包中的内容

sed -i &apos;s#old#new#g&apos; 文件名
　　使用new替换文件中的old

ssh root@192.168.8.15 &quot;ifconfig&quot;
　　远程执行命令

bash -x 脚本名
　　调试脚本

centos6上的三个网络配置文件
　　/etc/sysconfig/network-scripts/ifcfg-etho
　　/etc/sysconfig/network
　　/etc/resolv.conf # dns</code></pre><blockquote>
<p>非原创，如有侵权请通知删除，便于查阅功能</p>
</blockquote>
<h1 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h1><pre><code>cd /
mkdir file
mkdir app

// 从官网下载压缩包,复制到file文件夹中

tar axvf /file/nginx-对应版本（tab补全即可） -C /app/

cd /app/nginx-对应版本（tab补全即可）

.configure
// 可显示配置后对应文件夹，一般在usr/local/nginx

make
make install

cd objs
./nginx -c /app/nginx-对应版本（tab补全即可）/conf/nginx.conf

此时生效的html文件夹为usr/local/nginx/html下的，用下拉vim命令修改nginx.conf文件</code></pre><h1 id="vim常见命令"><a href="#vim常见命令" class="headerlink" title="vim常见命令"></a>vim常见命令</h1><pre><code>vim nginx.conf

// 直接修改即可

esc退出到命令模式
:wq // 退出并保存
:w //保存
:q //退出</code></pre>]]></content>
      <categories>
        <category>linux</category>
        <category>常见操作</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>常见命令</tag>
        <tag>安装nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>.sync</title>
    <url>/2020/07/28/sync/</url>
    <content><![CDATA[<h1 id="sync修饰符"><a href="#sync修饰符" class="headerlink" title=".sync修饰符"></a>.sync修饰符</h1><blockquote>
<p>一个组件上只能定义一个v-model，如果其他prop也要实现双向绑定的效果该怎么办呢？ 简单的方法是子组件向父组件发送一个事件，父组件监听该事件，然后更新prop。具体如下：<br>// info.vue组件定义了一个value 属性， 和一个valueChanged事件</p>
</blockquote>
<pre><code>&lt;template&gt;
    &lt;div&gt;
        &lt;input @input=&quot;onInput&quot; :value=&quot;value&quot;/&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    props: {
        value: {
            type: String
        }
    },
    methods: {
        onInput(e) {
            this.$emit(&quot;valueChanged&quot;, e.target.value)
        }
    }
}
&lt;/script&gt;
父组件index.vue
&lt;template&gt;
    &lt;info :value=&quot;myValue&quot; @valueChanged=&quot;e =&gt; myValue = e&quot;&gt;&lt;/info&gt;
&lt;/template&gt;

&lt;script&gt;
    inport info from &apos;./info.vue&apos;;
    export default {
        components: {
            info,
        },
        data() {
            return {
                myValue: 1234,
            }
        },
    }
&lt;/script&gt;</code></pre><blockquote>
<p>上述写法太麻烦了，通过.sync可以简化上面代码，只需要修两个地方：</p>
</blockquote>
<ol>
<li>组件内触发的事件名称以“update:myPropName”命名，相应的上述info组件改为 update:value</li>
<li>父组件v-bind:value 加上.sync修饰符，即 v-bind:value.sync</li>
</ol>
<blockquote>
<p>这样父组件就不用再手动绑定@update:value事件了。</p>
</blockquote>
<h2 id="用法1-v-bind-prop-sync-”propvalue”"><a href="#用法1-v-bind-prop-sync-”propvalue”" class="headerlink" title="用法1: v-bind:prop.sync=”propvalue”"></a>用法1: v-bind:prop.sync=”propvalue”</h2><pre><code>// info.vue组件
...
methods: {
    onInput(e) {
        this.$emit(&quot;update:value&quot;, e.target.value)
    }
}
// index.vue组件
&lt;info :value.sync=&quot;myValue&quot;&gt;&lt;/info&gt;</code></pre><h2 id="用法2-v-bind-sync-”obj”"><a href="#用法2-v-bind-sync-”obj”" class="headerlink" title="用法2 v-bind.sync=”obj”"></a>用法2 v-bind.sync=”obj”</h2><blockquote>
<p>如果一个组件的多个prop都要实现双向绑定，根据上面学到的知识，只需要每个prop加sync修饰符</p>
</blockquote>
<pre><code>&lt;info :a.sync=&quot;value1&quot; :b.sync=&quot;value2&quot; :c.sync=&quot;value2&quot; :d.sync=&quot;value2&quot;&gt;&lt;/info&gt;</code></pre><blockquote>
<p>这样写太麻烦，vue提供了一种更简便的方法， v-bind.sync = “对象”</p>
</blockquote>
<pre><code>&lt;info v-bind.sync=&quot;obj&quot;&gt;&lt;/info&gt;
...
&lt;script&gt;
..
data() {
    obj: {a: &apos;&apos;, b: &apos;&apos;, c: &apos;&apos;, d: &apos;&apos;}
}
..
&lt;/script&gt;</code></pre><blockquote>
<p>注意：<br>带有.sync修饰符的v-bind不能喝表达式一起使用（例如 v-bind:title.sync = “doc.title + ‘!’”是无效的）。取而代之的是，你只能你想要绑定的属性名。<br>小结<br>一个组件需要提供多个双向绑定的属性时使用，只能选用一个属性来提供 v-model 功能，但如果有其他属性也要提供双向绑定，就需要.sync</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>ts</title>
    <url>/2020/07/28/ts/</url>
    <content><![CDATA[<h1 id="ts类型"><a href="#ts类型" class="headerlink" title="ts类型"></a>ts类型</h1><ul>
<li>number: 数字类型</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> n:<span class="built_in">number</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>string: 字符串类型</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> str:<span class="built_in">string</span> = <span class="string">"str"</span></span><br></pre></td></tr></table></figure>

<ul>
<li>array: 数组类型</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1:<span class="built_in">string</span>[] = [<span class="string">"arr1]</span></span><br><span class="line"><span class="string">let arr2:Array&lt;number&gt; =  ["</span>arr2]</span><br><span class="line"><span class="keyword">let</span> arr3:<span class="built_in">any</span>[] = [<span class="number">1</span>,<span class="string">"w"</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li>tuple: 元组类型</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> tuple:[<span class="built_in">string</span>,<span class="built_in">number</span>,<span class="built_in">boolean</span>]=[<span class="string">"str"</span>,<span class="number">1</span>,<span class="literal">false</span>]</span><br><span class="line"><span class="comment">//是数组类型的一种</span></span><br></pre></td></tr></table></figure>

<ul>
<li>enum: 枚举类型</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123; res,blue = <span class="number">5</span>,yellow&#125;</span><br><span class="line"><span class="keyword">let</span> red:Color = Color.red,blue:Color = Color.blue,yellow:Color = Color.yellow</span><br><span class="line"><span class="built_in">console</span>.log(red,blue,yellow,Color.red) <span class="comment">// 0,5,6,0</span></span><br><span class="line"><span class="comment">//默认打印索引值，有值时为对应值，后面无值时打印跟随前面的值+1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>any: 任意类型</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">any</span>:<span class="built_in">any</span> = <span class="number">1</span></span><br><span class="line"><span class="built_in">any</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment">// 可用来处理确定不了值，或者dom等对象</span></span><br></pre></td></tr></table></figure>

<ul>
<li>null,undefined</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> under:<span class="built_in">number</span> | <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// 用来初始不指定值不会出错</span></span><br><span class="line"><span class="keyword">let</span> <span class="literal">null</span>:<span class="built_in">number</span> | <span class="literal">null</span></span><br><span class="line"><span class="comment">// 用来值后来变为空后不会出错</span></span><br></pre></td></tr></table></figure>

<ul>
<li>void</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>):<span class="title">void</span></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"nothing"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 一般用来方法无返回值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>never</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ne:never=<span class="function">(<span class="params">(<span class="params"></span>)=&gt;&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="params">'fail'</span>)</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span>)<span class="params">()</span></span></span><br><span class="line"><span class="function">// 表示其他类型，<span class="params">null</span>,<span class="params">undefined</span>是其的子类型，表示从不会出现的值</span></span><br></pre></td></tr></table></figure>
<h1 id="ts函数"><a href="#ts函数" class="headerlink" title="ts函数"></a>ts函数</h1><h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">name:<span class="built_in">String</span>,age?:<span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log((name,age))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">name:<span class="built_in">String</span>,age:<span class="built_in">number</span>=20</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log((name,age))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">sum:<span class="built_in">number</span>,...result:<span class="built_in">number</span>[]</span>):<span class="title">number</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i:<span class="built_in">number</span> of result)</span><br><span class="line">        sum+=i</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line">run(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><blockquote>
<p>函数重载，主要用来检查类型，找到第一个匹配的类型传入</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">name:<span class="built_in">string</span></span>):<span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">age:<span class="built_in">number</span></span>):<span class="title">string</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params">str:<span class="built_in">any</span></span>):<span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> str === <span class="string">'number'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`我的年龄是<span class="subst">$&#123;str&#125;</span>`</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">`我的姓名是<span class="subst">$&#123;str&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(run(<span class="number">123</span>))</span><br></pre></td></tr></table></figure>
<h1 id="ts类"><a href="#ts类" class="headerlink" title="ts类"></a>ts类</h1><h2 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span>="张三"</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name=name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    run():<span class="built_in">void</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>在跑步`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2><blockquote>
<p>extends的方法</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span></span><br><span class="line">    <span class="keyword">protected</span> age: <span class="built_in">number</span> | <span class="literal">undefined</span></span><br><span class="line">    <span class="keyword">private</span> sex: <span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span> = "张三", age?: <span class="built_in">number</span>, sex?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">        <span class="keyword">this</span>.age = age</span><br><span class="line">        <span class="keyword">this</span>.sex = sex</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>在跑步`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getName(): <span class="built_in">string</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    setName(name: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">"李四"</span>)</span><br><span class="line">p.setName(<span class="string">"王二"</span>)</span><br><span class="line">p.run()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> newPerson <span class="keyword">extends</span> Person &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name?: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    run(): <span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>在跑步,子类`</span>)</span><br><span class="line">        <span class="comment">// super.run() // 父类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> n = <span class="keyword">new</span> newPerson()</span><br><span class="line">n.run()</span><br></pre></td></tr></table></figure>

<h2 id="类的修饰符"><a href="#类的修饰符" class="headerlink" title="类的修饰符"></a>类的修饰符</h2><p>// public 默认，类中，子类，类外部都可以访问<br>// protected 类中，子类可以访问，外部无法访问<br>// private 类型可以访问，子类，外部无法访问<br>// 其实都可以方案，不过在编译时会报错</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义同上</span></span><br><span class="line">p.name <span class="comment">//外部访问方法</span></span><br><span class="line">n.run()  <span class="comment">//子类访问方法</span></span><br></pre></td></tr></table></figure>
<h2 id="类里的静态属性和静态方法"><a href="#类里的静态属性和静态方法" class="headerlink" title="类里的静态属性和静态方法"></a>类里的静态属性和静态方法</h2><blockquote>
<p>所有对象共享</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person1 &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">type</span>: <span class="built_in">string</span> = <span class="string">"person"</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> getType():<span class="built_in">void</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(Person1.type)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person1.getType()</span><br><span class="line"><span class="built_in">console</span>.log(Person1.type, <span class="number">111</span>)</span><br></pre></td></tr></table></figure>
<h2 id="类里面的多态"><a href="#类里面的多态" class="headerlink" title="类里面的多态"></a>类里面的多态</h2><blockquote>
<p>即方法的重复实现</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal&#123;</span><br><span class="line">    <span class="keyword">type</span>:<span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">type</span>:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type=<span class="keyword">type</span></span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"不知道你需要吃什么"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Dog <span class="keyword">extends</span> Animal&#123;</span><br><span class="line">    eat() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"需要吃狗粮"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Cat <span class="keyword">extends</span> Animal&#123;</span><br><span class="line">    eat() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"需要吃猫粮"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> Cat(<span class="string">"张无忌"</span>).eat()</span><br></pre></td></tr></table></figure>
<h2 id="抽象类的抽象方法"><a href="#抽象类的抽象方法" class="headerlink" title="抽象类的抽象方法"></a>抽象类的抽象方法</h2><blockquote>
<p>抽象类不可以直接被实例化，抽象类的子类必须实现对应的抽象方法</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> Animal1 &#123;</span><br><span class="line">    <span class="keyword">type</span>: <span class="built_in">string</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">type</span>: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = <span class="keyword">type</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> eat(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="ts接口"><a href="#ts接口" class="headerlink" title="ts接口"></a>ts接口</h1><h2 id="属性接口"><a href="#属性接口" class="headerlink" title="属性接口"></a>属性接口</h2><h3 id="对json进行约束"><a href="#对json进行约束" class="headerlink" title="对json进行约束"></a>对json进行约束</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 必须一致</span></span><br><span class="line"><span class="keyword">interface</span> person&#123;</span><br><span class="line">    name:<span class="built_in">string</span>;</span><br><span class="line">    age:<span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可选属性，可传可不传</span></span><br><span class="line"><span class="keyword">interface</span> person&#123;</span><br><span class="line">    name:<span class="built_in">string</span>;</span><br><span class="line">    age:<span class="built_in">number</span>;</span><br><span class="line">    sex?:<span class="built_in">string</span>; <span class="comment">// 可选属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数类型接口"><a href="#函数类型接口" class="headerlink" title="函数类型接口"></a>函数类型接口</h3><blockquote>
<p>对函数传入的类型和返回的数值进行约束</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> encrypt &#123;</span><br><span class="line">    (name: <span class="built_in">string</span>, age: <span class="built_in">number</span>): <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> md5: encrypt = <span class="function"><span class="keyword">function</span> (<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name + age)</span><br><span class="line">    <span class="keyword">return</span> name+age</span><br><span class="line">&#125;</span><br><span class="line">md5(<span class="string">"张三"</span>, <span class="number">13</span>)</span><br></pre></td></tr></table></figure>

<h3 id="可索引的接口"><a href="#可索引的接口" class="headerlink" title="可索引的接口"></a>可索引的接口</h3><blockquote>
<p>个人觉得没什么用</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> arr &#123;</span><br><span class="line">    [index: <span class="built_in">number</span>]: <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> obj &#123;</span><br><span class="line">    [index: <span class="built_in">string</span>]: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr1: arr = [<span class="string">"123"</span>, <span class="number">456</span>]</span><br><span class="line"><span class="keyword">let</span> obj1: obj = &#123;name: <span class="string">"张三"</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr1, obj1)</span><br></pre></td></tr></table></figure>
<h3 id="类-类型的接口"><a href="#类-类型的接口" class="headerlink" title="类 类型的接口"></a>类 类型的接口</h3><blockquote>
<p>对类的约束</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> animal&#123;</span><br><span class="line">    name:<span class="built_in">string</span>,</span><br><span class="line">    eat(str:<span class="built_in">string</span>):<span class="built_in">void</span> <span class="comment">//函数必须实现，但是里面的参数可以不传</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> dog <span class="keyword">implements</span> animal&#123;</span><br><span class="line">    name:<span class="built_in">string</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name:<span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name</span><br><span class="line">&#125;</span><br><span class="line">eat()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name,<span class="string">"在吃饭"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接口的扩展，接口的继承"><a href="#接口的扩展，接口的继承" class="headerlink" title="接口的扩展，接口的继承"></a>接口的扩展，接口的继承</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    name:<span class="built_in">String</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> animal &#123;</span><br><span class="line">    name: <span class="built_in">string</span>,</span><br><span class="line"></span><br><span class="line">    eat(str: <span class="built_in">string</span>): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> person1 <span class="keyword">extends</span> animal &#123;</span><br><span class="line">    work(): <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> doctor <span class="keyword">extends</span> Person <span class="keyword">implements</span> person1 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    eat(str: <span class="built_in">string</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    work() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><blockquote>
<p>一些对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性:</p>
</blockquote>
<pre><code>interface Point {
    readonly x: number;
    readonly y: number;
}</code></pre><blockquote>
<p>你可以通过赋值一个对象字面量来构造一个Point。 赋值后， x和y再也不能被改变了。</p>
</blockquote>
<pre><code>let p1: Point = { x: 10, y: 20 };
p1.x = 5; // error!</code></pre><blockquote>
<p>TypeScript具有ReadonlyArray<T>类型，它与Array<T>相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改：</p>
</blockquote>
<pre><code>let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;
ro[0] = 12; // error!
ro.push(5); // error!
ro.length = 100; // error!
a = ro; // error!</code></pre><blockquote>
<p>上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 但是你可以用类型断言重写：</p>
</blockquote>
<pre><code>a = ro as number[];</code></pre><h3 id="readonly-vs-const"><a href="#readonly-vs-const" class="headerlink" title="readonly vs const"></a>readonly vs const</h3><blockquote>
<p>最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用const，若做为属性则使用readonly。</p>
</blockquote>
<h2 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h2><blockquote>
<p>我们在第一个例子里使用了接口，TypeScript让我们传入{ size: number; label: string; }到仅期望得到{ label: string; }的函数里。 我们已经学过了可选属性，并且知道他们在“option bags”模式里很有用。<br>然而，天真地将这两者结合的话就会像在JavaScript里那样搬起石头砸自己的脚。 比如，拿 createSquare例子来说：</p>
</blockquote>
<pre><code>interface SquareConfig {
    color?: string;
    width?: number;
}
function createSquare(config: SquareConfig): { color: string; area: number } {
    // ...
}
let mySquare = createSquare({ colour: &quot;red&quot;, width: 100 });</code></pre><blockquote>
<p>注意传入createSquare的参数拼写为colour而不是color。 在JavaScript里，这会默默地失败。<br>你可能会争辩这个程序已经正确地类型化了，因为width属性是兼容的，不存在color属性，而且额外的colour属性是无意义的。<br>然而，TypeScript会认为这段代码可能存在bug。 对象字面量会被特殊对待而且会经过 额外属性检查，当将它们赋值给变量或作为参数传递的时候。 如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</p>
</blockquote>
<pre><code>// error: &apos;colour&apos; not expected in type &apos;SquareConfig&apos;let mySquare = createSquare({ colour: &quot;red&quot;, width: 100 });</code></pre><blockquote>
<p>绕开这些检查非常简单。 最简便的方法是使用类型断言：</p>
</blockquote>
<pre><code>let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig);</code></pre><blockquote>
<p>然而，最佳的方式是能够添加一个字符串索引签名，前提是你能够确定这个对象可能具有某些做为特殊用途使用的额外属性。 如果 SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它：</p>
</blockquote>
<pre><code>interface SquareConfig {
    color?: string;
    width?: number;
    [propName: string]: any;
}</code></pre><blockquote>
<p>我们稍后会讲到索引签名，但在这我们要表示的是SquareConfig可以有任意数量的属性，并且只要它们不是color和width，那么就无所谓它们的类型是什么。<br>还有最后一种跳过这些检查的方式，这可能会让你感到惊讶，它就是将这个对象赋值给一个另一个变量： 因为squareOptions不会经过额外属性检查，所以编译器不会报错。</p>
</blockquote>
<pre><code>let squareOptions = { colour: &quot;red&quot;, width: 100 };let mySquare = createSquare(squareOptions);</code></pre><blockquote>
<p>要留意，在像上面一样的简单代码里，你可能不应该去绕开这些检查。 对于包含方法和内部状态的复杂对象字面量来讲，你可能需要使用这些技巧，但是大部额外属性检查错误是真正的bug。 就是说你遇到了额外类型检查出的错误，比如“option bags”，你应该去审查一下你的类型声明。 在这里，如果支持传入 color或colour属性到createSquare，你应该修改SquareConfig定义来体现出这一点。</p>
</blockquote>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><blockquote>
<p>接口能够描述JavaScript中对象拥有的各种各样的外形。 除了描述带有属性的普通对象外，接口也可以描述函数类型。<br>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。 它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p>
</blockquote>
<pre><code>interface SearchFunc {
  (source: string, subString: string): boolean;
}</code></pre><blockquote>
<p>这样定义后，我们可以像使用其它接口一样使用这个函数类型的接口。 下例展示了如何创建一个函数类型的变量，并将一个同类型的函数赋值给这个变量。</p>
</blockquote>
<pre><code>let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
  let result = source.search(subString);
  return result &gt; -1;
}</code></pre><blockquote>
<p>对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。 比如，我们使用下面的代码重写上面的例子：</p>
</blockquote>
<pre><code>let mySearch: SearchFunc;
mySearch = function(src: string, sub: string): boolean {
  let result = src.search(sub);
  return result &gt; -1;
}</code></pre><blockquote>
<p>函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 如果你不想指定类型，TypeScript的类型系统会推断出参数类型，因为函数直接赋值给了 SearchFunc类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与SearchFunc接口中的定义不匹配。</p>
</blockquote>
<pre><code>let mySearch: SearchFunc;
mySearch = function(src, sub) {
    let result = src.search(sub);
    return result &gt; -1;
}</code></pre><h2 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h2><blockquote>
<p>与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[“daniel”]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 让我们看一个例子：</p>
</blockquote>
<pre><code>interface StringArray {
  [index: number]: string;
}
let myArray: StringArray;
myArray = [&quot;Bob&quot;, &quot;Fred&quot;];
let myStr: string = myArray[0];</code></pre><blockquote>
<p>上面例子里，我们定义了StringArray接口，它具有索引签名。 这个索引签名表示了当用 number去索引StringArray时会得到string类型的返回值。<br>TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。 也就是说用 100（一个number）去索引等同于使用”100”（一个string）去索引，因此两者需要保持一致。</p>
</blockquote>
<pre><code>class Animal {
    name: string;
}class Dog extends Animal {
    breed: string;
}
// 错误：使用数值型的字符串索引，有时会得到完全不同的Animal!interface NotOkay {
    [x: number]: Animal;
    [x: string]: Dog;
}</code></pre><blockquote>
<p>字符串索引签名能够很好的描述dictionary模式，并且它们也会确保所有属性与其返回值类型相匹配。 因为字符串索引声明了 obj.property和obj[“property”]两种形式都可以。 下面的例子里， name的类型与字符串索引类型不匹配，所以类型检查器给出一个错误提示：</p>
</blockquote>
<pre><code>interface NumberDictionary {
  [index: string]: number;
  length: number;    // 可以，length是number类型
  name: string       // 错误，`name`的类型与索引类型返回值的类型不匹配
}</code></pre><blockquote>
<p>最后，你可以将索引签名设置为只读，这样就防止了给索引赋值：</p>
</blockquote>
<pre><code>interface ReadonlyStringArray {
    readonly [index: number]: string;
}let myArray: ReadonlyStringArray = [&quot;Alice&quot;, &quot;Bob&quot;];
myArray[2] = &quot;Mallory&quot;; // error!</code></pre><blockquote>
<p>你不能设置myArray[2]，因为索引签名是只读的。</p>
</blockquote>
<h2 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h2><h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><blockquote>
<p>与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约。</p>
</blockquote>
<pre><code> interface ClockInterface {
    currentTime: Date;
}
class Clock implements ClockInterface {
    currentTime: Date;
    constructor(h: number, m: number) { }
}</code></pre><blockquote>
<p>你也可以在接口中描述一个方法，在类里实现它，如同下面的setTime方法一样：</p>
</blockquote>
<pre><code>interface ClockInterface {
    currentTime: Date;
    setTime(d: Date);
}
class Clock implements ClockInterface {
    currentTime: Date;
    setTime(d: Date) {
        this.currentTime = d;
    }
    constructor(h: number, m: number) { }
}</code></pre><blockquote>
<p>接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。<br>类静态部分与实例部分的区别<br>当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 你会注意到，当你用构造器签名去定义一个接口并试图定义一个类去实现这个接口时会得到一个错误：</p>
</blockquote>
<pre><code>interface ClockConstructor {
    new (hour: number, minute: number);
}
class Clock implements ClockConstructor {
    currentTime: Date;
    constructor(h: number, m: number) { }
}</code></pre><blockquote>
<p>这里因为当一个类实现了一个接口时，只对其实例部分进行类型检查。 constructor存在于类的静态部分，所以不在检查的范围内。<br>因此，我们应该直接操作类的静态部分。 看下面的例子，我们定义了两个接口， ClockConstructor为构造函数所用和ClockInterface为实例方法所用。 为了方便我们定义一个构造函数 createClock，它用传入的类型创建实例。</p>
</blockquote>
<pre><code>interface ClockConstructor {
    new (hour: number, minute: number): ClockInterface;
}interface ClockInterface {
    tick();
}
function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface {
    return new ctor(hour, minute);
}
class DigitalClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log(&quot;beep beep&quot;);
    }
}class AnalogClock implements ClockInterface {
    constructor(h: number, m: number) { }
    tick() {
        console.log(&quot;tick tock&quot;);
    }
}
let digital = createClock(DigitalClock, 12, 17);let analog = createClock(AnalogClock, 7, 32);</code></pre><blockquote>
<p>因为createClock的第一个参数是ClockConstructor类型，在createClock(AnalogClock, 7, 32)里，会检查AnalogClock是否符合构造函数签名。</p>
</blockquote>
<h2 id="继承接口"><a href="#继承接口" class="headerlink" title="继承接口"></a>继承接口</h2><blockquote>
<p>和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。</p>
</blockquote>
<pre><code>interface Shape {
    color: string;
}
interface Square extends Shape {
    sideLength: number;
}
let square = &lt;Square&gt;{};
square.color = &quot;blue&quot;;
square.sideLength = 10;</code></pre><blockquote>
<p>一个接口可以继承多个接口，创建出多个接口的合成接口。</p>
</blockquote>
<pre><code>interface Shape {
    color: string;
}
interface PenStroke {
    penWidth: number;
}
interface Square extends Shape, PenStroke {
    sideLength: number;
}
let square = &lt;Square&gt;{};
square.color = &quot;blue&quot;;
square.sideLength = 10;
square.penWidth = 5.0;</code></pre><h2 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h2><blockquote>
<p>先前我们提过，接口能够描述JavaScript里丰富的类型。 因为JavaScript其动态灵活的特点，有时你会希望一个对象可以同时具有上面提到的多种类型。<br>一个例子就是，一个对象可以同时做为函数和对象使用，并带有额外的属性。</p>
</blockquote>
<pre><code>interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}
function getCounter(): Counter {
    let counter = &lt;Counter&gt;function (start: number) { };
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}
let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;</code></pre><blockquote>
<p>在使用JavaScript第三方库的时候，你可能需要像上面那样去完整地定义类型。</p>
</blockquote>
<h2 id="接口继承类"><a href="#接口继承类" class="headerlink" title="接口继承类"></a>接口继承类</h2><blockquote>
<p>当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。<br>当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。 例：</p>
</blockquote>
<pre><code>class Control {
    private state: any;
}
interface SelectableControl extends Control {
    select(): void;
}
class Button extends Control implements SelectableControl {
    select() { }
}
class TextBox extends Control {
    select() { }
}
// 错误：“Image”类型缺少“state”属性。class Image implements SelectableControl {
    select() { }
}
class Location {

}</code></pre><blockquote>
<p>在上面的例子里，SelectableControl包含了Control的所有成员，包括私有成员state。 因为 state是私有成员，所以只能够是Control的子类们才能实现SelectableControl接口。 因为只有 Control的子类才能够拥有一个声明于Control的私有成员state，这对私有成员的兼容性是必需的。<br>在Control类内部，是允许通过SelectableControl的实例来访问私有成员state的。 实际上，SelectableControl接口和拥有select方法的Control类是一样的。 Button和TextBox类是SelectableControl的子类（因为它们都继承自Control并有select方法），但Image和Location类并不是这样的。</p>
</blockquote>
<h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><blockquote>
<p>在一些函数的类型，不仅支持当前的类型，实现类型的扩展,实现了any实现不了的指定类型校验</p>
</blockquote>
<h2 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">return_self</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return_self&lt;<span class="built_in">number</span>&gt;(<span class="number">1111</span>)</span><br><span class="line">return_self&lt;<span class="built_in">string</span>&gt;(<span class="string">"1111"</span>)</span><br></pre></td></tr></table></figure>


<h2 id="类的泛型"><a href="#类的泛型" class="headerlink" title="类的泛型"></a>类的泛型</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> min_class&lt;T,R&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> list: T[] = []</span><br><span class="line"></span><br><span class="line">    add(value: T): T &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> min = <span class="keyword">new</span> min_class&lt;<span class="built_in">number</span>,<span class="built_in">string</span>&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> list: (<span class="built_in">number</span> | <span class="built_in">string</span>)[] = [<span class="number">12</span>, <span class="string">"12"</span>]</span><br></pre></td></tr></table></figure>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><h3 id="函数接口泛型"><a href="#函数接口泛型" class="headerlink" title="函数接口泛型"></a>函数接口泛型</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> classT &#123;</span><br><span class="line">    &lt;T&gt;(str: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ab: classT = <span class="function"><span class="keyword">function</span> &lt;<span class="title">T</span>&gt;(<span class="params">str: T</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ab&lt;<span class="built_in">number</span>&gt;(<span class="number">123</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> classTT&lt;T&gt; &#123;</span><br><span class="line">    (str: T): T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get_any</span>&lt;<span class="title">T</span>&gt;(<span class="params">str: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">any</span>: classTT&lt;<span class="built_in">number</span>&gt; = get_any</span><br><span class="line"><span class="built_in">any</span>(<span class="number">123</span>)</span><br></pre></td></tr></table></figure>
<h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><blockquote>
<p>反正变量名冲突，在外部使用需要使用export<br>可以理解为小模块</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="keyword">interface</span> Animal &#123;</span><br><span class="line">        name: <span class="built_in">String</span>,</span><br><span class="line">        eat(): <span class="built_in">void</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> Dog <span class="keyword">implements</span> Animal &#123;</span><br><span class="line">        name: <span class="built_in">String</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        eat(): <span class="built_in">void</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.name, <span class="string">"在吃东西"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">class</span> black_dog <span class="keyword">extends</span> Dog &#123;</span><br><span class="line">        sex: <span class="built_in">String</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">constructor</span>(<span class="params">sex: <span class="built_in">string</span>, name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">            <span class="keyword">super</span>(name);</span><br><span class="line">            <span class="keyword">this</span>.sex = sex</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> black_dog = <span class="keyword">new</span> A.black_dog(<span class="string">"gon"</span>, <span class="string">"小黑"</span>)</span><br></pre></td></tr></table></figure>

<h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><blockquote>
<p>是一种特殊类型的声明，它能够被附加的类声明，方法，属性或参数上，可以修改类的行为</p>
</blockquote>
<blockquote>
<p>通俗的讲，装饰器就是一个方法，可以注入到类，方法，属性参数上来扩展，属性，方法，参数的功能</p>
</blockquote>
<blockquote>
<p>常见的装饰器有：类装饰器，属性装饰器，方法装饰器，参数装饰器</p>
</blockquote>
<blockquote>
<p>装饰器的写法：普通装饰器（无法传参），装饰器工厂（可传参）</p>
</blockquote>
<blockquote>
<p>属性&gt;方法&gt;方法参数&gt;类，同种类的先下后上，先后后前</p>
</blockquote>
<h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><blockquote>
<p>类装饰器在类声明之前被声明，类装饰器应用于类构造函数，可以用来监视，修改或者替换类定义</p>
</blockquote>
<h3 id="普通装饰器"><a href="#普通装饰器" class="headerlink" title="普通装饰器"></a>普通装饰器</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructor_1</span>(<span class="params">params: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(params)</span><br><span class="line">    params.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"我是类中的方法"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// return class extends params &#123;  /*此方法可重载类*/</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@constructor_1</span></span><br><span class="line"><span class="keyword">class</span> constructor_animal&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> people_2:<span class="built_in">any</span>=<span class="keyword">new</span> constructor_animal()</span><br><span class="line">people_2.eat()</span><br></pre></td></tr></table></figure>

<h3 id="装饰器工厂"><a href="#装饰器工厂" class="headerlink" title="装饰器工厂"></a>装饰器工厂</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructor_2</span>(<span class="params">params: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(params, target)</span><br><span class="line">    target.prototype.eat=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"我是类中的方法"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@constructor_2</span>(<span class="string">"这是传入的参数"</span>)</span><br><span class="line"><span class="keyword">class</span> constructor_people &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> people_3:<span class="built_in">any</span>=<span class="keyword">new</span> constructor_people()</span><br><span class="line">people_3.eat()</span><br></pre></td></tr></table></figure>


<h2 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h2><blockquote>
<p>接受两个参数 </p>
<blockquote>
<p>1：对于静态成员来说是类的构造函数，对于实例成员来说是累的成员对象<br>2:成员的名字</p>
</blockquote>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">http_log</span>(<span class="params">params:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target:<span class="built_in">any</span>,attr:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(params,target,attr)</span><br><span class="line">        target[attr]=params</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> http_client&#123;</span><br><span class="line">    <span class="meta">@http_log</span>(<span class="string">"blog.dingyahui.top"</span>)</span><br><span class="line">    <span class="keyword">public</span> url:<span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">    <span class="meta">@http_log</span>(<span class="string">"http"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">type</span>:<span class="built_in">string</span> | <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> new_url = <span class="keyword">new</span> http_client()</span><br><span class="line"><span class="built_in">console</span>.log(new_url.url)</span><br></pre></td></tr></table></figure>


<h2 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h2><blockquote>
<p>它会被应用到方法的属性描述符上，可以用来监视，修改或者替换方法定义<br>参数：</p>
<blockquote>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象</li>
<li>成员的名字</li>
<li>成员的属性描述符</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logMethod</span>(<span class="params">params:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target:<span class="built_in">any</span>,name:<span class="built_in">string</span>,desc:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(params,target,name,desc)</span><br><span class="line">        <span class="keyword">let</span> method = desc.value</span><br><span class="line">        desc.value=<span class="function"><span class="keyword">function</span> (<span class="params">params:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"这方法什么都不是的修改版"</span>)</span><br><span class="line">        method.call(<span class="keyword">this</span>,params) <span class="comment">//加上这句可以执行函数原来的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> httpMethod&#123;</span><br><span class="line">    <span class="meta">@logMethod</span>(<span class="string">"这个是方法"</span>)</span><br><span class="line">    log(params:<span class="built_in">string</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"这方法什么都不是"</span>,params)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> new_method = <span class="keyword">new</span> httpMethod()</span><br><span class="line">new_method.log(<span class="string">"方法"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="方法参数装饰器"><a href="#方法参数装饰器" class="headerlink" title="方法参数装饰器"></a>方法参数装饰器</h2><blockquote>
<p>在运行时当做函数被调用，可以使用参数装饰器为类的原型增加一些元素数据<br>参数：</p>
<blockquote>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象</li>
<li>方法的名字</li>
<li>参数在参数列表的中的索引</li>
</ol>
</blockquote>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logParams</span>(<span class="params">params:<span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target:<span class="built_in">any</span>,name:<span class="built_in">string</span>,index:<span class="built_in">any</span></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(params,target,name,index,<span class="string">"------params"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> httpParams&#123;</span><br><span class="line">    log(<span class="meta">@logParams</span>(<span class="string">"这个是参数"</span>) params:<span class="built_in">string</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"这参数什么都不是"</span>,params)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> new_Params = <span class="keyword">new</span> httpParams()</span><br><span class="line">new_Params.log(<span class="string">"参数"</span>)</span><br></pre></td></tr></table></figure>


<h1 id="Utility-Types"><a href="#Utility-Types" class="headerlink" title="Utility Types"></a>Utility Types</h1><h2 id="Partial"><a href="#Partial" class="headerlink" title="Partial"></a>Partial<Type></h2><blockquote>
<p>构造具有以下所有属性的类型：Type设置为可选。此实用程序将返回表示给定类型的所有子集的类型。</p>
</blockquote>
<blockquote>
<p>使对应的属性变为可选</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  description: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateTodo</span>(<span class="params">todo: Todo, fieldsToUpdate: Partial&lt;Todo&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...todo, ...fieldsToUpdate &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo1 = &#123;</span><br><span class="line">  title: <span class="string">"organize desk"</span>,</span><br><span class="line">  description: <span class="string">"clear clutter"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo2 = updateTodo(todo1, &#123;</span><br><span class="line">  description: <span class="string">"throw out trash"</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Required"><a href="#Required" class="headerlink" title="Required"></a>Required<Type></h2><blockquote>
<p>Type设置为必需。相反的Partial.</p>
</blockquote>
<blockquote>
<p>使属性变为必须</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Props &#123;</span><br><span class="line">  a?: <span class="built_in">number</span>;</span><br><span class="line">  b?: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj: Props = &#123; a: <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj2: Required&lt;Props&gt; = &#123; a: <span class="number">5</span> &#125;;</span><br><span class="line">Property <span class="string">'b'</span> is missing <span class="keyword">in</span> <span class="keyword">type</span> <span class="string">'&#123; a: number; &#125;'</span> but required <span class="keyword">in</span> <span class="keyword">type</span> <span class="string">'Required&lt;Props&gt;'</span>.</span><br></pre></td></tr></table></figure>

<h2 id="Readonly"><a href="#Readonly" class="headerlink" title="Readonly"></a>Readonly<Type></h2><blockquote>
<p>构造具有以下所有属性的类型：Type设为readonly，这意味着不能重新分配构造类型的属性。</p>
</blockquote>
<blockquote>
<p>使属性变为只读，类似于Object.freeze()</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo: Readonly&lt;Todo&gt; = &#123;</span><br><span class="line">  title: <span class="string">"Delete inactive users"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">todo.title = <span class="string">"Hello"</span>;</span><br><span class="line">Cannot assign to <span class="string">'title'</span> because it is a read-only property.</span><br></pre></td></tr></table></figure>

<h2 id="Record-lt-Keys-Type-gt"><a href="#Record-lt-Keys-Type-gt" class="headerlink" title="Record&lt;Keys,Type&gt;"></a>Record&lt;Keys,Type&gt;</h2><blockquote>
<p>构造一个对象类型，其属性键为Keys其属性值为Type。此实用程序可用于将类型的属性映射到另一类型。</p>
</blockquote>
<blockquote>
<p>限制对象的键值和属性</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> CatInfo &#123;</span><br><span class="line">  age: <span class="built_in">number</span>;</span><br><span class="line">  breed: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CatName = <span class="string">"miffy"</span> | <span class="string">"boris"</span> | <span class="string">"mordred"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cats: Record&lt;CatName, CatInfo&gt; = &#123;</span><br><span class="line">  miffy: &#123; age: <span class="number">10</span>, breed: <span class="string">"Persian"</span> &#125;,</span><br><span class="line">  boris: &#123; age: <span class="number">5</span>, breed: <span class="string">"Maine Coon"</span> &#125;,</span><br><span class="line">  mordred: &#123; age: <span class="number">16</span>, breed: <span class="string">"British Shorthair"</span> &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cats.boris;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> cats: Record&lt;CatName, CatInfo&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Pick-lt-Type-Keys-gt"><a href="#Pick-lt-Type-Keys-gt" class="headerlink" title="Pick&lt;Type, Keys&gt;"></a>Pick&lt;Type, Keys&gt;</h2><blockquote>
<p>通过选择属性集来构造类型。Keys(字符串文字或字符串文字的联合)Type.</p>
</blockquote>
<blockquote>
<p>相当于值使用对应的联合字符串的属性</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  description: <span class="built_in">string</span>;</span><br><span class="line">  completed: <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TodoPreview = Pick&lt;Todo, <span class="string">"title"</span> | <span class="string">"completed"</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo: TodoPreview = &#123;</span><br><span class="line">  title: <span class="string">"Clean room"</span>,</span><br><span class="line">  completed: <span class="literal">false</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">todo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> todo: TodoPreview</span><br></pre></td></tr></table></figure>

<h2 id="Omit-lt-Type-Keys-gt"><a href="#Omit-lt-Type-Keys-gt" class="headerlink" title="Omit&lt;Type, Keys&gt;"></a>Omit&lt;Type, Keys&gt;</h2><blockquote>
<p>通过从Type然后移除Keys(字符串文字或字符串文字的联合)。</p>
</blockquote>
<blockquote>
<p>派出对应字符串联合的键值，返回属性</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> Todo &#123;</span><br><span class="line">  title: <span class="built_in">string</span>;</span><br><span class="line">  description: <span class="built_in">string</span>;</span><br><span class="line">  completed: <span class="built_in">boolean</span>;</span><br><span class="line">  createdAt: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TodoPreview = Omit&lt;Todo, <span class="string">"description"</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todo: TodoPreview = &#123;</span><br><span class="line">  title: <span class="string">"Clean room"</span>,</span><br><span class="line">  completed: <span class="literal">false</span>,</span><br><span class="line">  createdAt: <span class="number">1615544252770</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">todo;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> todo: TodoPreview</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TodoInfo = Omit&lt;Todo, <span class="string">"completed"</span> | <span class="string">"createdAt"</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> todoInfo: TodoInfo = &#123;</span><br><span class="line">  title: <span class="string">"Pick up kids"</span>,</span><br><span class="line">  description: <span class="string">"Kindergarten closes at 5pm"</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">todoInfo;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">const</span> todoInfo: TodoInfo</span><br></pre></td></tr></table></figure>

<h2 id="Exclude-lt-Type-ExcludedUnion-gt"><a href="#Exclude-lt-Type-ExcludedUnion-gt" class="headerlink" title="Exclude&lt;Type, ExcludedUnion&gt;"></a>Exclude&lt;Type, ExcludedUnion&gt;</h2><blockquote>
<p>通过排除Type所有可指派给ExcludedUnion.</p>
</blockquote>
<blockquote>
<p>派出type中一些可能的属性,返回属性</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T0 = Exclude&lt;<span class="string">"a"</span> | <span class="string">"b"</span> | <span class="string">"c"</span>, <span class="string">"a"</span>&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T0 = <span class="string">"b"</span> | <span class="string">"c"</span></span><br><span class="line"><span class="keyword">type</span> T1 = Exclude&lt;<span class="string">"a"</span> | <span class="string">"b"</span> | <span class="string">"c"</span>, <span class="string">"a"</span> | <span class="string">"b"</span>&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T1 = <span class="string">"c"</span></span><br><span class="line"><span class="keyword">type</span> T2 = Exclude&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="function">(<span class="params">(<span class="params"></span>) =&gt; <span class="built_in">void</span></span>), <span class="params">Function</span>&gt;;</span></span><br><span class="line"><span class="function">     </span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">T2</span> = <span class="params">string</span> | <span class="params">number</span></span></span><br></pre></td></tr></table></figure>

<h2 id="Extract-lt-Type-Union-gt"><a href="#Extract-lt-Type-Union-gt" class="headerlink" title="Extract&lt;Type, Union&gt;"></a>Extract&lt;Type, Union&gt;</h2><blockquote>
<p>通过从Type所有可指派给Union.</p>
</blockquote>
<blockquote>
<p>返回共同可能的类型，返回类型</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T0 = Extract&lt;<span class="string">"a"</span> | <span class="string">"b"</span> | <span class="string">"c"</span>, <span class="string">"a"</span> | <span class="string">"f"</span>&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T0 = <span class="string">"a"</span></span><br><span class="line"><span class="keyword">type</span> T1 = Extract&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="function">(<span class="params">(<span class="params"></span>) =&gt; <span class="built_in">void</span></span>), <span class="params">Function</span>&gt;;</span></span><br><span class="line"><span class="function">     </span></span><br><span class="line"><span class="function"><span class="params">type</span> <span class="params">T1</span> = <span class="params">()</span> =&gt;</span> <span class="built_in">void</span></span><br></pre></td></tr></table></figure>

<h2 id="NonNullable"><a href="#NonNullable" class="headerlink" title="NonNullable"></a>NonNullable<Type></h2><blockquote>
<p>通过排除构造类型null和undefined从…Type.</p>
</blockquote>
<blockquote>
<p>去除其中的null 和 underfined属性</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T0 = NonNullable&lt;<span class="built_in">string</span> | <span class="built_in">number</span> | <span class="literal">undefined</span>&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T0 = <span class="built_in">string</span> | <span class="built_in">number</span></span><br><span class="line"><span class="keyword">type</span> T1 = NonNullable&lt;<span class="built_in">string</span>[] | <span class="literal">null</span> | <span class="literal">undefined</span>&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T1 = <span class="built_in">string</span>[]</span><br></pre></td></tr></table></figure>

<h2 id="Parameters"><a href="#Parameters" class="headerlink" title="Parameters"></a>Parameters<Type></h2><blockquote>
<p>从函数类型的参数中使用的类型构造元组类型。Type.</p>
</blockquote>
<blockquote>
<p>通过函数的参数生成对应的元组类型</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">arg: &#123; a: <span class="built_in">number</span>; b: <span class="built_in">string</span> &#125;</span>): <span class="title">void</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T0 = Parameters&lt;<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">string</span>&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T0 = []</span><br><span class="line"><span class="keyword">type</span> T1 = Parameters&lt;<span class="function">(<span class="params">s: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T1 = [s: <span class="built_in">string</span>]</span><br><span class="line"><span class="keyword">type</span> T2 = Parameters&lt;&lt;T&gt;<span class="function">(<span class="params">arg: T</span>) =&gt;</span> T&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T2 = [arg: unknown]</span><br><span class="line"><span class="keyword">type</span> T3 = Parameters&lt;<span class="keyword">typeof</span> f1&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T3 = [arg: &#123;</span><br><span class="line">    a: <span class="built_in">number</span>;</span><br><span class="line">    b: <span class="built_in">string</span>;</span><br><span class="line">&#125;]</span><br><span class="line"><span class="keyword">type</span> T4 = Parameters&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T4 = unknown[]</span><br><span class="line"><span class="keyword">type</span> T5 = Parameters&lt;never&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T5 = never</span><br><span class="line"><span class="keyword">type</span> T6 = Parameters&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">Type <span class="string">'string'</span> does not satisfy the constraint <span class="string">'(...args: any) =&gt; any'</span>.</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T6 = never</span><br><span class="line"><span class="keyword">type</span> T7 = Parameters&lt;<span class="built_in">Function</span>&gt;;</span><br><span class="line">Type <span class="string">'Function'</span> does not satisfy the constraint <span class="string">'(...args: any) =&gt; any'</span>.</span><br><span class="line">  Type <span class="string">'Function'</span> provides no match <span class="keyword">for</span> the signature <span class="string">'(...args: any): any'</span>.</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T7 = never</span><br></pre></td></tr></table></figure>

<h2 id="ConstructorParameters"><a href="#ConstructorParameters" class="headerlink" title="ConstructorParameters"></a>ConstructorParameters<Type></h2><blockquote>
<p>从构造函数类型的类型构造元组或数组类型。它生成包含所有参数类型(或类型)的元组类型。never如果Type不是一种功能)。</p>
</blockquote>
<blockquote>
<p>从构造函数的类型生成元组或数组类型</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> T0 = ConstructorParameters&lt;ErrorConstructor&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T0 = [message?: <span class="built_in">string</span>]</span><br><span class="line"><span class="keyword">type</span> T1 = ConstructorParameters&lt;FunctionConstructor&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T1 = <span class="built_in">string</span>[]</span><br><span class="line"><span class="keyword">type</span> T2 = ConstructorParameters&lt;RegExpConstructor&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T2 = [pattern: <span class="built_in">string</span> | <span class="built_in">RegExp</span>, flags?: <span class="built_in">string</span>]</span><br><span class="line"><span class="keyword">type</span> T3 = ConstructorParameters&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T3 = unknown[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T4 = ConstructorParameters&lt;<span class="built_in">Function</span>&gt;;</span><br><span class="line">Type <span class="string">'Function'</span> does not satisfy the constraint <span class="string">'abstract new (...args: any) =&gt; any'</span>.</span><br><span class="line">  Type <span class="string">'Function'</span> provides no match <span class="keyword">for</span> the signature <span class="string">'new (...args: any): any'</span>.</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T4 = never</span><br></pre></td></tr></table></figure>

<h2 id="ReturnType"><a href="#ReturnType" class="headerlink" title="ReturnType"></a>ReturnType<Type></h2><blockquote>
<p>构造由函数的返回类型组成的类型。Type.</p>
</blockquote>
<blockquote>
<p>根据函数的返回类型生成类型</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>): </span>&#123; a: <span class="built_in">number</span>; b: <span class="built_in">string</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T0 = ReturnType&lt;<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">string</span>&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T0 = <span class="built_in">string</span></span><br><span class="line"><span class="keyword">type</span> T1 = ReturnType&lt;<span class="function">(<span class="params">s: <span class="built_in">string</span></span>) =&gt;</span> <span class="built_in">void</span>&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T1 = <span class="built_in">void</span></span><br><span class="line"><span class="keyword">type</span> T2 = ReturnType&lt;&lt;T&gt;<span class="function"><span class="params">()</span> =&gt;</span> T&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T2 = unknown</span><br><span class="line"><span class="keyword">type</span> T3 = ReturnType&lt;&lt;T <span class="keyword">extends</span> U, U <span class="keyword">extends</span> <span class="built_in">number</span>[]&gt;<span class="function"><span class="params">()</span> =&gt;</span> T&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T3 = <span class="built_in">number</span>[]</span><br><span class="line"><span class="keyword">type</span> T4 = ReturnType&lt;<span class="keyword">typeof</span> f1&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T4 = &#123;</span><br><span class="line">    a: <span class="built_in">number</span>;</span><br><span class="line">    b: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> T5 = ReturnType&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T5 = <span class="built_in">any</span></span><br><span class="line"><span class="keyword">type</span> T6 = ReturnType&lt;never&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T6 = never</span><br><span class="line"><span class="keyword">type</span> T7 = ReturnType&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">Type <span class="string">'string'</span> does not satisfy the constraint <span class="string">'(...args: any) =&gt; any'</span>.</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T7 = <span class="built_in">any</span></span><br><span class="line"><span class="keyword">type</span> T8 = ReturnType&lt;<span class="built_in">Function</span>&gt;;</span><br><span class="line">Type <span class="string">'Function'</span> does not satisfy the constraint <span class="string">'(...args: any) =&gt; any'</span>.</span><br><span class="line">  Type <span class="string">'Function'</span> provides no match <span class="keyword">for</span> the signature <span class="string">'(...args: any): any'</span>.</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T8 = <span class="built_in">any</span></span><br></pre></td></tr></table></figure>

<h2 id="InstanceType"><a href="#InstanceType" class="headerlink" title="InstanceType"></a>InstanceType<Type></h2><blockquote>
<p>构造函数的实例类型构成的类型。Type.</p>
</blockquote>
<blockquote>
<p>根据对应的实力类型生成类型、</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> C &#123;</span><br><span class="line">  x = <span class="number">0</span>;</span><br><span class="line">  y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> T0 = InstanceType&lt;<span class="keyword">typeof</span> C&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T0 = C</span><br><span class="line"><span class="keyword">type</span> T1 = InstanceType&lt;<span class="built_in">any</span>&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T1 = <span class="built_in">any</span></span><br><span class="line"><span class="keyword">type</span> T2 = InstanceType&lt;never&gt;;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T2 = never</span><br><span class="line"><span class="keyword">type</span> T3 = InstanceType&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">Type <span class="string">'string'</span> does not satisfy the constraint <span class="string">'abstract new (...args: any) =&gt; any'</span>.</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T3 = <span class="built_in">any</span></span><br><span class="line"><span class="keyword">type</span> T4 = InstanceType&lt;<span class="built_in">Function</span>&gt;;</span><br><span class="line">Type <span class="string">'Function'</span> does not satisfy the constraint <span class="string">'abstract new (...args: any) =&gt; any'</span>.</span><br><span class="line">  Type <span class="string">'Function'</span> provides no match <span class="keyword">for</span> the signature <span class="string">'new (...args: any): any'</span>.</span><br><span class="line">     </span><br><span class="line"><span class="keyword">type</span> T4 = <span class="built_in">any</span></span><br></pre></td></tr></table></figure>

<h2 id="ThisParameterType"><a href="#ThisParameterType" class="headerlink" title="ThisParameterType"></a>ThisParameterType<Type></h2><blockquote>
<p>类的类型。这函数类型的参数，或未知数如果函数类型没有this参数。</p>
</blockquote>
<blockquote>
<p>根据对应函数的类型返回t对应参数的类型</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toHex</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">Number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">numberToString</span>(<span class="params">n: ThisParameterType&lt;<span class="keyword">typeof</span> toHex&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> toHex.apply(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="OmitThisParameter"><a href="#OmitThisParameter" class="headerlink" title="OmitThisParameter"></a>OmitThisParameter<Type></h2><blockquote>
<p>移除this参数来自Type。如果Type没有显式声明this参数，则结果是Type。否则，使用no的新函数类型。this参数是从Type。泛型被删除，并且只有最后一个重载签名被传播到新的函数类型中。</p>
</blockquote>
<blockquote>
<p>相当于一个更改执行的类型，如bind</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toHex</span>(<span class="params"><span class="keyword">this</span>: <span class="built_in">Number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.toString(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fiveToHex: OmitThisParameter&lt;<span class="keyword">typeof</span> toHex&gt; = toHex.bind(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(fiveToHex());</span><br></pre></td></tr></table></figure>

<h2 id="ThisType"><a href="#ThisType" class="headerlink" title="ThisType"></a>ThisType<Type></h2><blockquote>
<p>此实用程序不返回转换的类型。相反，它是上下文的标记。this类型。注意，–noImplicitThis必须启用标志才能使用此实用程序。</p>
</blockquote>
<blockquote>
<p>声明了对应的this的包含的参数类型</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ObjectDescriptor&lt;D, M&gt; = &#123;</span><br><span class="line">  data?: D;</span><br><span class="line">  methods?: M &amp; ThisType&lt;D &amp; M&gt;; <span class="comment">// Type of 'this' in methods is D &amp; M</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeObject</span>&lt;<span class="title">D</span>, <span class="title">M</span>&gt;(<span class="params">desc: ObjectDescriptor&lt;D, M&gt;</span>): <span class="title">D</span> &amp; <span class="title">M</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data: object = desc.data || &#123;&#125;;</span><br><span class="line">  <span class="keyword">let</span> methods: object = desc.methods || &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123; ...data, ...methods &#125; <span class="keyword">as</span> D &amp; M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = makeObject(&#123;</span><br><span class="line">  data: &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    moveBy(dx: <span class="built_in">number</span>, dy: <span class="built_in">number</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.x += dx; <span class="comment">// Strongly typed this</span></span><br><span class="line">      <span class="keyword">this</span>.y += dy; <span class="comment">// Strongly typed this</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.x = <span class="number">10</span>;</span><br><span class="line">obj.y = <span class="number">20</span>;</span><br><span class="line">obj.moveBy(<span class="number">5</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，methods对象的参数中的makeObject具有上下文类型，其中包括ThisType&lt;D &amp; M&gt;因此.的类型这方法中的methods对象是{ x: number, y: number } &amp; { moveBy(dx: number, dy: number): number }。注意methods属性的推断目标和源。this键入方法。</p>
<p>这个ThisType<T>中声明的空接口。lib.d.ts。除了在对象文本的上下文类型中识别之外，接口的作用就像任何空接口。</p>
<h2 id="内部字符串操作类型"><a href="#内部字符串操作类型" class="headerlink" title="内部字符串操作类型"></a>内部字符串操作类型</h2><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">Uppercase&lt;StringType&gt;</span><br><span class="line">Lowercase&lt;StringType&gt;</span><br><span class="line">Capitalize&lt;StringType&gt;</span><br><span class="line">Uncapitalize&lt;StringType&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>ts</category>
      </categories>
      <tags>
        <tag>ts</tag>
      </tags>
  </entry>
  <entry>
    <title>vue.config.js</title>
    <url>/2020/08/31/vue-config-js/</url>
    <content><![CDATA[<h1 id="vue-config-js文件配置"><a href="#vue-config-js文件配置" class="headerlink" title="vue.config.js文件配置"></a>vue.config.js文件配置</h1><blockquote>
<p>使用vue-cli3创建的项目不再有配置文件，须自主创建vue.config.js，这里可以按照夏利穿件</p>
</blockquote>
<pre><code>/*
* @Description: 
* @Author: kukuboy
* @Date: 2020-05-25 09:15:19
* @LastEditTime: 2020-07-16 09:00:04
* @LastEditors: kukuboy
*/
module.exports = {
    // 基本路径
    // baseUrl: process.env.NODE_ENV === &apos;production&apos; ? &apos;&apos; : &apos;&apos;,
    // 更改路径，解决空白
    publicPath:&apos;./&apos;,
    // 输出文件目录
    outputDir: &apos;dist&apos;, // 默认dist
    // 用于嵌套生成的静态资产（js,css,img,fonts）目录
    // assetsDir: &apos;&apos;,
    // 指定生成的 index.html 的输出路径 (相对于 outputDir)。也可以是一个绝对路径
    indexPath: &apos;index.html&apos;, // Default: &apos;index.html&apos;
    filenameHashing: true,
    // 构建多页时使用
    pages: undefined,
    // eslint-loader是否在保存的时候检查
    lintOnSave: true,
    // 是否使用包含运行时编译器的Vue核心的构建
    runtimeCompiler: false,
    // 默认情况下 babel-loader 会忽略所有 node_modules 中的文件。如果你想要通过 Babel 显式转译一个依赖，可以在这个选项中列出来
    transpileDependencies: [],
    // 如果你不需要生产环境的 source map，可以将其设置为 false 以加速生产环境构建。
    productionSourceMap: false,
    // 如果这个值是一个对象，则会通过 webpack-merge 合并到最终的配置中。如果这个值是一个函数，则会接收被解析的配置作为参数。该函数及可以修改配置并不返回任何东西，也可以返回一个被克隆或合并过的配置版本。
    configureWebpack: config =&gt; {
        if (process.env.NODE_ENV === &apos;production&apos;) {
            // 为生产环境修改配置...
        } else {
            // 为开发环境修改配置...
        }
    },
    // 是一个函数，会接收一个基于 webpack-chain 的 ChainableConfig 实例。允许对内部的 webpack 配置进行更细粒度的修改。
    chainWebpack: config =&gt; {
        /*config.module
        .rule(&apos;images&apos;)
        .use(&apos;url-loader&apos;)
            .loader(&apos;url-loader&apos;)
            .tap(options =&gt; {
            // 修改它的选项...
            return options
            })*/
    },
    // // css相关配置
    // css: {
    //     // 启用 CSS modules
    //     modules: false,
    //     // 是否使用css分离插件
    //     extract: true,
    //     // 开启 CSS source maps?
    //     sourceMap: false,
    //     // css预设器配置项
    //     loaderOptions: {},
    // },
    // webpack-dev-server 相关配置
    devServer: {
        host: &apos;0.0.0.0&apos;,
        port: 8080,
        https: false,
        open: false,
        hotOnly: false,
        proxy: {
            &apos;/xxxx&apos;: {
                target: &apos;http://xxx.xxx.xx.xxx:9804&apos;,
                changeOrigin: true,
                pathRewrite: {
                    &apos;^/xxxx&apos;: &apos;/xxxx&apos;
                }
            }
        },
        before: app =&gt; { },
    },
    // PWA 插件相关配置
    pwa: {},
    // 第三方插件配置
    pluginOptions: {
        // ...
    }
}</code></pre>]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
        <category>config</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>config</tag>
        <tag>vue-cli3</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-router实现404</title>
    <url>/2020/09/21/vue-router%E5%AE%9E%E7%8E%B0404/</url>
    <content><![CDATA[<h1 id="实现页面跳转到404页面"><a href="#实现页面跳转到404页面" class="headerlink" title="实现页面跳转到404页面"></a>实现页面跳转到404页面</h1><pre><code>const page404 = {
path: &quot;/*&quot;,
name: &quot;error_404&quot;,
hidden: true,
meta: {
    title: &quot;404-页面不存在&quot;
},
component: () =&gt; import(&quot;../views/error_page/404.vue&quot;)
};
const routes = [
{
    path: &quot;/&quot;,
    // name: &quot;Home&quot;,
    component: () =&gt; import(&quot;../views/Home&quot;),
},
page500,
page404
];
//添加其他页面请写在page404之前，否则会覆盖匹配</code></pre><h1 id="实现不存页面均跳转到首页"><a href="#实现不存页面均跳转到首页" class="headerlink" title="实现不存页面均跳转到首页"></a>实现不存页面均跳转到首页</h1><pre><code>const pageNotFound = {
path: &quot;/*&quot;,
component: NotFoundComponent
};
const routes = [
{
    path: &quot;/&quot;,
    // name: &quot;Home&quot;,
    component: () =&gt; import(&quot;../views/Home&quot;),
},
pageNotFound
];
//添加其他页面请写在pageNotFound之前，否则会覆盖匹配</code></pre>]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
        <category>vue-router</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-cli3</tag>
        <tag>vue-router</tag>
        <tag>404</tag>
      </tags>
  </entry>
  <entry>
    <title>vuex_state数据刷新丢失问题</title>
    <url>/2020/09/04/vuex-state%E6%95%B0%E6%8D%AE%E5%88%B7%E6%96%B0%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<blockquote>
<p>在使用vuex存储数据进行调试的过程中，刷新会直接丢失数据，在这里直接敷上解决方法</p>
</blockquote>
<blockquote>
<p>此项目由vue-cli3建立</p>
</blockquote>
<h1 id="store-index-js文件"><a href="#store-index-js文件" class="headerlink" title="store,index.js文件"></a>store,index.js文件</h1><pre><code>/*
* @Description:
* @Author: 水印红枫
* @Date: 2020-07-02 16:46:07
* @LastEditors: 水印红枫
*/
import Vue from &quot;vue&quot;;
import Vuex from &quot;vuex&quot;;
import { cmd } from &quot;@/util/myUtil&quot;;

Vue.use(Vuex);

const store = new Vuex.Store({
state: sessionStorage.getItem(&quot;state&quot;)
    ? JSON.parse(sessionStorage.getItem(&quot;state&quot;))
    : {
        currentPage: &quot;/&quot;
    },
getters: {
    currentPage(state) {
    return state.currentPage;
    }
},
mutations: {
    setcurrentPage(state, val) {
    state.currentPage = val;
    }
},
actions: {
    setcurrentPage({ commit }, val) {
    commit(&quot;setcurrentPage&quot;, val);
    }
}
});
export default store;</code></pre><h2 id="app-vue-或者home-vue中"><a href="#app-vue-或者home-vue中" class="headerlink" title="app.vue 或者home.vue中"></a>app.vue 或者home.vue中</h2><pre><code>destroyed() {
    window.removeEventListener(&quot;unload&quot;, this.saveState); // 解决刷新后vux内容丢失问题
},
mounted() {
    this.init();
},
methods: {
    init() {
    // 解决刷新后vux内容丢失问题
    window.addEventListener(&quot;unload&quot;, this.saveState);
    },
    saveState() {
    sessionStorage.setItem(&quot;state&quot;, JSON.stringify(this.$store.state));
    // 需要在刷新时进行操作可在这里
    // sessionStorage.setItem(&quot;state_page&quot;, 1);
    this.clearState();
    },
    clearState() {
    //刷新后需要清空的数据放在这里处理
    },
}</code></pre>]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
        <category>vuex</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>vue-cli3</tag>
        <tag>vuex</tag>
        <tag>state刷新丢失</tag>
      </tags>
  </entry>
  <entry>
    <title>vue常用api</title>
    <url>/2020/11/24/vue%E5%B8%B8%E7%94%A8api/</url>
    <content><![CDATA[<h1 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h1><p><strong>可卸载main.js中</strong></p>
<h2 id="silent"><a href="#silent" class="headerlink" title="silent"></a>silent</h2><p><strong>控制使用</strong></p>
<ul>
<li><p>类型：boolean</p>
</li>
<li><p>默认值：false</p>
</li>
<li><p>用法：</p>
</li>
</ul>
<pre><code>Vue.config.silent = true</code></pre><p>取消 Vue 所有的日志与警告。</p>
<h2 id="keyCodes"><a href="#keyCodes" class="headerlink" title="keyCodes"></a>keyCodes</h2><p><strong>控制按键绑定对应功能</strong></p>
<ul>
<li><p>类型：{ [key: string]: number | Array<number> }</p>
</li>
<li><p>默认值：{}</p>
</li>
<li><p>用法：</p>
</li>
</ul>
<pre><code>Vue.config.keyCodes = {
v: 86,
f1: 112,
// camelCase 不可用
mediaPlayPause: 179,
// 取而代之的是 kebab-case 且用双引号括起来
&quot;media-play-pause&quot;: 179,
up: [38, 87]
}
&lt;input type=&quot;text&quot; @keyup.media-play-pause=&quot;method&quot;&gt;</code></pre><p>给 v-on 自定义键位别名。</p>
<h2 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h2><p><strong>查看性能</strong></p>
<ul>
<li><p>2.2.0 新增</p>
</li>
<li><p>类型：boolean</p>
</li>
<li><p>默认值：false (自 2.2.3 起)</p>
</li>
<li><p>用法：</p>
</li>
</ul>
<p>设置为 true 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪。只适用于开发模式和支持 performance.mark API 的浏览器上。</p>
<h2 id="productionTip"><a href="#productionTip" class="headerlink" title="productionTip"></a>productionTip</h2><p><strong>该项配置可去除开发时当前路由跳转提示</strong></p>
<ul>
<li><p>2.2.0 新增</p>
</li>
<li><p>类型：boolean</p>
</li>
<li><p>默认值：true</p>
</li>
<li><p>用法：</p>
</li>
</ul>
<p>设置为 false 以阻止 vue 在启动时生成生产提示。</p>
<h1 id="api"><a href="#api" class="headerlink" title="api"></a>api</h1><h2 id="Vue-extend-options"><a href="#Vue-extend-options" class="headerlink" title="Vue.extend( options )"></a>Vue.extend( options )</h2><p><strong>可以理解为vue文件</strong></p>
<ul>
<li><p>参数：</p>
<pre><code>{Object} options</code></pre></li>
<li><p>用法：</p>
</li>
</ul>
<p>使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。</p>
<p>data 选项是特例，需要注意 - 在 Vue.extend() 中它必须是函数</p>
<pre><code>&lt;div id=&quot;mount-point&quot;&gt;&lt;/div&gt;
// 创建构造器
var Profile = Vue.extend({
template: &apos;&lt;p&gt;{{firstName}} {{lastName}} aka {{alias}}&lt;/p&gt;&apos;,
data: function () {
    return {
    firstName: &apos;Walter&apos;,
    lastName: &apos;White&apos;,
    alias: &apos;Heisenberg&apos;
    }
}
})
// 创建 Profile 实例，并挂载到一个元素上。
new Profile().$mount(&apos;#mount-point&apos;)</code></pre><p>结果如下：</p>
<pre><code>&lt;p&gt;Walter White aka Heisenberg&lt;/p&gt;</code></pre><h2 id="Vue-nextTick-callback-context"><a href="#Vue-nextTick-callback-context" class="headerlink" title="Vue.nextTick( [callback, context] )"></a>Vue.nextTick( [callback, context] )</h2><p><strong>可用于等待页面渲染完成</strong></p>
<ul>
<li><p>参数：</p>
<pre><code>{Function} [callback]
{Object} [context]</code></pre></li>
<li><p>用法：</p>
</li>
</ul>
<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p>
<pre><code>// 修改数据
vm.msg = &apos;Hello&apos;
// DOM 还没有更新
Vue.nextTick(function () {
// DOM 更新了
})

// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)
Vue.nextTick()
.then(function () {
    // DOM 更新了
})</code></pre><p>2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。</p>
<h2 id="Vue-set-target-propertyName-index-value"><a href="#Vue-set-target-propertyName-index-value" class="headerlink" title="Vue.set( target, propertyName/index, value )"></a>Vue.set( target, propertyName/index, value )</h2><p><strong>可触发视图更新</strong></p>
<ul>
<li><p>参数：</p>
<p>  {Object | Array} target<br>  {string | number} propertyName/index<br>  {any} value<br>返回值：设置的值。</p>
</li>
<li><p>用法：</p>
</li>
</ul>
<p>向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新 property，因为 Vue 无法探测普通的新增 property (比如 this.myObject.newProperty = ‘hi’)</p>
<p>注意对象不能是 Vue 实例，或者 Vue 实例的根数据对象。</p>
<h2 id="Vue-delete-target-propertyName-index"><a href="#Vue-delete-target-propertyName-index" class="headerlink" title="Vue.delete( target, propertyName/index )"></a>Vue.delete( target, propertyName/index )</h2><p><strong>可触发视图更新</strong></p>
<ul>
<li><p>参数：</p>
<p>  {Object | Array} target<br>  {string | number} propertyName/index<br>仅在 2.2.0+ 版本中支持 Array + index 用法。</p>
</li>
<li><p>用法：</p>
</li>
</ul>
<p>删除对象的 property。如果对象是响应式的，确保删除能触发更新视图。这个方法主要用于避开 Vue 不能检测到 property 被删除的限制，但是你应该很少会使用它。</p>
<p>在 2.2.0+ 中同样支持在数组上工作。</p>
<p>目标对象不能是一个 Vue 实例或 Vue 实例的根数据对象。</p>
<h1 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h1><blockquote>
<p>所有的生命周期钩子自动绑定 this 上下文到实例中，因此你可以访问数据，对 |property 和方法进行运算。这意味着你不能使用箭头函数来定义一个生命周期方法 (例如 created: () =&gt; this.fetchTodos())。这是因为箭头函数绑定了父上下文，因此 this 与你期待的 Vue 实例不同，this.fetchTodos 的行为未定义。</p>
</blockquote>
<h2 id="生命周期图"><a href="#生命周期图" class="headerlink" title="生命周期图"></a>生命周期图</h2><p><img src="/img/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA.png" alt="生命周期图示"></p>
<h2 id="beforeCreate"><a href="#beforeCreate" class="headerlink" title="beforeCreate"></a>beforeCreate</h2><ul>
<li><p>类型：Function</p>
</li>
<li><p>详细：</p>
</li>
</ul>
<p>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</p>
<h2 id="created"><a href="#created" class="headerlink" title="created"></a>created</h2><ul>
<li><p>类型：Function</p>
</li>
<li><p>详细：</p>
</li>
</ul>
<p>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el property 目前尚不可用。</p>
<h2 id="beforeMount"><a href="#beforeMount" class="headerlink" title="beforeMount"></a>beforeMount</h2><ul>
<li><p>类型：Function</p>
</li>
<li><p>详细：</p>
</li>
</ul>
<p>在挂载开始之前被调用：相关的 render 函数首次被调用。</p>
<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>
<h2 id="mounted"><a href="#mounted" class="headerlink" title="mounted"></a>mounted</h2><ul>
<li><p>类型：Function</p>
</li>
<li><p>详细：</p>
</li>
</ul>
<p>实例被挂载后调用，这时 el 被新创建的 vm.$el 替换了。如果根实例挂载到了一个文档内的元素上，当 mounted 被调用时 vm.$el 也在文档内。</p>
<p><strong>注意 mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick：</strong></p>
<pre><code>mounted: function () {
this.$nextTick(function () {
    // Code that will run only after the
    // entire view has been rendered
})
}</code></pre><p>该钩子在服务器端渲染期间不被调用。</p>
<h2 id="beforeUpdate"><a href="#beforeUpdate" class="headerlink" title="beforeUpdate"></a>beforeUpdate</h2><ul>
<li><p>类型：Function</p>
</li>
<li><p>详细：</p>
</li>
</ul>
<p>数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</p>
<p><strong>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</strong></p>
<h2 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h2><ul>
<li><p>类型：Function</p>
</li>
<li><p>详细：</p>
</li>
</ul>
<p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p>
<p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。</p>
<p>注意 updated 不会保证所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以在 updated 里使用 vm.$nextTick：</p>
<pre><code>updated: function () {
this.$nextTick(function () {
    // Code that will run only after the
    // entire view has been re-rendered
})
}</code></pre><p>该钩子在服务器端渲染期间不被调用。</p>
<h2 id="activated"><a href="#activated" class="headerlink" title="activated"></a>activated</h2><ul>
<li><p>类型：Function</p>
</li>
<li><p>详细：</p>
</li>
</ul>
<p>被 keep-alive 缓存的组件激活时调用。</p>
<p>该钩子在服务器端渲染期间不被调用。</p>
<ul>
<li>参考：</li>
</ul>
<p><a href="https://cn.vuejs.org/v2/api/#keep-alive" target="_blank" rel="noopener">构建组件 - keep-alive</a><br><a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%9C%A8%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-keep-alive" target="_blank" rel="noopener">动态组件 - keep-alive</a></p>
<h2 id="deactivated"><a href="#deactivated" class="headerlink" title="deactivated"></a>deactivated</h2><ul>
<li><p>类型：Function</p>
</li>
<li><p>详细：</p>
</li>
</ul>
<p>被 keep-alive 缓存的组件停用时调用。</p>
<p>该钩子在服务器端渲染期间不被调用。</p>
<ul>
<li>参考：</li>
</ul>
<p><a href="https://cn.vuejs.org/v2/api/#keep-alive" target="_blank" rel="noopener">构建组件 - keep-alive</a><br><a href="https://cn.vuejs.org/v2/guide/components-dynamic-async.html#%E5%9C%A8%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E4%B8%8A%E4%BD%BF%E7%94%A8-keep-alive" target="_blank" rel="noopener">动态组件 - keep-alive</a></p>
<h2 id="beforeDestroy"><a href="#beforeDestroy" class="headerlink" title="beforeDestroy"></a>beforeDestroy</h2><ul>
<li><p>类型：Function</p>
</li>
<li><p>详细：</p>
</li>
</ul>
<p>实例销毁之前调用。在这一步，实例仍然完全可用。</p>
<p>该钩子在服务器端渲染期间不被调用。</p>
<h2 id="destroyed"><a href="#destroyed" class="headerlink" title="destroyed"></a>destroyed</h2><ul>
<li><p>类型：Function</p>
</li>
<li><p>详细：</p>
</li>
</ul>
<p>实例销毁后调用。该钩子被调用后，对应 Vue 实例的所有指令都被解绑，所有的事件监听器被移除，所有的子实例也都被销毁。</p>
<p>该钩子在服务器端渲染期间不被调用。</p>
<h2 id="errorCaptured"><a href="#errorCaptured" class="headerlink" title="errorCaptured"></a>errorCaptured</h2><blockquote>
<p>2.5.0+ 新增</p>
</blockquote>
<ul>
<li><p>类型：(err: Error, vm: Component, info: string) =&gt; ?boolean</p>
</li>
<li><p>详细：</p>
</li>
</ul>
<p>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</p>
<blockquote>
<p>你可以在此钩子中修改组件的状态。因此在捕获错误时，在模板或渲染函数中有一个条件判断来绕过其它内容就很重要；不然该组件可能会进入一个无限的渲染循环。</p>
</blockquote>
<ul>
<li>错误传播规则</li>
</ul>
<ul>
<li><p>默认情况下，如果全局的 config.errorHandler 被定义，所有的错误仍会发送它，因此这些错误仍然会向单一的分析服务的地方进行汇报。</p>
</li>
<li><p>如果一个组件的继承或父级从属链路中存在多个 errorCaptured 钩子，则它们将会被相同的错误逐个唤起。</p>
</li>
<li><p>如果此 errorCaptured 钩子自身抛出了一个错误，则这个新错误和原本被捕获的错误都会发送给全局的 config.errorHandler。</p>
</li>
<li><p>一个 errorCaptured 钩子能够返回 false 以阻止错误继续向上传播。本质上是说“这个错误已经被搞定了且应该被忽略”。它会阻止其它任何会被这个错误唤起的 errorCaptured 钩子和全局的 config.errorHandler。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue混入</title>
    <url>/2020/11/19/vue%E6%B7%B7%E5%85%A5/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><p><strong>一个混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项。</strong></p>
<pre><code>// 定义一个混入对象
var myMixin = {
created: function () {
    this.hello()
},
methods: {
    hello: function () {
    console.log(&apos;hello from mixin!&apos;)
    }
}
}

// 定义一个使用混入对象的组件
var Component = Vue.extend({
mixins: [myMixin]
})

var component = new Component() // =&gt; &quot;hello from mixin!&quot;</code></pre><h1 id="选项合并"><a href="#选项合并" class="headerlink" title="选项合并"></a>选项合并</h1><p><strong>当组件和混入对象含有同名选项时，这些选项将以恰当的方式进行“合并”。比如，数据对象在内部会进行递归合并，并在发生冲突时以组件数据优先。</strong></p>
<pre><code>var mixin = {
data: function () {
    return {
    message: &apos;hello&apos;,
    foo: &apos;abc&apos;
    }
}
}

new Vue({
mixins: [mixin],
data: function () {
    return {
    message: &apos;goodbye&apos;,
    bar: &apos;def&apos;
    }
},
created: function () {
    console.log(this.$data)
    // =&gt; { message: &quot;goodbye&quot;, foo: &quot;abc&quot;, bar: &quot;def&quot; }
}
})</code></pre><p><strong>同名钩子函数将合并为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。</strong></p>
<pre><code>var mixin = {
created: function () {
    console.log(&apos;混入对象的钩子被调用&apos;)
}
}

new Vue({
mixins: [mixin],
created: function () {
    console.log(&apos;组件钩子被调用&apos;)
}
})

// =&gt; &quot;混入对象的钩子被调用&quot;
// =&gt; &quot;组件钩子被调用&quot;</code></pre><p><strong>值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</strong></p>
<pre><code>var mixin = {
methods: {
    foo: function () {
    console.log(&apos;foo&apos;)
    },
    conflicting: function () {
    console.log(&apos;from mixin&apos;)
    }
}
}

var vm = new Vue({
mixins: [mixin],
methods: {
    bar: function () {
    console.log(&apos;bar&apos;)
    },
    conflicting: function () {
    console.log(&apos;from self&apos;)
    }
}
})

vm.foo() // =&gt; &quot;foo&quot;
vm.bar() // =&gt; &quot;bar&quot;
vm.conflicting() // =&gt; &quot;from self&quot;</code></pre><p><strong>注意：Vue.extend() 也使用同样的策略进行合并。</strong></p>
<h1 id="全局混入"><a href="#全局混入" class="headerlink" title="全局混入"></a>全局混入</h1><p><strong>混入也可以进行全局注册。使用时格外小心！一旦使用全局混入，它将影响每一个之后创建的 Vue 实例。使用恰当时，这可以用来为自定义选项注入处理逻辑。</strong></p>
<pre><code>// 为自定义的选项 &apos;myOption&apos; 注入一个处理器。
Vue.mixin({
created: function () {
    var myOption = this.$options.myOption
    if (myOption) {
    console.log(myOption)
    }
}
})

new Vue({
myOption: &apos;hello!&apos;
})
// =&gt; &quot;hello!&quot;</code></pre><p><strong>如在vue-cli3中使用</strong></p>
<p><strong>mixins.js</strong></p>
<pre><code>export default {
data() {
    return {
    //   msg: &quot;erwerwe&quot;,
    //   form: {
    //     a: &quot;aaa&quot;
    //   }
    };
},
//   filters: {
//     //过滤器
//     numToString(value) {
//       return value.toString();
//     }
//   },
created() {
    //钩子函数
    console.log(&quot;这是混入的created组件&quot;);
},
computed: {
    //计算属性
    // ids() {
    //   return !this.loading;
    // }
},
mounted() {
    console.log(&quot;这是混入的mounted组件&quot;);
},
methods: {
    // clickFn() {
    //   console.log(this.msg);
    // }
    // 其它属性方法......
}
};</code></pre><p><strong>main.js</strong></p>
<pre><code>import Vue from &quot;vue&quot;;
import App from &quot;@/App.vue&quot;;
import router from &quot;@/router&quot;;
import store from &quot;@/store&quot;;
import mixins from &quot;@/util/mixins&quot;;

// require(&quot;@/util/mock/mock&quot;);

Vue.config.productionTip = false;

Vue.mixin(mixins);

new Vue({
router,
store,
render: h =&gt; h(App)
}).$mount(&quot;#app&quot;);</code></pre><blockquote>
<p>请谨慎使用全局混入，因为它会影响每个单独创建的 Vue 实例 (包括第三方组件)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。推荐将其作为插件发布，以避免重复应用混入。</p>
</blockquote>
<h1 id="自定义选项合并策略"><a href="#自定义选项合并策略" class="headerlink" title="自定义选项合并策略"></a>自定义选项合并策略</h1><p><strong>自定义选项将使用默认策略，即简单地覆盖已有值。如果想让自定义选项以自定义逻辑合并，可以向 Vue.config.optionMergeStrategies 添加一个函数：</strong></p>
<pre><code>Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {
// 返回合并后的值
}</code></pre><p><strong>对于多数值为对象的选项，可以使用与 methods 相同的合并策略：</strong></p>
<pre><code>var strategies = Vue.config.optionMergeStrategies
strategies.myOption = strategies.methods</code></pre><p><strong>可以在 Vuex 1.x 的混入策略里找到一个更高级的例子：</strong></p>
<pre><code>const merge = Vue.config.optionMergeStrategies.computed
Vue.config.optionMergeStrategies.vuex = function (toVal, fromVal) {
if (!toVal) return fromVal
if (!fromVal) return toVal
return {
    getters: merge(toVal.getters, fromVal.getters),
    state: merge(toVal.state, fromVal.state),
    actions: merge(toVal.actions, fromVal.actions)
}
}</code></pre>]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
        <category>mixin</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>mixin混入</tag>
      </tags>
  </entry>
  <entry>
    <title>vue项目首页加载画面</title>
    <url>/2020/12/01/vue%E9%A1%B9%E7%9B%AE%E9%A6%96%E9%A1%B5%E5%8A%A0%E8%BD%BD%E7%94%BB%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><strong>适用于vue-cli创建的项目</strong></p>
<p><strong>原理为页面加载后内容被替代，加载之前变现实该内容</strong></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;

&lt;head&gt;
&lt;meta charset=&quot;utf-8&quot;&gt;
&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover&quot;&gt;
&lt;link rel=&quot;icon&quot; href=&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;&gt;
&lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
&lt;noscript&gt;
    &lt;strong&gt;We&apos;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&apos;t work properly without JavaScript enabled.
    Please enable it to continue.&lt;/strong&gt;
&lt;/noscript&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;!-- built files will be auto injected --&gt;
    &lt;div id=&quot;rotate&quot;&gt;
    &lt;div class=&quot;ball&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;line lineOne&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;line lineTwo&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;line lineThree&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;line lineFour&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;line lineFive&quot;&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div class=&quot;iconApp&quot; style=&quot;display: none;&quot; onclick=&quot;back()&quot;&gt;
    &lt;p class=&quot;iconfont iconP&quot;&gt;&amp;#xe87c;&lt;/p&gt;
    &lt;p class=&quot;iconP&quot;&gt;加载失败&lt;/p&gt;
    &lt;/div&gt;
    &lt;script&gt;
    function back() {
        //可编写返回或者弹窗内容
    }
    &lt;/script&gt;
    &lt;style&gt;
    #app {
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
    }

    #rotate {
        width: 100%;
        margin-top: 3vh;
        position: relative;
        opacity: 0;
        animation: opactiyChange 1s linear 1s 1 forwards normal;
    }

    @keyframes opactiyChange {
        from {
        opacity: 0;
        }

        to {
        opacity: 1;
        }
    }

    #rotate .line {
        width: 12vw;
        height: 0.3vw;
        background-color: #000000;
        top: 8vw;
        position: absolute;
        left: 44vw;
    }

    #rotate .ball {
        position: absolute;
        margin-left: 47.5vw;
        width: 5vw;
        height: 5vw;
        border-radius: 2.5vw;
        top: 5.5vw;
        z-index: 2;
        background-color: #ffffff;
    }

    #rotate .lineOne {
        animation: rotateOne 3s linear 0s infinite normal;
    }

    #rotate .lineTwo {
        animation: rotateTwo 3s linear 0s infinite normal;
    }

    #rotate .lineThree {
        animation: rotateThree 3s linear 0s infinite normal;
    }

    #rotate .lineFour {
        animation: rotateFour 3s linear 0s infinite normal;
    }

    #rotate .lineFive {
        animation: rotateFive 3s linear 0s infinite normal;
    }

    @keyframes rotateOne {
        0% {
        transform: rotate(0deg);
        }

        20% {
        transform: rotate(36deg);
        }

        40% {
        transform: rotate(72deg);
        }

        60% {
        transform: rotate(108deg);
        }

        80% {
        transform: rotate(144deg);
        }

        100% {
        transform: rotate(180deg);
        }
    }

    @keyframes rotateTwo {
        0% {
        transform: rotate(36deg);
        }

        20% {
        transform: rotate(72deg);
        }

        40% {
        transform: rotate(108deg);
        }

        60% {
        transform: rotate(144deg);
        }

        80% {
        transform: rotate(180deg);
        }

        100% {
        transform: rotate(216deg);
        }
    }

    @keyframes rotateThree {
        0% {
        transform: rotate(72deg);
        }

        20% {
        transform: rotate(108deg);
        }

        40% {
        transform: rotate(144deg);
        }

        60% {
        transform: rotate(180deg);
        }

        80% {
        transform: rotate(216deg);
        }

        100% {
        transform: rotate(252deg);
        }
    }

    @keyframes rotateFour {
        0% {
        transform: rotate(108deg);
        }

        20% {
        transform: rotate(144deg);
        }

        40% {
        transform: rotate(180deg);
        }

        60% {
        transform: rotate(216deg);
        }

        80% {
        transform: rotate(252deg);
        }

        100% {
        transform: rotate(288deg);
        }
    }

    @keyframes rotateFive {
        0% {
        transform: rotate(144deg);
        }

        20% {
        transform: rotate(180deg);
        }

        40% {
        transform: rotate(216deg);
        }

        60% {
        transform: rotate(252deg);
        }

        80% {
        transform: rotate(288deg);
        }

        100% {
        transform: rotate(324deg);
        }
    }
    &lt;/style&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
&lt;style&gt;
#rotate {
    display: none;
}

.iconApp {
    display: block !important;
    text-align: center;
    margin: 0;
}

.iconApp .iconP {
    margin: 0;
}

@font-face {
    font-family: &apos;iconfont&apos;;
    src: url(&apos;iconfont.eot?t=1605171141748&apos;);
    /* IE9 */
    src: url(&apos;iconfont.eot?t=1605171141748#iefix&apos;) format(&apos;embedded-opentype&apos;),
    /* IE6-IE8 */
    url(&apos;data:application/x-font-woff2;charset=utf-8;base64,d09GMgABAAAAAALsAAsAAAAABuQAAAKdAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHEIGVgCCcAqBYIFPATYCJAMICwYABCAFhG0HPhsDBhHVk2tkXyTYjtFbgDIrYZ6GfIV2WYUzwfP8Or5zH8YfRMJSzJLiRkHZcfM0QAAd8BxjBQ+Azc3QNSpCsSTneT99RzompPnpE/dO/wookPmAclx706QuwDiggPbGKKBAC6SQG8YueIG3IUBAoXrStXvfoXgY7EUCyNxZMybhFUIYDMt6CE7DToPswOKpjeoZsD36vPyhIQ8UVmPXDZzebSodfy5x8vSKeMXYgEC83H0AFtBAPTAgQxtT/dEIY2uClKEUx6oW+LkkjgMLclQjwv46uzICIB+KnknsSR71lwoAA1igKzB40muA9VOTk/0Z52+uvLHp2orr0z5sGrrnwMGzWR83D9sbns/af2hC4r13xebk+25JDz+W2VMfxh24Vp547kauPXyzKuns9ZyhZ4Ri89hUh5snGps7q57ohV3jBV3Pjbw4/ezkNruruGwfM7JrrxUDe/a0Ha2vG5jM8W8EjSdWnGgMOkbWmx3mGEFHAOJrRyN/9TtMqezFhKS2/73QAPD1bfZ9PCe+QQvgndst8A/FA7uMIbXNymjixpyiK/beGgICIIZ9qX5M1WXcsEPwCmIGhUsBNB7lpGHVwxLSBAePDgio02N/SJrFaMT4QK21AEKyC1AkchOaZM9Jw/oOS6Z/cEhOI2C4pJ0YUhk6S3QhlIwG1A+CbtW6VhZx9RXdK0vKSyPOE6mHKCzjXM5esCItsaa/3cpswVIrsIP7MOcGB7WImkfPfGzTZJueNOpWBkEXQslogPqBoFu1QX8Wlfdf0b2ypI6OuvATqYfhwWI0DyAvqjqo41Ee6W+3YrbAUitgBw7MTqqBo3laRM0jPyFxbCbUyw5Vjdtryt8dAAJsvRJnhCZ9ryPIGr38vwzdBxUE53UYAAAAAA==&apos;) format(&apos;woff2&apos;),
    url(&apos;iconfont.woff?t=1605171141748&apos;) format(&apos;woff&apos;),
    url(&apos;iconfont.ttf?t=1605171141748&apos;) format(&apos;truetype&apos;),
    /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */
    url(&apos;iconfont.svg?t=1605171141748#iconfont&apos;) format(&apos;svg&apos;);
    /* iOS 4.1- */
}

.iconApp .iconfont {
    margin-top: 20vh;
    font-family: &apos;iconfont&apos; !important;
    font-size: 20vw;
    font-style: normal;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
}
&lt;/style&gt;</code></pre>]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
        <category>vue-cli项目</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>首页加载过慢</tag>
      </tags>
  </entry>
  <entry>
    <title>vue混入文件的几大用法</title>
    <url>/2020/12/01/vue%E6%B7%B7%E5%85%A5%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E5%A4%A7%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><strong>该用法未采用全局混入，采用引入混用</strong><br><strong>文件格式为正常的vue文件</strong></p>
<p>方法为：</p>
<pre><code>import mixins from &quot;@/util/mixins&quot;;

export default {
name: &quot;NewGift&quot;,
components: {},
mixins: [mixins],
}</code></pre><h1 id="显示页面加载时间"><a href="#显示页面加载时间" class="headerlink" title="显示页面加载时间"></a>显示页面加载时间</h1><pre><code>created() {
    console.time(&quot;页面加载时间：&quot;);
    document.getElementById(&quot;app&quot;).classList.add(&quot;viewFilter&quot;);
    mixin_time = setTimeout(() =&gt; {
    console.log(&quot;开始出现加载条&quot;);
    this.$Dialog.ViewLoading();
    }, 1000);
},
mounted() {
    console.timeEnd(&quot;页面加载时间：&quot;);
    // setTimeout(() =&gt; {
    document.getElementById(&quot;app&quot;).classList.remove(&quot;viewFilter&quot;);
    this.$Dialog.ViewLoading({
    state: &quot;end&quot;
    });
    clearTimeout(mixin_time);
    // }, 100000);
},</code></pre><h1 id="存放一些通用变量，如放在vuex-getter里的值"><a href="#存放一些通用变量，如放在vuex-getter里的值" class="headerlink" title="存放一些通用变量，如放在vuex getter里的值"></a>存放一些通用变量，如放在vuex getter里的值</h1><pre><code>import { mapGetters } from &quot;vuex&quot;;
computed: {
    //计算属性
    ...mapGetters([&quot;loginSign&quot;])
},</code></pre><h1 id="页面加载过慢时增加等待"><a href="#页面加载过慢时增加等待" class="headerlink" title="页面加载过慢时增加等待"></a>页面加载过慢时增加等待</h1><p><strong>this.$Dialog.ViewLoading();为显示一个遮罩层覆盖页面，出现加载条</strong></p>
<pre><code>let mixin_time;
export default {
destroyed() {
    clearTimeout(mixin_time);
},
created() {
    mixin_time = setTimeout(() =&gt; {
    console.log(&quot;开始出现加载条&quot;);
    this.$Dialog.ViewLoading();
    }, 1000);
},
mounted() {
    this.$Dialog.ViewLoading({
    state: &quot;end&quot;
    });
},</code></pre><h1 id="页面加载完成前增加模糊"><a href="#页面加载完成前增加模糊" class="headerlink" title="页面加载完成前增加模糊"></a>页面加载完成前增加模糊</h1><pre><code>export default {
created() {
    document.getElementById(&quot;app&quot;).classList.add(&quot;viewFilter&quot;);
},
mounted() {
    document.getElementById(&quot;app&quot;).classList.remove(&quot;viewFilter&quot;);
},</code></pre><h1 id="部分内容接口请求完成前模糊内容"><a href="#部分内容接口请求完成前模糊内容" class="headerlink" title="部分内容接口请求完成前模糊内容"></a>部分内容接口请求完成前模糊内容</h1><p><strong>js</strong></p>
<pre><code>//array内容为ref名字的数字，如：
//&lt;div ref=&quot;answer1&quot;&gt;&lt;/div&gt;
//&lt;div ref=&quot;answer2&quot;&gt;&lt;/div&gt;
//array=[&quot;answer1&quot;,&quot;answer2&quot;]
methods: {
    RequestInit(array) {
    try {
        for (let i of array) {
        if (this.$refs[i]._isVue) this.$refs[i].$el.classList.add(&quot;filter10&quot;);
        else this.$refs[i].classList.add(&quot;filter10&quot;);
        }
    } catch (e) {
        console.log(&quot;混入函数出错：&quot;, e);
    }
    },
    RequestSuccess(array) {
    try {
        this.$nextTick(() =&gt; {
        for (let i of array) {
            if (this.$refs[i]._isVue)
            this.$refs[i].$el.classList.remove(&quot;filter10&quot;);
            else this.$refs[i].classList.remove(&quot;filter10&quot;);
        }
        });
    } catch (e) {
        console.log(&quot;混入函数出错：&quot;, e);
    }
    },
    RequestFail(array) {
    try {
        for (let i of array) {
        if (this.$refs[i]._isVue) {
            this.$refs[i].$el.classList.add(&quot;filterFail&quot;);
            this.$refs[i].$el.addEventListener(&quot;click&quot;, () =&gt;
            this.failClick(this.$refs[i].$el, i)
            );
        } else {
            this.$refs[i].classList.add(&quot;filterFail&quot;);
            this.$refs[i].addEventListener(&quot;click&quot;, () =&gt;
            this.failClick(this.$refs[i], i)
            );
        }
        }
    } catch (e) {
        console.log(&quot;混入函数出错：&quot;, e);
    }
    },
    failClick(el, name) {
    if (el.classList.value.indexOf(&quot;filterFail&quot;) &lt; 0) return;
    el.classList.remove(&quot;filterFail&quot;);
    el.removeEventListener(&quot;click&quot;, () =&gt; this.failClick(el, name));
    // 重新请求函数
    try {
        eval(&quot;this.&quot; + name + &quot;()&quot;);
    } catch (e) {
        console.log(&quot;重复请求失败&quot;, e);
    }
    }
}</code></pre><p><strong>scss</strong></p>
<pre><code>.filter10{
position: relative;
*{
    filter: blur(10px);
    -webkit-filter: blur(10px);
    pointer-events: none;
}
&amp;::after{
    content: &quot;&quot;;
    position: absolute;
    left: 20%;
    top: 40%;
    width: 30%;
    height: 2px;
    border-radius: 1px;
    background-color: #e83030;
    animation: move 1s linear 0s infinite normal;
}
@keyframes move {
    0%{
    left: 20%;
    width: 0;
    }
    25%{
    left: 20%;
    width: 30%;
    }
    50%{
    left: 50%;
    width: 30%;
    }
    75%{
    left: 80%;
    width: 0%;
    }
    100%{
    left: 80%;
    width: 0%;
    }
}
&amp;.filterFail::after{
    font-size: 0.3rem;
    line-height: 0.6rem;
    color: #FFFFFF;
    content: &quot;点击重试&quot;;
    position: absolute;
    left: 30%;
    top: 40%;
    height: 0.6rem;
    width: 40%;
    border-radius: 0.3rem;
    box-shadow: 0 5px 20px #000000;
    animation:none;
}
}</code></pre>]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
        <category>mixin</category>
        <category>mixin.js</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>mixin混入</tag>
      </tags>
  </entry>
  <entry>
    <title>前端常见问题</title>
    <url>/2021/03/10/%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="安卓中img标签图片正常显示，ios不显示问题"><a href="#安卓中img标签图片正常显示，ios不显示问题" class="headerlink" title="安卓中img标签图片正常显示，ios不显示问题"></a>安卓中img标签图片正常显示，ios不显示问题</h1><pre><code>安卓与ios存在层级渲染不同的问题，看是否图片存在z-index过低的原因，
在ios中渲染可能会低于背景
故消失看不见</code></pre>]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>前端细节知识点</title>
    <url>/2020/07/28/%E5%89%8D%E7%AB%AF%E7%BB%86%E8%8A%82%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="前端细节知识点"><a href="#前端细节知识点" class="headerlink" title="前端细节知识点"></a>前端细节知识点</h1><hr>
<h2 id="使用-in-遍历数组"><a href="#使用-in-遍历数组" class="headerlink" title="使用 in 遍历数组"></a>使用 in 遍历数组</h2><pre><code>for (let i in this.rainTime.time) {
           let key = i === &quot;0&quot; ? &quot;am&quot; : &quot;pm&quot;;
}</code></pre><blockquote>
<p>易错点：在使用in遍历数组的过程中，如果涉及对 in 的判断，这里注意，in 拿到的值是字符的形式，如“0”，勿用数组去比较</p>
</blockquote>
<h2 id="z-index"><a href="#z-index" class="headerlink" title="z-index"></a>z-index</h2><pre><code>z-index: 0 // 默认值</code></pre><blockquote>
<p>易错点：只在存在position设置非默认时生效，同时在background-color，background-image等存在时容易出现问题，最好自己先验证一下</p>
</blockquote>
<h2 id="实现字符串乘法"><a href="#实现字符串乘法" class="headerlink" title="实现字符串乘法"></a>实现字符串乘法</h2><pre><code>// str:字符串，num: 乘数
let newVal = Array.prototype.join.call({length:num+1},str)</code></pre><h1 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h1><h2 id="js-storage存储变成-object-object"><a href="#js-storage存储变成-object-object" class="headerlink" title="js storage存储变成[object,object]"></a>js storage存储变成[object,object]</h2><p><strong>问题：</strong> 在把对象存入localstorge或sessionstorge时，再直接拿出时可能会变成[object object]<br><strong>解决方法：</strong> 存入时用JSON.stringify转化，取出时再用JSON.parse转化回来即可</p>
<h2 id="fill-之后数组的内容一变都变"><a href="#fill-之后数组的内容一变都变" class="headerlink" title="fill 之后数组的内容一变都变"></a>fill 之后数组的内容一变都变</h2><p><strong>问题：</strong> 比如在fill之中再放入一个数组，数组中某一个项改变时，其他的也会跟着改变<br><strong>解决方法：</strong> fill填充的是对这个对象的引用，故最好不要在fill中填入引入类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>).fill(<span class="literal">false</span>))</span><br><span class="line">arr[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span></span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line">    输出：</span><br><span class="line">    [</span><br><span class="line">        [<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>],</span><br><span class="line">        [<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>],</span><br><span class="line">        [<span class="literal">true</span>,<span class="literal">false</span>,<span class="literal">false</span>]</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
<h2 id="es6数组的方便遍历方法"><a href="#es6数组的方便遍历方法" class="headerlink" title="es6数组的方便遍历方法"></a>es6数组的方便遍历方法</h2><pre><code>for (let index of [&apos;a&apos;, &apos;b&apos;].keys()) {
console.log(index);
}
// 0
// 1

for (let elem of [&apos;a&apos;, &apos;b&apos;].values()) {
console.log(elem);
}
// &apos;a&apos;
// &apos;b&apos;

for (let [index, elem] of [&apos;a&apos;, &apos;b&apos;].entries()) {
console.log(index, elem);
}
// 0 &quot;a&quot;
// 1 &quot;b&quot;</code></pre><p>如果不使用for…of循环，可以手动调用遍历器对象的next方法，进行遍历。</p>
<pre><code>let letter = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];
let entries = letter.entries();
console.log(entries.next().value); // [0, &apos;a&apos;]
console.log(entries.next().value); // [1, &apos;b&apos;]
console.log(entries.next().value); // [2, &apos;c&apos;]</code></pre><h1 id="对象和继承"><a href="#对象和继承" class="headerlink" title="对象和继承"></a>对象和继承</h1><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// js常见的对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name=<span class="string">"张三"</span></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name=name</span><br><span class="line">  <span class="keyword">this</span>.run=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>在跑步`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.work=<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>在工作`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对象冒充继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newPerson</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型链继承</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newAgainPerson</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  Person.call(<span class="keyword">this</span>,name) <span class="comment">//加对象冒充方法可以传入参数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// newAgainPerson.prototype=new Person()</span></span><br><span class="line">newAgainPerson.prototype=Person.prototype <span class="comment">//防止重复继承</span></span><br><span class="line"><span class="keyword">let</span> n = newPerson()</span><br><span class="line">n.run()</span><br><span class="line"><span class="comment">// n.work() 不可以继承原型链上的，此无法运行</span></span><br><span class="line"><span class="keyword">let</span> nn = newAgainPerson()</span><br><span class="line">nn.work() <span class="comment">// 可以运行</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>es6</tag>
        <tag>数组</tag>
        <tag>fill</tag>
        <tag>localstorge</tag>
        <tag>sessionstorge</tag>
      </tags>
  </entry>
  <entry>
    <title>回流和重绘</title>
    <url>/2020/12/01/%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="回流"><a href="#回流" class="headerlink" title="回流"></a>回流</h2><p>回流即为重排<br>当render tree的内容因为尺寸，布局，隐藏，位置改变而改变时需要重新构建，即为回流<br>页面至少需要一次回流，即为页面第一次加载的时候</p>
<h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>当render tree的的一些元素需要更新属性，只影响该元素的外观，不影响布局的，即为重绘</p>
<h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p>回流完即会引起重绘，所以可以说回流一定会重绘，而重绘不一定会回流</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><blockquote>
<p>由介绍可知，回流的代价一定比重绘高，所以减少回流即可在性能上做到提升</p>
</blockquote>
<h2 id="动画脱离文档流"><a href="#动画脱离文档流" class="headerlink" title="动画脱离文档流"></a>动画脱离文档流</h2><p>如果页面中存在动画效果，如果在文档流中即可导致页面回流，这个时候脱离文档流，及使用定位的方式便可实现优化</p>
<h2 id="样式统一改变"><a href="#样式统一改变" class="headerlink" title="样式统一改变"></a>样式统一改变</h2><p>现在很多浏览器已经有了自己的队列，所以这个方式并一定可以优化，但一些样式如scrolleft,clientheight,等样式会清空样式，所以在使用的时候需要注意一下</p>
<p>方法一，样式的逐项改变换位统一改变</p>
<pre><code>dom.style.height=&apos;100px&apos;
dom.style.marginLeft=&apos;20px&apos;

改为dom.style.cssText=&quot;height:&apos;100px&apos;;margin-left:&apos;20px&apos;</code></pre><p>方法二，直接改变类名</p>
<pre><code>dom.classList.remove(&quot;filter10&quot;);
dom.classList.add(&quot;filter&quot;);</code></pre><h2 id="css硬件加速"><a href="#css硬件加速" class="headerlink" title="css硬件加速"></a>css硬件加速</h2><p>该方法须GPU支持，开始后一些动画样式的改变便不会再引起回流</p>
<h2 id="隐藏元素"><a href="#隐藏元素" class="headerlink" title="隐藏元素"></a>隐藏元素</h2><p>先隐藏元素，修改后再显示</p>
<h2 id="复制元素"><a href="#复制元素" class="headerlink" title="复制元素"></a>复制元素</h2><p>修改复制后的元素，修改完成后再显示</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>优化</category>
        <category>回流和重绘</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>回流和重绘</tag>
      </tags>
  </entry>
  <entry>
    <title>字重</title>
    <url>/2020/07/23/%E5%AD%97%E9%87%8D/</url>
    <content><![CDATA[<h1 id="字重"><a href="#字重" class="headerlink" title="字重"></a>字重</h1><pre><code>渺 100－UltraLight/HairLine
丝 100 ExtraLight/UltraLight/HairLine/Thin
纤 200 Thin/ExtraLight/UltraLight
细 300 Light
线 (350 SemiLight)
书 (350 Book)
标 400 Regular
中 500 Medium
庸 600 Semibold/DemiBold
肿 (650 Demibold)
粗 700 Bold
重 800 Heavy/ExtraBold/Black/Extra
黑 900 Black/Heavy/Ultra
抹 950 ExtraBlack/UltraBlack/Ultra
糊 950+ UltraBlack/Ultra</code></pre>]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么建立自己的博客</title>
    <url>/2021/04/27/%E6%80%8E%E4%B9%88%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="快速部署"><a href="#快速部署" class="headerlink" title="快速部署"></a>快速部署</h1><h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><blockquote>
<p>这里步骤太简单，而且网上的步骤很多，这里不再介绍</p>
</blockquote>
<ul>
<li>node.js环境</li>
<li>git 环境</li>
</ul>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><blockquote>
<p>powerShell环境</p>
</blockquote>
<pre><code>//全局安装
npm install hexo-cli -g</code></pre><h2 id="创建自己的博客文件"><a href="#创建自己的博客文件" class="headerlink" title="创建自己的博客文件"></a>创建自己的博客文件</h2><blockquote>
<p>powerShell环境</p>
</blockquote>
<pre><code>hexo init blogDemo

hexo3.0服务器进行了独立，如果需要这里可以进行安装
cd .\blogDemo\
npm install hexo-server --save


    .
    ├── _config.yml  //主要配置文件
    ├── package.json // 插件管理文件
    ├── scaffolds // 文件模板管理
    ├── source
    |   ├── _drafts
    |   └── _posts // 新建的文章在这里
    └── themes // 主体相关文件</code></pre><h2 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h2><blockquote>
<p>powerShell环境</p>
</blockquote>
<pre><code>hexo s // 或者hexo server
// 之后便可以在http://localhost:4000/打开
// hexo -s -p 3000 更改端口</code></pre><h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><blockquote>
<p>powerShell环境</p>
</blockquote>
<pre><code>hexo new 这是新文章的名字</code></pre><h2 id="提交与部署"><a href="#提交与部署" class="headerlink" title="提交与部署"></a>提交与部署</h2><ul>
<li>coding<ol>
<li>创建hexoDemo项目，创建代码仓库</li>
<li>安装hexo-deployer-git,用于git方式的部署<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li>
<li>复制仓库地址，如<a href="mailto:git@e.coding.net">git@e.coding.net</a>:kukuboy/hexodemo/hexoDemo.git</li>
<li>将文件主目录下的_confg.yml中的deploy，修改为如下 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">     type: git</span><br><span class="line">     repo:</span><br><span class="line">       coding: git@e.coding.net:kukuboy&#x2F;hexodemo&#x2F;hexoDemo.git</span><br></pre></td></tr></table></figure></li>
<li>执行部署 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d &#x2F;&#x2F; hexo deploy的缩写</span><br></pre></td></tr></table></figure></li>
<li>coding打开持续部署功能，如果没有可在项目设置功能中打开</li>
<li>选择静态网站托管，选择主目录部署</li>
<li>部署完成后即可看到指定可访问的域名</li>
</ol>
</li>
</ul>
<h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1>]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>微信测试号</title>
    <url>/2020/08/26/%E5%BE%AE%E4%BF%A1%E6%B5%8B%E8%AF%95%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="微信测试号开发"><a href="#微信测试号开发" class="headerlink" title="微信测试号开发"></a>微信测试号开发</h1><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><p><a href="https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html" target="_blank" rel="noopener">微信公众号开发文档</a></p>
<p><a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login" target="_blank" rel="noopener">微信测试号申请平台</a></p>
<p><a href="http://mp.weixin.qq.com/debug/" target="_blank" rel="noopener">微信接口在线调试平台</a></p>
<h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><ol>
<li>在<a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login" target="_blank" rel="noopener">微信测试号申请平台</a>申请自己的测试号并关注</li>
<li>在<a href="http://mp.weixin.qq.com/debug/" target="_blank" rel="noopener">微信接口在线调试平台</a>获取token</li>
<li>在<a href="http://mp.weixin.qq.com/debug/" target="_blank" rel="noopener">微信接口在线调试平台</a>利用已获得token查询自己菜单</li>
<li>根据<a href="https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html" target="_blank" rel="noopener">微信公众号开发文档</a>记录的自定义菜单创建json格式，自定义自己的菜单json</li>
<li>在<a href="http://mp.weixin.qq.com/debug/" target="_blank" rel="noopener">微信接口在线调试平台</a>利用创建菜单接口创建自己的自定义菜单</li>
</ol>
]]></content>
      <categories>
        <category>微信</category>
        <category>测试号</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>微信测试号</tag>
        <tag>微信公众号开发</tag>
      </tags>
  </entry>
  <entry>
    <title>沪港通</title>
    <url>/2020/07/31/%E6%B2%AA%E6%B8%AF%E9%80%9A/</url>
    <content><![CDATA[<h1 id="沪港通"><a href="#沪港通" class="headerlink" title="沪港通"></a>沪港通</h1><ol>
<li><p>沪股通</p>
<pre><code>《上海证券交易所沪港通业务实施办法规定》，沪股通股票包括以下范围内的股票
（1） 上证180指数成分股
（2） 上证380指数成分股
（3） A+H股上市公司的本所上市A股
 在本所上市公司股票风险警示板交易的互票（即ST,*ST股票和退市整理股票），暂停上市的股票，以外币报价交易的股票（即B股）和具有本所认定的其他特殊情形的股票，不纳入沪股通股票。经监管所机构批准，本所可以调和智能沪股通股票的范围</code></pre></li>
<li><p>港股通</p>
<pre><code>（1）恒生综合大型股指数的成分股
（2）恒生综合中型股指数的成分股
（3）A+H上市公司的H股
本所上市A股为风险警示版股票或者暂停上市股票的A+H股上市公司的相应H股，同时有股票在本所以外的内地证券交易所上市的发行人的股票，在联交所以港币以外货币报价交易的股票和具有本所认定的其他特殊情形的股票，不纳入港股通股票</code></pre></li>
</ol>
]]></content>
      <categories>
        <category>金融</category>
        <category>股票</category>
        <category>沪港通</category>
      </categories>
      <tags>
        <tag>沪港通</tag>
      </tags>
  </entry>
  <entry>
    <title>有限责任公司</title>
    <url>/2020/07/27/%E6%9C%89%E9%99%90%E8%B4%A3%E4%BB%BB%E5%85%AC%E5%8F%B8/</url>
    <content><![CDATA[<h1 id="有限责任有限公司"><a href="#有限责任有限公司" class="headerlink" title="有限责任有限公司"></a>有限责任有限公司</h1><blockquote>
<p>有限责任公司的股东以其认缴的出资额为限对公司承担责任；公司以其全部资产对其债务承担责任的公司<br>有限责任公司中，执行董事可以兼任公司经理</p>
</blockquote>
<h2 id="股权转让"><a href="#股权转让" class="headerlink" title="股权转让"></a>股权转让</h2><ol>
<li>有限责任公司的股东之间可以相互转让其全部或者部分股权</li>
<li>股东向股东以外的人转让股权，应当经其他股东半数同意。股东应就其股权转让事项书面通知其他股东征求同意，其他股东自接到书面通知之日起满30日内未答复的，视为同意转让。其他股东半数以上不同意转让的，不同意的股东应当购买该转让的股东，不购买的，视为同意转让</li>
<li>经股东同意转让的股权，在同等条件下，其他股东有优先购买权。两个以上股东主张行使优先购买权的，协商确定各自的购买比例，协商不成的，按照转让是各自的出资比例行使优先购买权</li>
<li>公司章程对股权转让另有规定的，从起规定</li>
<li>自然人股东死亡后，其合法继承人可以继承股东资格，但是，公司章程另有规定的除外</li>
</ol>
]]></content>
      <categories>
        <category>金融</category>
      </categories>
      <tags>
        <tag>有限责任有限公司</tag>
        <tag>股权转让</tag>
      </tags>
  </entry>
  <entry>
    <title>组件挂载式使用</title>
    <url>/2020/11/10/%E7%BB%84%E4%BB%B6%E6%8C%82%E8%BD%BD%E5%BC%8F%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><h2 id="关键文件dialog-js"><a href="#关键文件dialog-js" class="headerlink" title="关键文件dialog.js"></a>关键文件dialog.js</h2><pre><code>/*
* @Description:
* @Author: 水印红枫
* @Date: 2020-07-02 16:46:07
* @LastEditors: 水印红枫
*/

import Vue from &quot;vue&quot;;

import Toast from &quot;./toast&quot;;

const Dialog = {
install(Vue) {
    Object.defineProperty(Vue.prototype, &quot;$Dialog&quot;, {
    value: this,
    writable: false
    });
},
Toast(options = {}) {
    const ToastFrame = Vue.extend(Toast);
    let vm = document.getElementById(&quot;toast&quot;);
    if (vm !== null) {
    document.body.removeChild(vm);
    }
    let div = document.createElement(&quot;div&quot;);
    div.id = &quot;Toast&quot;;
    document.body.appendChild(div);
    let $vm = new ToastFrame({
    el: &quot;#Toast&quot;
    });
    if (typeof options === &quot;object&quot;) {
    Object.assign($vm, options);
    } else if (typeof options === &quot;string&quot; || typeof options === &quot;number&quot;) {
    $vm.content = options;
    }
},
}
export default Dialog;</code></pre><h2 id="引入方法"><a href="#引入方法" class="headerlink" title="引入方法"></a>引入方法</h2><pre><code>__在main.js中使用vue.use即可__

import Vue from &quot;vue&quot;;
import dialog from &quot;@/util/dialog/dialog&quot;;
Vue.use(dialog);</code></pre><h2 id="组件相关更改"><a href="#组件相关更改" class="headerlink" title="组件相关更改"></a>组件相关更改</h2><pre><code>接受数据同样使用props

props:{
    data:{
        type: Object,
        default:()=&gt;{
            return {text : &quot;&quot;}
        }
    },
    id:{
        type: String,
        default:&quot;111&quot;
    },
    dialogAction: {
        type: Function,
        default: value =&gt; {
            return value;
        }
    }
}

销毁不再使用v-show或v-if,使用

close() {
  this.dialogAction(&quot;close&quot;);
  let vm = document.getElementById(&quot;Toast&quot;);
  if (vm !== null) {
    document.body.removeChild(vm);
  }
},</code></pre><h2 id="组件使用"><a href="#组件使用" class="headerlink" title="组件使用"></a>组件使用</h2><pre><code>this.$Dialog.Toast({
    data:{},
    id:&quot;222&quot;,
    dialogAction: val =&gt; {
        console.log(val)
    }
})

该函数可接受关闭回馈以及组件向外传递数据</code></pre>]]></content>
      <categories>
        <category>前端</category>
        <category>vue</category>
        <category>组件</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>组件</tag>
      </tags>
  </entry>
  <entry>
    <title>网站信息</title>
    <url>/2020/09/14/%E7%BD%91%E7%AB%99%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h1 id="网站采用技术-hexo"><a href="#网站采用技术-hexo" class="headerlink" title="网站采用技术 hexo"></a>网站采用技术 hexo</h1><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">官方文档</a></p>
<h1 id="网站采用主题-butterfly"><a href="#网站采用主题-butterfly" class="headerlink" title="网站采用主题 butterfly"></a>网站采用主题 butterfly</h1><p><a href="https://demo.jerryc.me/" target="_blank" rel="noopener">官方文档</a></p>
<h1 id="网站评论支持-leancloud-valine"><a href="#网站评论支持-leancloud-valine" class="headerlink" title="网站评论支持 leancloud valine"></a>网站评论支持 leancloud valine</h1><p><a href="https://www.leancloud.cn/" target="_blank" rel="noopener">官方文档</a><br><a href="http://blog.dingyahui.top/2020/09/15/评论支持leancloudvaline/">技术使用介绍</a></p>
<h1 id="网站娱乐支持-hexo-douban"><a href="#网站娱乐支持-hexo-douban" class="headerlink" title="网站娱乐支持 hexo-douban"></a>网站娱乐支持 hexo-douban</h1><p><a href="https://github.com/mythsman/hexo-douban/" target="_blank" rel="noopener">官方文档</a></p>
]]></content>
      <categories>
        <category>网站</category>
      </categories>
      <tags>
        <tag>主题</tag>
        <tag>引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化配置</title>
    <url>/2020/09/03/%E6%A0%BC%E5%BC%8F%E5%8C%96%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="vscode-setting-json配置文件配置"><a href="#vscode-setting-json配置文件配置" class="headerlink" title="vscode setting.json配置文件配置"></a>vscode setting.json配置文件配置</h1><blockquote>
<p>安装扩展，可根据代码提示自行选装</p>
<p>vuter<br>eslint<br>tslint<br>fileheader<br>Todo Dree</p>
</blockquote>
<pre><code>{
// 自动保存
&quot;files.autoSave&quot;: &quot;onFocusChange&quot;,
&quot;editor.formatOnSave&quot;: false, // 不要和其他格式化同时开启，冲突会陷入死循环
&quot;editor.fontSize&quot;: 14,
&quot;editor.formatOnType&quot;: false,
// eslint
&quot;editor.codeActionsOnSave&quot;: {
    &quot;source.fixAll.eslint&quot;: true
},
// vuter
&quot;vetur.format.defaultFormatter.ts&quot;: &quot;prettier-tslint&quot;,
&quot;vetur.format.defaultFormatter.html&quot;: &quot;js-beautify-html&quot;,
&quot;vetur.format.options.tabSize&quot;: 4,
&quot;vetur.format.options.useTabs&quot;: true,
// tslint
&quot;tslint.autoFixOnSave&quot;: false,
&quot;tslint.enable&quot;: false
// 推荐主题
&quot;workbench.colorTheme&quot;: &quot;Monokai&quot;,
// git
&quot;git.autofetch&quot;: true,
&quot;git.enableSmartCommit&quot;: true,
// fileheader
&quot;fileheader.configObj&quot;: {
    &quot;createFileTime&quot;: true, //设置为true则为文件新建时候作为date，否则注释生成时间为date
    &quot;autoAdd&quot;: false, //自动生成注释，老是忘记的同学可以设置
    &quot;annotationStr&quot;: {
    &quot;head&quot;: &quot;/*&quot;,
    &quot;middle&quot;: &quot; * @&quot;,
    &quot;end&quot;: &quot; */&quot;,
    &quot;use&quot;: true //设置自定义注释可用
    },
    &quot;headInsertLine&quot;: {
    &quot;php&quot;: 2
    }
},
&quot;fileheader.cursorMode&quot;: {
    &quot;description&quot;: &quot;&quot;,
    &quot;param &quot;: &quot;&quot;,
    &quot;return&quot;: &quot;&quot;
},
&quot;fileheader.customMade&quot;: {
    &quot;Description&quot;: &quot;&quot;, //文件内容描述
    &quot;Author&quot;: &quot;&quot;, //编辑人
    &quot;Date&quot;: &quot;Do not edit&quot;, //时间
    &quot;LastEditors&quot;: &quot;&quot; // 最后编辑人
},
// Todo Dree
&quot;todo-tree.tree.showScanModeButton&quot;: false,
//尺寸缩小，与ctrl -同等功能
&quot;window.zoomLevel&quot;: -1,
}</code></pre>]]></content>
      <categories>
        <category>前端</category>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>vscode</tag>
        <tag>格式化</tag>
        <tag>setting.json配置</tag>
      </tags>
  </entry>
  <entry>
    <title>期货交易</title>
    <url>/2020/07/28/%E6%9C%9F%E8%B4%A7%E4%BA%A4%E6%98%93/</url>
    <content><![CDATA[<h1 id="期货交易"><a href="#期货交易" class="headerlink" title="期货交易"></a>期货交易</h1><blockquote>
<p>期货交易具有高信用的特征，集中表现为期货交易的保证金制度</p>
</blockquote>
<h2 id="期货交易所"><a href="#期货交易所" class="headerlink" title="期货交易所"></a>期货交易所</h2><blockquote>
<p>由国务院期货监督管路机构审批。期货交易所不以营利为目的，按照其章程的规定实行自律管理。期货交易所以其全部财产承担民事责任。期货交易所的负责人由国务院监督管理机构任免，期货交易所履行下列职责</p>
</blockquote>
<ol>
<li>提供提货交易的场所，设施和服务</li>
<li>设计期货合约，安排期货合约上市</li>
<li>组织并监督期货交易，结算和交割</li>
<li>为期货交易提供集中履约担保</li>
<li>按照章程和交易规则对会员进行监督管理</li>
<li>国务院期货监督管理机构规定的其他职责</li>
</ol>
<blockquote>
<p>经中国证监监督管理委员会批准，期货交易所可以采取会员制或者公司制的组织形式，会员制期货交易所的注册资本划分为均等份额，由会员出资认缴。期货交易所的会员是指根据有关法律，行政法规和规章的规定，经交易所批准，有权在交易所从事交易或者结算业务的在中华人民共和国境内登记注册的企业法人或者其他经济组织。交易所会员按照业务范围分为期货公司和非期货公司微信。会员大会是期货交易所的权力机构，由全体会员组成。期货交易所设理事会，每届任期3年，理事会是会员大会的常设机构，对会员大会负责。会员大会由理事会召集，一般情况下每年召开一次。<br>期货交易所可以实行会员分级结算制度。实行会员分级结算制度的交易所的会员分为结算会员和非结算会员。根据业务范围不同，结算会员可分为交易结算会员，全面结算会员，特别结算会员和交易会员</p>
</blockquote>
<h2 id="期货公司设立的条件"><a href="#期货公司设立的条件" class="headerlink" title="期货公司设立的条件"></a>期货公司设立的条件</h2><blockquote>
<p>申请设立期货公司，应当符合《中华人民共和国公司法》，并且</p>
</blockquote>
<ol>
<li>注册资本最低限额为人民币3000万元</li>
<li>董事，监事，高级管理人员具备任职条件，从业人员具有期货从业资格</li>
<li>有符合法律，行政法规规定的公司章程</li>
<li>主要股东以及实际控制人具有持续盈利能力，信誉良好，最近三年无重大违法违规纪律</li>
<li>有合格的经营场所和业务设施</li>
<li>有健全的风险管理和内部控制制度</li>
<li>国务院期货监督管理机构规定的其他条件</li>
</ol>
<blockquote>
<p>国务院期货监督管理机构根据审慎监管原则和各项业务的风险程度，可以提高注册资本最低限额。注册资本应当是实缴资本。股本应当以货币或者期货公司经营必须的非货币财产出资，货币出资比例不得低于85%<br>国务院期货监督机构应当在手里期货公司设立申请之日起6个月内，根据审慎监管原则进行审查，做出批准或者不批准的决定。未经国务院期货监督管理机构批准，任何单位和隔热不得委托或者接受他人委托持有或者管理期货公司的股权</p>
</blockquote>
]]></content>
      <categories>
        <category>金融</category>
        <category>期货交易所</category>
      </categories>
      <tags>
        <tag>期货交易所</tag>
        <tag>期货交易</tag>
      </tags>
  </entry>
  <entry>
    <title>算法</title>
    <url>/2021/04/02/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><blockquote>
<p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解   。<br>贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择。</p>
</blockquote>
<p><strong>使用贪心算法前要先证明或了解算法的可行性</strong><br><strong>最小生成树Prim算法,最小生成树Kruskal算法都是贪心算法很好的实践</strong></p>
<h2 id="最小生成树Prim算法"><a href="#最小生成树Prim算法" class="headerlink" title="最小生成树Prim算法"></a>最小生成树Prim算法</h2><pre><code>适用情况，加权连通图

首先随便选择一个顶点，作为顶点集，然后选择其他距此顶点集最近的顶点，加入到顶点集中，依次反复</code></pre><h2 id="最小生成树Kruskal算法"><a href="#最小生成树Kruskal算法" class="headerlink" title="最小生成树Kruskal算法"></a>最小生成树Kruskal算法</h2><pre><code>适用情况，加权连通图

首先把所有的边排序，然后将最小的边的顶点作为顶点集，然后查找下一条最小的边，判断边的两个顶点是否加入到了顶点集中，没有则加入，依次反复</code></pre><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><ul>
<li><p>介绍</p>
<ul>
<li><p>数组完成排序后，我们可以放置两个指针 ii 和 jj，其中 ii 是慢指针，而 jj 是快指针。只要 nums[i] = nums[j]nums[i]=nums[j]，我们就增加 j以跳过重复项。</p>
</li>
<li><p>当我们遇到 nums[j] !=nums[i] 时，跳过重复项的运行已经结束，因此我们必须把它（nums[j]nums[j]）的值复制到 nums[i + 1]nums[i+1]。然后递增 ii，接着我们将再次重复相同的过程，直到 jj 到达数组的末尾为止。</p>
</li>
</ul>
</li>
<li><p>复杂度分析</p>
<ul>
<li><p>时间复杂度：O(n)O(n)，假设数组的长度是 nn，那么 ii 和 jj 分别最多遍历 nn 步。</p>
</li>
<li><p>空间复杂度：O(1)O(1)。</p>
</li>
</ul>
</li>
</ul>
<pre><code>          删除有序数组中的重复项 II
       给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。

       不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。



       说明：

       为什么返回数值是整数，但输出的答案是数组呢？

       请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

       你可以想象内部操作如下:

       // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
       int len = removeDuplicates(nums);

       // 在函数里修改输入数组对于调用者是可见的。
       // 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
       for (int i = 0; i &lt; len; i++) {
           print(nums[i]);
       }


       示例 1：

       输入：nums = [1,1,1,2,2,3]
       输出：5, nums = [1,1,2,2,3]
       解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。
       示例 2：

       输入：nums = [0,0,1,1,1,1,2,3,3]
       输出：7, nums = [0,0,1,1,2,3,3]
       解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的元素。


       提示：

       0 &lt;= nums.length &lt;= 3 * 104
       -104 &lt;= nums[i] &lt;= 104
       nums 已按升序排列


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">        <span class="comment">// 利用排序的指针方案</span></span><br><span class="line"><span class="keyword">var</span> removeDuplicates = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = nums.length</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">let</span> slow = <span class="number">2</span>, fast = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span>(fast &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[fast]!==nums[slow<span class="number">-2</span>])&#123;</span><br><span class="line">            nums[slow]=nums[fast]</span><br><span class="line">            ++slow</span><br><span class="line">        &#125;</span><br><span class="line">        ++fast</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre><h1 id="中心扩展法"><a href="#中心扩展法" class="headerlink" title="中心扩展法"></a>中心扩展法</h1><ul>
<li><p>介绍</p>
<ul>
<li>这里主要用来解决回文串，枚举每一个可能的回文中心，然后用两个指针分别向左右两边拓展，当两个指针指向的元素相同的时候就拓展，否则停止拓展。</li>
</ul>
</li>
<li><p>复杂度分析</p>
<ul>
<li>时间复杂度：O(n^2)。</li>
<li>空间复杂度：O(1)。</li>
</ul>
</li>
</ul>
<pre><code>     回文子串

    给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

    具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。



    示例 1：

    输入：&quot;abc&quot;
    输出：3
    解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;
    示例 2：

    输入：&quot;aaa&quot;
    输出：6
    解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;


    提示：

    输入的字符串长度不会超过 1000 。


<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> countSubstrings = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> n = s.length</span><br><span class="line">    <span class="keyword">let</span> sum=<span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;n*<span class="number">2</span><span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="built_in">Math</span>.floor(i/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">let</span> y = <span class="built_in">Math</span>.ceil(i/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">while</span>(x&gt;=<span class="number">0</span>&amp;&amp;y&lt;n&amp;&amp;s[x]===s[y])&#123;</span><br><span class="line">            sum++</span><br><span class="line">            x--</span><br><span class="line">            y++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><ul>
<li><p>介绍</p>
<ul>
<li><p>基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解</p>
</li>
<li><p>一般需要找出之间的关系，即</p>
<pre><code>p[i][j] = {
              p[i+1][j-1] i &lt; j
              true i===j
          }</code></pre></li>
</ul>
</li>
<li><p>复杂度分析</p>
<ul>
<li>时间复杂度：O(n^2)，其中 nn 是字符串的长度。动态规划的状态总数为 O(n^2)，对于每个状态，我们需要转移的时间为 O(1)。</li>
<li>空间复杂度：O(n^2)，即存储动态规划所需数组的空间</li>
</ul>
</li>
</ul>
<pre><code>    最长回文子串

    给你一个字符串 s，找到 s 中最长的回文子串。



    示例 1：

    输入：s = &quot;babad&quot;
    输出：&quot;bab&quot;
    解释：&quot;aba&quot; 同样是符合题意的答案。
    示例 2：

    输入：s = &quot;cbbd&quot;
    输出：&quot;bb&quot;
    示例 3：

    输入：s = &quot;a&quot;
    输出：&quot;a&quot;
    示例 4：

    输入：s = &quot;ac&quot;
    输出：&quot;a&quot;


    提示：

    1 &lt;= s.length &lt;= 1000
    s 仅由数字和英文字母（大写和/或小写）组成

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> longestPalindrome = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(s.length).fill(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i <span class="keyword">in</span> arr)</span><br><span class="line">        arr[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(s.length).fill(<span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">let</span> max = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = s.length<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j = i; j&lt;s.length; j++)&#123;</span><br><span class="line">            arr[i][j] = i===j || (i+<span class="number">1</span>===j &amp;&amp; s[i]===s[j]) || (arr[i+<span class="number">1</span>][j<span class="number">-1</span>] &amp;&amp; s[i]===s[j])</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j]&amp;&amp;j-i&gt;max[<span class="number">0</span>])</span><br><span class="line">                max=[j-i,i,j] </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.slice(max[<span class="number">1</span>],max[<span class="number">2</span>]+<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre><h1 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h1><ul>
<li>介绍<ul>
<li>二分查找法主要用于有序队列，其实无序也可以用，只是效率较差，可根据队列规律取舍</li>
<li>在有序队里中<ol>
<li>先找到中间左边</li>
<li>判断去找的值是不是满足 arr[left]&lt;=x&lt;=arr[mid]</li>
<li>如果满足就在左边的队里中使用二分法查找，否则就在右边的队里中寻找</li>
<li>当left&gt;=right，或者arr[mid]===x,则查找结束</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>复杂度分析</p>
<ul>
<li>时间复杂度：O(n)，其中 nn 是数组}nums 的长度。最坏情况下数组元素均相等且不为target，我们需要访问所有位置才能得出结果。</li>
<li>空间复杂度：O(1)。</li>
</ul>
</li>
</ul>
<pre><code>         搜索旋转排序数组 II
    已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。

    在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。

    给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。



    示例 1：

    输入：nums = [2,5,6,0,0,1,2], target = 0
    输出：true
    示例 2：

    输入：nums = [2,5,6,0,0,1,2], target = 3
    输出：false


    提示：

    1 &lt;= nums.length &lt;= 5000
    -104 &lt;= nums[i] &lt;= 104
    题目数据保证 nums 在预先未知的某个下标上进行了旋转
    -104 &lt;= target &lt;= 104


    进阶：

    这是 搜索旋转排序数组 的延伸题目，本题中的 nums  可能包含重复元素。
    这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ef = <span class="function">(<span class="params">left,right</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = <span class="built_in">parseInt</span>((left+right)/<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]===target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left&gt;=right)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[left]&lt;target&amp;&amp;target&lt;nums[mid])</span><br><span class="line">            <span class="keyword">return</span> ef(left,mid,<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> ef(left,mid,<span class="number">1</span>) || ef(mid+<span class="number">1</span>,right)        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ef(<span class="number">0</span>,nums.length<span class="number">-1</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><blockquote>
<p>题目来源</p>
<blockquote>
<p>作者：LeetCode-Solution<br>链接：<a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-yec2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-yec2/</a><br>来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>贪心算法</tag>
        <tag>最小生成树Prim算法</tag>
        <tag>最小生成树Kruskal算法</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>网页初始化样式</title>
    <url>/2020/08/31/%E7%BD%91%E9%A1%B5%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="全局样式"><a href="#全局样式" class="headerlink" title="全局样式"></a>全局样式</h1><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>  &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">    // cursor: pointer;</span><br><span class="line">    <span class="selector-tag">outline</span>: 0;</span><br><span class="line">    <span class="selector-tag">-webkit-tap-highlight-color</span>: <span class="selector-tag">rgba</span>(0, 0, 0, 0);</span><br><span class="line">    <span class="comment">/*iOS会在元素周围显示橙色的外框，以表明该元素被tap了。如果你想自己实现tap时的响应效果，可以用以下方法“去除”这个高亮效果*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="comment">/* 禁止长按选中事件 */</span></span><br><span class="line">    <span class="attribute">-webkit-user-select</span>: none;</span><br><span class="line">    <span class="attribute">-moz-user-select</span>: none;</span><br><span class="line">    <span class="attribute">-ms-user-select</span>: none;</span><br><span class="line">    <span class="attribute">user-select</span>: none;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    // position: fixed; // 此项开启可防止ios中的滑动</span><br><span class="line">    <span class="comment">/* ios页面主题限制在安全区域内 */</span></span><br><span class="line">    <span class="selector-tag">padding-bottom</span>: <span class="selector-tag">constant</span>(<span class="selector-tag">safe-area-insert-bottom</span>);</span><br><span class="line">    <span class="selector-tag">padding-bottom</span>: <span class="selector-tag">env</span>(<span class="selector-tag">safe-area-insert-bottom</span>);</span><br><span class="line">&#125;</span><br><span class="line">// 更改盒模型</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 深色模式适配 */</span></span><br><span class="line"><span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">    <span class="attribute">color-scheme</span>: light dark;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#ffffff</span>;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme:</span> dark) &#123;</span><br><span class="line">    <span class="selector-pseudo">:root</span> &#123;</span><br><span class="line">        <span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>) <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 共用样式</span><br><span class="line"><span class="selector-class">.touchScrollY</span> &#123;</span><br><span class="line">    <span class="comment">/* 增加该属性，可以增加弹性 */</span></span><br><span class="line">    <span class="attribute">overflow-y</span>: auto;</span><br><span class="line">    <span class="attribute">-webkit-overflow-scrolling</span>: touch;</span><br><span class="line">&#125;</span><br><span class="line">// 模糊化处理</span><br><span class="line"><span class="selector-class">.filterBlur</span> &#123;</span><br><span class="line">    <span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">10px</span>);</span><br><span class="line">    <span class="attribute">-webkit-filter</span>: <span class="built_in">blur</span>(<span class="number">10px</span>);</span><br><span class="line">    <span class="attribute">pointer-events</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*-----全局样式结束-------*/</span></span><br><span class="line"><span class="comment">/*--------盒模型兼容开始-------*/</span></span><br><span class="line"><span class="selector-class">.flex</span> &#123;</span><br><span class="line">    // display: box;</span><br><span class="line">    <span class="comment">/*Android 4.4*/</span></span><br><span class="line">    <span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</span><br><span class="line">    <span class="comment">/*iOS 6-, Safari 3.1-6*/</span></span><br><span class="line">    <span class="selector-tag">display</span>: <span class="selector-tag">-moz-box</span>;</span><br><span class="line">    <span class="comment">/*Firefox 19*/</span></span><br><span class="line">    <span class="selector-tag">display</span>: <span class="selector-tag">-ms-flexbox</span>;</span><br><span class="line">    <span class="comment">/*IE 10*/</span></span><br><span class="line">    <span class="selector-tag">display</span>: <span class="selector-tag">-webkit-flex</span>;</span><br><span class="line">    <span class="comment">/*Chrome*/</span></span><br><span class="line">    <span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;</span><br><span class="line">    <span class="comment">/*Opera 12.1, Firefox 20+*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*主轴竖直*/</span></span><br><span class="line"><span class="selector-class">.flex_column</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-box-orient</span>: vertical;</span><br><span class="line">    <span class="attribute">-webkit-flex-direction</span>: column;</span><br><span class="line">    <span class="attribute">-moz-flex-direction</span>: column;</span><br><span class="line">    <span class="attribute">-ms-flex-direction</span>: column;</span><br><span class="line">    <span class="attribute">-o-flex-direction</span>: column;</span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">&#125;</span><br><span class="line">// 排列方向</span><br><span class="line"><span class="selector-class">.flex_wrap</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-box-lines</span>: multiple;</span><br><span class="line">    <span class="attribute">-webkit-flex-direction</span>: wrap;</span><br><span class="line">    <span class="attribute">-moz-flex-direction</span>: wrap;</span><br><span class="line">    <span class="attribute">-ms-flex-direction</span>: wrap;</span><br><span class="line">    <span class="attribute">-o-flex-direction</span>: wrap;</span><br><span class="line">    <span class="attribute">flex-direction</span>: wrap;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*元素两端排列*/</span></span><br><span class="line"><span class="selector-class">.flex_jus_between</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-box-pack</span>: space-between;</span><br><span class="line">    <span class="attribute">-webkit-justify-content</span>: space-between;</span><br><span class="line">    <span class="attribute">-moz-justify-content</span>: space-between;</span><br><span class="line">    <span class="attribute">-ms-justify-content</span>: space-between;</span><br><span class="line">    <span class="attribute">-o-justify-content</span>: space-between;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-between;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*元素两端间距排列*/</span></span><br><span class="line"><span class="selector-class">.flex_jus_around</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-box-pack</span>: space-around;</span><br><span class="line">    <span class="attribute">-webkit-justify-content</span>: space-around;</span><br><span class="line">    <span class="attribute">-moz-justify-content</span>: space-around;</span><br><span class="line">    <span class="attribute">-ms-justify-content</span>: space-around;</span><br><span class="line">    <span class="attribute">-o-justify-content</span>: space-around;</span><br><span class="line">    <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*元素两端间距排列*/</span></span><br><span class="line"><span class="selector-class">.flex_jus_center</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-box-pack</span>: center;</span><br><span class="line">    <span class="attribute">-webkit-justify-content</span>: center;</span><br><span class="line">    <span class="attribute">-moz-justify-content</span>: center;</span><br><span class="line">    <span class="attribute">-ms-justify-content</span>: center;</span><br><span class="line">    <span class="attribute">-o-justify-content</span>: center;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*元素竖直方向居中*/</span></span><br><span class="line"><span class="selector-class">.flex-ali_i_center</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-box-align</span>: center;</span><br><span class="line">    <span class="attribute">-webkit-align-items</span>: center;</span><br><span class="line">    <span class="attribute">-moz-align-items</span>: center;</span><br><span class="line">    <span class="attribute">-ms-align-items</span>: center;</span><br><span class="line">    <span class="attribute">-o-align-items</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*多行元素竖直方向居中*/</span></span><br><span class="line"><span class="selector-class">.flex-ali_c_center</span> &#123;</span><br><span class="line">    <span class="attribute">-webkit-box-align</span>: center;</span><br><span class="line">    <span class="attribute">-webkit-align-content</span>: center;</span><br><span class="line">    <span class="attribute">-moz-align-content</span>: center;</span><br><span class="line">    <span class="attribute">-ms-align-content</span>: center;</span><br><span class="line">    <span class="attribute">-o-align-content</span>: center;</span><br><span class="line">    <span class="attribute">align-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>css初始化</tag>
      </tags>
  </entry>
  <entry>
    <title>股票</title>
    <url>/2020/07/31/%E8%82%A1%E7%A5%A8/</url>
    <content><![CDATA[<h1 id="股票"><a href="#股票" class="headerlink" title="股票"></a>股票</h1><blockquote>
<p>股票是一种有价证券，它是股份有限公司签发的证明股东所持股份的凭证。一般的股民是指以自然人身份从事股票买卖的投资者</p>
</blockquote>
<h2 id="普通股"><a href="#普通股" class="headerlink" title="普通股"></a>普通股</h2><ol>
<li>普通股票按投票权不同也划分为不同等级，如A级和B级，A级普通股没有投票权或者只有部分投票权；B级普通股则具有完全投票权，一般为公司创办人所有，目的是在股权稀释过程中掌握公司的控制权</li>
<li>根据风险特征可分为蓝筹股，成长股，收入股，周期股，防守股，概念股，投机股</li>
</ol>
<ul>
<li>（1） 蓝筹股：指具备稳定的盈利能力，在所属行业中占有重要支配地位，能定期分派有货股利的大公司所发行的普通股</li>
<li>（2） 成长股：指销售额和利润迅速提升，启发张显著快鱼同行业的企业所发行的股票</li>
<li>（3） 收入股：也叫高息股，指能支配较高收益的普通股，其公司业绩比较稳定，收入股的代表为一些公用事业股票</li>
<li>（4） 周期股：指收益随着经济周期波动而波动的公司所发行的股票</li>
<li>（5） 防守股：指在经济衰退时期或经济发展不确定因素较多的时候，那些高于社会平均收益且具有相对稳定性的公司所发行的普通股</li>
<li>（6） 概念股：指适合某一时代潮流的公司所发行的，股价起伏较大的普通股</li>
<li>（7） 投机股：指价格极不稳定或公司前景难以确定，具有较大投机潜力的股票，在我国股票市场上，一些ST股票就是投机股的典型代表</li>
</ul>
<h2 id="优先股"><a href="#优先股" class="headerlink" title="优先股"></a>优先股</h2><blockquote>
<p>优先股票是一种特殊股票，在其股东权利，义务中附加了某些特别条件。优先股票的股息率是固定的，其持有者的股东权利受到一定限制，但在公司盈利和剩余财产的分配顺序上比普通股东享有优先权</p>
</blockquote>
]]></content>
      <categories>
        <category>金融</category>
        <category>股票</category>
      </categories>
      <tags>
        <tag>股票</tag>
      </tags>
  </entry>
  <entry>
    <title>股票上市</title>
    <url>/2020/07/31/%E8%82%A1%E7%A5%A8%E4%B8%8A%E5%B8%82/</url>
    <content><![CDATA[<h1 id="股票上市"><a href="#股票上市" class="headerlink" title="股票上市"></a>股票上市</h1><h2 id="股票上市的条件"><a href="#股票上市的条件" class="headerlink" title="股票上市的条件"></a>股票上市的条件</h2><ol>
<li>股票经国务院证券监督管理机构核准已公开发行</li>
<li>公司股本总额不低于人民币3000万元</li>
<li>公开发行的股份达到公司股份总数的25%以上；公司股本总额超过人民币4亿元的，公开发行股份的比例为10%以上</li>
<li>公司最近3年无重大违法行为，财务会计报告无虚假记载</li>
<li>证券交易所可以规定高于上述规定的上市条件，并报国务院证券监督管理机构批准</li>
</ol>
<h2 id="股票上市申请"><a href="#股票上市申请" class="headerlink" title="股票上市申请"></a>股票上市申请</h2><blockquote>
<p>申请股票上市交易，应当向证券交易所报送下列文件：上市报告书；申请股票上市的股东大会决议；公司章程；公司营业执照；依照经会计师事务所省级的公司最近3年的财务会计报告；法律意见书和上市保荐书；最近一次的招股说明书；证券交易所上市规定的其他文件</p>
</blockquote>
]]></content>
      <categories>
        <category>金融</category>
        <category>股票</category>
        <category>股票上市</category>
      </categories>
      <tags>
        <tag>股票上市</tag>
      </tags>
  </entry>
  <entry>
    <title>评论支持leancloudvaline</title>
    <url>/2020/09/15/%E8%AF%84%E8%AE%BA%E6%94%AF%E6%8C%81leancloudvaline/</url>
    <content><![CDATA[<h1 id="网站评论支持-leancloud-valine"><a href="#网站评论支持-leancloud-valine" class="headerlink" title="网站评论支持 leancloud valine"></a>网站评论支持 leancloud valine</h1><p><a href="https://www.leancloud.cn/" target="_blank" rel="noopener">官方文档</a></p>
<h1 id="代码-Valine-Admin"><a href="#代码-Valine-Admin" class="headerlink" title="代码 Valine-Admin"></a>代码 Valine-Admin</h1><blockquote>
<p>可直接在github上搜索，按照介绍使用即可，建议自己fork一个，使用自己<br>的，方便自己更改主题</p>
</blockquote>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol>
<li>首先在leancloud上注册创建应用Valine-Admin</li>
<li>进入对应的应用，点击设置 -&gt; 应用 Keys，获取AppID和AppKey</li>
<li>以Hexo主题配置文件为例，填入对应的地方</li>
</ol>
<pre><code>valine:
enable: true
appId: AppID
appKey: AppKey
notify: false
verify: false
visitor: true
avatar: &apos;mp&apos; # Gravatar style : mp/identicon/monsterid/wavatar/retro/hide
pageSize: 10
placeholder: &apos;just go go&apos; # Comment Box placeholder</code></pre><ol start="4">
<li><p>评论存储</p>
<blockquote>
<p>有些已默认配置好，以后可在此项查看评论，并删除评论</p>
</blockquote>
<ul>
<li>查看评论<br>   点击 存储 -&gt; 结构化数据，选择创建Class，名称Comment，其他保持默认，以后就可在此Class内查看</li>
<li>文章阅读量统计<br>   点击 存储 -&gt; 结构化数据，选择创建Class，名称Counter，其他保持默认，以后就可在此Class内查看</li>
</ul>
</li>
<li><p>云引擎</p>
<ul>
<li>选择云引擎-&gt;部署</li>
<li>选择git部署，填入github地址，部署即可 （如<a href="https://github.com/kukuboy/Valine-Admin）" target="_blank" rel="noopener">https://github.com/kukuboy/Valine-Admin）</a></li>
<li>云引擎-&gt;设置:：</li>
<li>填写各变量以及内容，这里不再具体详解，valine-admin项目的rendme已经介绍，其他各博客也有</li>
<li>云引擎-&gt;定时任务</li>
<li>自动唤醒：名称自定义，选择生产环境，self_wake，x选择corn表达式 - 0 */20 7-23 * * ? </li>
<li>补发邮件：名称自定义，选择生产环境 - resend_mails，x选择corn表达式 - 0 0 8 * * ?</li>
</ul>
</li>
<li><p>设置</p>
</li>
</ol>
<blockquote>
<p>这里需要自己由自己的域名，建议还是买一个域名，其实还是挺便宜的，一年也就几块钱，用处很多，因为这里国家要求，leancloud需要检查备案信息，所以还是花几块钱买个吧</p>
</blockquote>
<ul>
<li>安全中心：在Web 安全域名中填入自己博客地址</li>
<li>域名绑定：可自己定义一个二级域名，不要与博客域名相同，不要与博客域名相同，不要与博客域名相同，重要的事情说三遍，这个域名是用来评论管理的，按照介绍绑定以及解析即可</li>
</ul>
<p>如有问题可评论留下你的问题，或者私发邮件给博主，博主是个小博主，还是会尽力回的</p>
]]></content>
      <categories>
        <category>博客</category>
        <category>评论</category>
      </categories>
      <tags>
        <tag>leancloud</tag>
        <tag>valine</tag>
        <tag>评论</tag>
      </tags>
  </entry>
</search>
